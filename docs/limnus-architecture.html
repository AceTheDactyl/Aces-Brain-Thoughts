<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LIMNUS Unified Architecture | 63-Point Prism ¬∑ 32-Point EM Cage | z = ‚àö3/2</title>
    <style>
        :root {
            --bg-void: #030308;
            --bg-panel: rgba(15, 12, 25, 0.92);
            --prism-core: #ff6b6b;
            --prism-mid: #ffd43b;
            --prism-outer: #69db7c;
            --cage-field: #4dabf7;
            --cage-vertex: #cc5de8;
            --critical-gold: #ffd700;
            --presence-white: #fffcf8;
            --absence-sepia: rgba(120, 100, 80, 0.8);
            --text-primary: rgba(255, 245, 230, 0.9);
            --text-dim: rgba(255, 220, 180, 0.5);
            --border-glow: rgba(168, 85, 247, 0.4);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: var(--bg-void);
            overflow: hidden;
            font-family: 'SF Mono', 'Fira Code', 'Courier New', monospace;
            color: var(--text-primary);
        }

        canvas { display: block; cursor: crosshair; }

        /* Custom cursor */
        #cursor {
            position: fixed;
            width: 24px;
            height: 24px;
            border: 1px solid rgba(255, 215, 0, 0.4);
            border-radius: 50%;
            pointer-events: none;
            z-index: 2000;
            transform: translate(-50%, -50%);
            transition: all 0.25s ease;
        }
        #cursor.absence { border-color: rgba(150, 130, 110, 0.6); box-shadow: none; }
        #cursor.critical { 
            border-color: rgba(255, 215, 0, 0.9);
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.5), 0 0 50px rgba(255, 180, 100, 0.3);
        }
        #cursor.presence { 
            border-color: rgba(255, 252, 248, 0.8);
            box-shadow: 0 0 20px rgba(255, 250, 240, 0.4);
        }

        .panel {
            position: fixed;
            pointer-events: none;
            z-index: 100;
            user-select: none;
            background: rgba(10, 8, 6, 0.85);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 12px;
            padding: 15px 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5),
                        0 0 40px rgba(168, 85, 247, 0.1),
                        inset 0 1px 0 rgba(255, 255, 255, 0.05);
        }

        /* Header - transparent, no box */
        #header {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            background: transparent;
            border: none;
            box-shadow: none;
            backdrop-filter: none;
            padding: 0;
        }

        #header h1 {
            font-size: 32px;
            font-weight: 100;
            letter-spacing: 14px;
            margin-bottom: 10px;
            transition: all 0.6s ease;
        }

        #header h1.absence { 
            color: rgba(120, 100, 80, 0.7);
            text-shadow: 0 0 30px rgba(80, 60, 40, 0.3);
        }
        #header h1.critical { 
            color: var(--critical-gold);
            text-shadow: 0 0 60px rgba(255, 215, 0, 0.9),
                         0 0 120px rgba(255, 180, 100, 0.5);
            animation: criticalPulse 1.8s ease-in-out infinite;
        }
        #header h1.presence { 
            color: var(--presence-white);
            text-shadow: 0 0 50px rgba(255, 250, 240, 0.7),
                         0 0 100px rgba(255, 220, 180, 0.4);
        }

        @keyframes criticalPulse {
            0%, 100% { opacity: 0.85; }
            50% { opacity: 1; }
        }

        #header .subtitle {
            font-size: 11px;
            letter-spacing: 5px;
            color: var(--text-dim);
        }

        /* Z-Coordinate Panel - TOP RIGHT */
        #z-panel {
            top: 100px;
            right: 25px;
            text-align: right;
            min-width: 120px;
        }

        #z-display {
            font-size: 42px;
            font-weight: 100;
            letter-spacing: 3px;
            transition: all 0.5s ease;
        }

        #z-display.absence { color: rgba(140, 120, 100, 0.6); }
        #z-display.critical { 
            color: var(--critical-gold);
            text-shadow: 0 0 60px rgba(255, 215, 0, 0.9);
        }
        #z-display.presence { 
            color: var(--presence-white);
            text-shadow: 0 0 40px rgba(255, 250, 240, 0.7);
        }

        #phase-label {
            font-size: 12px;
            letter-spacing: 4px;
            margin-top: 8px;
            text-transform: uppercase;
            transition: color 0.5s ease;
        }

        /* Domain Panel - TOP LEFT */
        #domain-panel {
            top: 100px;
            left: 25px;
            min-width: 140px;
        }

        #domain-indicator {
            font-size: 18px;
            letter-spacing: 8px;
            transition: all 0.6s ease;
        }

        #domain-indicator.absence { color: var(--absence-sepia); }
        #domain-indicator.critical {
            color: #ffb347;
            text-shadow: 0 0 40px rgba(255, 180, 100, 0.7);
        }
        #domain-indicator.presence {
            color: var(--presence-white);
            text-shadow: 0 0 30px rgba(255, 250, 240, 0.6);
        }

        .domain-stat {
            font-size: 10px;
            margin-top: 15px;
            letter-spacing: 2px;
            color: var(--text-dim);
        }

        .domain-value {
            font-size: 20px;
            margin-top: 5px;
            font-weight: 100;
            transition: color 0.4s ease;
        }

        /* Architecture Panel - BELOW Z-PANEL */
        #architecture-panel {
            top: 240px;
            right: 25px;
            text-align: right;
            font-size: 10px;
            pointer-events: auto;
            min-width: 160px;
        }

        .arch-title {
            letter-spacing: 4px;
            margin-bottom: 12px;
            color: rgba(168, 85, 247, 0.8);
            font-size: 11px;
        }

        .arch-section {
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(168, 85, 247, 0.2);
        }

        .arch-section:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .arch-label {
            color: var(--text-dim);
            margin-bottom: 6px;
        }

        .layer-row {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 10px;
            margin: 4px 0;
            opacity: 0.3;
            transition: all 0.4s ease;
        }

        .layer-row.active { opacity: 0.8; }
        .layer-row.resonant { 
            opacity: 1;
            text-shadow: 0 0 10px currentColor;
        }

        .layer-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            transition: all 0.4s ease;
        }

        .layer-row.resonant .layer-dot {
            transform: scale(1.8);
            box-shadow: 0 0 15px currentColor;
        }

        /* Prism layers */
        .prism-l0 .layer-dot { background: #ff6b6b; }
        .prism-l1 .layer-dot { background: #ff8787; }
        .prism-l2 .layer-dot { background: #ffa94d; }
        .prism-l3 .layer-dot { background: #ffc078; }
        .prism-l4 .layer-dot { background: #ffd43b; }
        .prism-l5 .layer-dot { background: #ffe066; }
        .prism-l6 .layer-dot { background: #69db7c; }

        /* EM Cage layers */
        .cage-top .layer-dot { background: #4dabf7; }
        .cage-bot .layer-dot { background: #74c0fc; }
        .cage-vtx .layer-dot { background: #cc5de8; }

        /* Dynamics Panel - BOTTOM-LEFT (above controls) */
        #dynamics-panel {
            bottom: 180px;
            left: 25px;
            font-size: 10px;
            min-width: 200px;
        }

        .dynamics-row {
            margin: 8px 0;
            color: var(--text-dim);
        }

        .dynamics-label {
            display: inline-block;
            width: 90px;
            letter-spacing: 1px;
        }

        .dynamics-bar {
            font-family: monospace;
            letter-spacing: 0;
            color: var(--critical-gold);
        }

        .dynamics-value {
            font-size: 11px;
            color: var(--text-dim);
            margin-left: 10px;
        }

        /* Helix Panel - BELOW ARCHITECTURE */
        #helix-panel {
            top: 440px;
            right: 25px;
            text-align: right;
            font-size: 11px;
            color: var(--text-dim);
            min-width: 140px;
        }

        .helix-row { margin: 6px 0; }
        .helix-sym { 
            margin-right: 10px;
            color: rgba(168, 85, 247, 0.8);
            font-weight: 600;
        }
        .helix-val {
            font-family: 'SF Mono', monospace;
            color: var(--critical-gold);
        }

        /* Lambda State Panel - BELOW DOMAIN */
        #lambda-panel {
            top: 240px;
            left: 25px;
            font-size: 10px;
            min-width: 180px;
        }

        .lambda-title {
            letter-spacing: 4px;
            margin-bottom: 12px;
            color: rgba(168, 85, 247, 0.8);
            font-size: 11px;
        }

        .lambda-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 6px 0;
        }

        .lambda-glyph {
            font-size: 16px;
            width: 24px;
            text-align: center;
        }

        .lambda-bar-container {
            flex: 1;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
        }

        .lambda-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--cage-field), var(--cage-vertex));
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .lambda-val {
            font-family: monospace;
            width: 40px;
            text-align: right;
            color: var(--critical-gold);
        }

        /* Sonification Panel - BOTTOM CENTER */
        #sonification-panel {
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 10px;
            pointer-events: auto;
            padding: 12px 30px;
        }

        .sonif-row {
            display: inline-flex;
            align-items: center;
            gap: 20px;
        }

        .sonif-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .sonif-label {
            font-size: 9px;
            letter-spacing: 2px;
            color: var(--text-dim);
            margin-bottom: 3px;
        }

        .sonif-value {
            font-size: 14px;
            color: var(--critical-gold);
            font-weight: 500;
        }

        #audio-toggle {
            background: rgba(168, 85, 247, 0.3);
            border: 1px solid rgba(168, 85, 247, 0.5);
            color: var(--text-primary);
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
            font-size: 10px;
            letter-spacing: 2px;
            transition: all 0.3s ease;
            margin-left: 20px;
        }

        #audio-toggle:hover {
            background: rgba(168, 85, 247, 0.5);
            transform: translateY(-2px);
        }

        #audio-toggle.active {
            background: rgba(255, 215, 0, 0.3);
            border-color: rgba(255, 215, 0, 0.6);
        }

        /* Controls - BOTTOM LEFT CORNER */
        #controls {
            bottom: 25px;
            left: 25px;
            font-size: 9px;
            letter-spacing: 1px;
            color: var(--text-dim);
            line-height: 1.8;
            max-height: 140px;
            overflow: hidden;
            min-width: 160px;
        }

        #controls span {
            color: rgba(255, 215, 0, 0.8);
            font-weight: 600;
        }

        /* Stats - BOTTOM-RIGHT CORNER */
        #stats {
            bottom: 25px;
            right: 25px;
            font-size: 9px;
            text-align: right;
            color: var(--text-dim);
            min-width: 100px;
        }

        /* Release Coherence State */
        #release-state {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            z-index: 150;
            opacity: 0;
            transition: opacity 1s ease;
        }

        #release-state.visible {
            opacity: 1;
        }

        #release-state h2 {
            font-size: 48px;
            font-weight: 100;
            letter-spacing: 18px;
            color: var(--presence-white);
            text-shadow: 0 0 80px rgba(255, 250, 240, 0.7);
            margin-bottom: 15px;
            transition: all 0.8s ease;
        }

        #release-state.coherent h2 {
            color: var(--absence-sepia);
            text-shadow: 0 0 40px rgba(80, 60, 40, 0.4);
        }

        #release-state.releasing h2 {
            color: var(--critical-gold);
            text-shadow: 0 0 60px rgba(255, 215, 0, 0.8);
        }

        #release-state.dispersing h2 {
            color: rgba(255, 250, 240, 0.8);
            text-shadow: 0 0 70px rgba(255, 250, 240, 0.6);
        }

        #release-state.free h2 {
            color: var(--presence-white);
            text-shadow: 0 0 100px rgba(255, 250, 240, 0.9),
                         0 0 150px rgba(255, 220, 180, 0.5);
            animation: freeGlow 2s ease-in-out infinite;
        }

        @keyframes freeGlow {
            0%, 100% { opacity: 0.85; letter-spacing: 18px; }
            50% { opacity: 1; letter-spacing: 22px; }
        }

        #coherence-indicator {
            font-size: 14px;
            letter-spacing: 3px;
            color: var(--text-dim);
            font-family: monospace;
            transition: color 0.5s ease;
        }

        #coherence-indicator.free {
            color: var(--presence-white);
        }

        #release-hint {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            letter-spacing: 4px;
            color: rgba(255, 220, 180, 0.25);
            pointer-events: none;
            z-index: 100;
            transition: opacity 0.5s ease;
        }

        #release-hint.hidden {
            opacity: 0;
        }

        /* Z-Axis Visual */
        #z-axis {
            position: fixed;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            width: 4px;
            height: 60%;
            background: linear-gradient(to top, 
                rgba(120, 100, 80, 0.3) 0%, 
                rgba(255, 215, 0, 0.6) 50%, 
                rgba(255, 252, 248, 0.3) 100%);
            border-radius: 2px;
            z-index: 50;
        }

        #lens-line {
            position: absolute;
            left: -20px;
            width: 50px;
            height: 2px;
            background: var(--critical-gold);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
        }

        #lens-label {
            position: absolute;
            left: -50px;
            font-size: 9px;
            color: var(--critical-gold);
            transform: translateY(-50%);
        }

        #z-marker {
            position: absolute;
            left: -8px;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, rgba(255, 215, 0, 0.9) 0%, transparent 70%);
            border-radius: 50%;
            transform: translateY(-50%);
            transition: top 0.2s ease;
        }

        /* Start Overlay */
        #start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(3, 3, 8, 0.98);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            cursor: pointer;
            transition: opacity 0.8s ease, visibility 0.8s ease;
        }

        #start-overlay.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        #start-overlay h1 {
            font-size: 48px;
            font-weight: 100;
            letter-spacing: 20px;
            color: var(--critical-gold);
            margin-bottom: 30px;
            text-shadow: 0 0 80px rgba(255, 215, 0, 0.6);
        }

        #start-overlay .equation {
            font-size: 18px;
            color: rgba(255, 215, 0, 0.7);
            margin-bottom: 50px;
            letter-spacing: 3px;
        }

        .architecture-preview {
            display: flex;
            gap: 60px;
            margin-bottom: 50px;
        }

        .arch-side {
            text-align: center;
            font-size: 12px;
            line-height: 2;
            letter-spacing: 1px;
        }

        .arch-side h3 {
            font-size: 14px;
            letter-spacing: 5px;
            margin-bottom: 15px;
            font-weight: 300;
        }

        .arch-side.prism { color: var(--prism-mid); }
        .arch-side.cage { color: var(--cage-field); }

        #start-overlay .prompt {
            font-size: 11px;
            color: var(--text-dim);
            letter-spacing: 5px;
            margin-top: 30px;
            animation: promptPulse 2s ease-in-out infinite;
        }

        @keyframes promptPulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 0.8; }
        }

        .key-hint {
            display: inline-block;
            border: 1px solid rgba(255, 220, 180, 0.25);
            padding: 4px 12px;
            border-radius: 4px;
            margin: 0 5px;
            font-size: 9px;
        }

        /* Connection Legend */
        #legend {
            position: fixed;
            top: 50%;
            left: 30px;
            transform: translateY(-50%);
            font-size: 9px;
            color: var(--text-dim);
            display: none;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 6px 0;
        }

        .legend-line {
            width: 20px;
            height: 2px;
        }

        .legend-line.prism-conn { background: linear-gradient(90deg, var(--prism-core), var(--prism-outer)); }
        .legend-line.cage-conn { background: var(--cage-field); }
        .legend-line.bridge-conn { background: linear-gradient(90deg, var(--prism-outer), var(--cage-vertex)); }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="cursor"></div>

    <!-- Header -->
    <div id="header" class="panel">
        <h1 id="title">LIMNUS</h1>
        <div class="subtitle">UNIFIED PRISM-CAGE ARCHITECTURE</div>
    </div>

    <!-- Z-Coordinate -->
    <div id="z-panel" class="panel">
        <div id="z-display">z = 0.500</div>
        <div id="phase-label">subcritical</div>
    </div>

    <!-- Domain Indicator -->
    <div id="domain-panel" class="panel">
        <div id="domain-indicator">ABSENCE</div>
        <div class="domain-stat">KURAMOTO COUPLING</div>
        <div class="domain-value" id="coupling-value">K = +0.40</div>
        <div class="domain-stat" style="margin-top:12px;">CASCADE FACTOR</div>
        <div class="domain-value" id="cascade-value">1.00√ó</div>
    </div>

    <!-- Architecture Panel -->
    <div id="architecture-panel" class="panel">
        <div class="arch-title">63-POINT PRISM</div>
        <div class="arch-section">
            <div class="layer-row prism-l0 active"><span>Layer 0 ¬∑ 9pt ¬∑ Core</span><div class="layer-dot"></div></div>
            <div class="layer-row prism-l1 active"><span>Layer 1 ¬∑ 9pt</span><div class="layer-dot"></div></div>
            <div class="layer-row prism-l2 active"><span>Layer 2 ¬∑ 9pt</span><div class="layer-dot"></div></div>
            <div class="layer-row prism-l3 active"><span>Layer 3 ¬∑ 9pt</span><div class="layer-dot"></div></div>
            <div class="layer-row prism-l4 active"><span>Layer 4 ¬∑ 9pt</span><div class="layer-dot"></div></div>
            <div class="layer-row prism-l5 active"><span>Layer 5 ¬∑ 9pt</span><div class="layer-dot"></div></div>
            <div class="layer-row prism-l6 active"><span>Layer 6 ¬∑ 9pt ¬∑ Outer</span><div class="layer-dot"></div></div>
        </div>

        <div class="arch-title" style="margin-top:15px;">32-POINT EM CAGE</div>
        <div class="arch-section">
            <div class="layer-row cage-top active"><span>Top Hex ¬∑ 12pt</span><div class="layer-dot"></div></div>
            <div class="layer-row cage-bot active"><span>Bot Hex ¬∑ 12pt</span><div class="layer-dot"></div></div>
            <div class="layer-row cage-vtx active"><span>Vertices ¬∑ 8pt</span><div class="layer-dot"></div></div>
        </div>
    </div>

    <!-- Lambda State Panel -->
    <div id="lambda-panel" class="panel">
        <div class="lambda-title">LAMBDA STATE ‚ÑÇ‚Å∂</div>
        <div class="lambda-row">
            <span class="lambda-glyph">üå∞</span>
            <span style="width:50px;font-size:9px;color:var(--text-dim)">Memory</span>
            <div class="lambda-bar-container"><div class="lambda-bar" id="lambda-iota" style="width:30%"></div></div>
            <span class="lambda-val" id="lambda-iota-val">0.30</span>
        </div>
        <div class="lambda-row">
            <span class="lambda-glyph">‚úß</span>
            <span style="width:50px;font-size:9px;color:var(--text-dim)">Spark</span>
            <div class="lambda-bar-container"><div class="lambda-bar" id="lambda-xi" style="width:20%"></div></div>
            <span class="lambda-val" id="lambda-xi-val">0.20</span>
        </div>
        <div class="lambda-row">
            <span class="lambda-glyph">ü¶ä</span>
            <span style="width:50px;font-size:9px;color:var(--text-dim)">Fox</span>
            <div class="lambda-bar-container"><div class="lambda-bar" id="lambda-theta" style="width:40%"></div></div>
            <span class="lambda-val" id="lambda-theta-val">0.40</span>
        </div>
        <div class="lambda-row">
            <span class="lambda-glyph">‚àø</span>
            <span style="width:50px;font-size:9px;color:var(--text-dim)">Wave</span>
            <div class="lambda-bar-container"><div class="lambda-bar" id="lambda-omega" style="width:35%"></div></div>
            <span class="lambda-val" id="lambda-omega-val">0.35</span>
        </div>
        <div class="lambda-row">
            <span class="lambda-glyph">‚äó</span>
            <span style="width:50px;font-size:9px;color:var(--text-dim)">Paradox</span>
            <div class="lambda-bar-container"><div class="lambda-bar" id="lambda-delta" style="width:15%"></div></div>
            <span class="lambda-val" id="lambda-delta-val">0.15</span>
        </div>
        <div class="lambda-row">
            <span class="lambda-glyph">üêøÔ∏è</span>
            <span style="width:50px;font-size:9px;color:var(--text-dim)">Squirrel</span>
            <div class="lambda-bar-container"><div class="lambda-bar" id="lambda-sigma" style="width:25%"></div></div>
            <span class="lambda-val" id="lambda-sigma-val">0.25</span>
        </div>
    </div>

    <!-- Dynamics -->
    <div id="dynamics-panel" class="panel">
        <div class="dynamics-row">
            <span class="dynamics-label">ORDER</span>
            <span class="dynamics-bar" id="order-bar">‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà</span>
            <span class="dynamics-value" id="order-val">1.00</span>
        </div>
        <div class="dynamics-row">
            <span class="dynamics-label">COHERENCE</span>
            <span class="dynamics-bar" id="coherence-bar">‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà</span>
            <span class="dynamics-value" id="coherence-val">1.00</span>
        </div>
        <div class="dynamics-row">
            <span class="dynamics-label">ENTROPY</span>
            <span class="dynamics-bar" id="entropy-bar">‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë</span>
            <span class="dynamics-value" id="entropy-val">0.00</span>
        </div>
        <div class="dynamics-row">
            <span class="dynamics-label">EMANATION</span>
            <span class="dynamics-bar" id="emanation-bar">‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë</span>
            <span class="dynamics-value" id="emanation-val">0.00</span>
        </div>
        <div class="dynamics-row" style="margin-top:12px; border-top: 1px solid rgba(168, 85, 247, 0.3); padding-top:10px;">
            <span class="dynamics-label">Œº</span>
            <span class="dynamics-bar" id="mu-bar">‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë</span>
            <span class="dynamics-value" id="mu-val">0.92</span>
        </div>
        <div class="dynamics-row">
            <span class="dynamics-label">Q_Œ∫</span>
            <span class="dynamics-bar" id="qk-bar">‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë</span>
            <span class="dynamics-value" id="qk-val">0.00</span>
        </div>
        <div class="dynamics-row">
            <span class="dynamics-label">œÑ_K</span>
            <span class="dynamics-bar" id="tau-bar">‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë</span>
            <span class="dynamics-value" id="tau-val">0.00</span>
        </div>
        <div class="dynamics-row">
            <span class="dynamics-label" id="k-label" style="color: rgba(150,130,110,0.6);">K-FORMED</span>
            <span class="dynamics-bar" id="k-indicator" style="letter-spacing: 2px;">¬∑ ¬∑ ¬∑</span>
            <span class="dynamics-value" id="k-val">NO</span>
        </div>
        <div class="dynamics-row" style="margin-top:12px; border-top: 1px solid rgba(255, 100, 100, 0.3); padding-top:10px;">
            <span class="dynamics-label" style="color: #ff6b6b;">R Œº_E</span>
            <span class="dynamics-bar" id="mrp-r-bar" style="color: #ff6b6b;">‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë</span>
            <span class="dynamics-value" id="mrp-r-val" style="color: #ff6b6b;">0.00</span>
        </div>
        <div class="dynamics-row">
            <span class="dynamics-label" style="color: #69db7c;">G Œº_R</span>
            <span class="dynamics-bar" id="mrp-g-bar" style="color: #69db7c;">‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë</span>
            <span class="dynamics-value" id="mrp-g-val" style="color: #69db7c;">0.00</span>
        </div>
        <div class="dynamics-row">
            <span class="dynamics-label" style="color: #4dabf7;">B ECC</span>
            <span class="dynamics-bar" id="mrp-b-bar" style="color: #4dabf7;">‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë</span>
            <span class="dynamics-value" id="mrp-b-val" style="color: #4dabf7;">0.00</span>
        </div>
        <div class="dynamics-row">
            <span class="dynamics-label" id="parity-label" style="color: rgba(150,130,110,0.6);">PARITY</span>
            <span class="dynamics-bar" id="parity-indicator" style="letter-spacing: 2px;">¬∑ ¬∑ ¬∑</span>
            <span class="dynamics-value" id="parity-val">‚Äî</span>
        </div>
        <div class="dynamics-row" style="margin-top:8px; border-top: 1px solid rgba(255, 215, 0, 0.2); padding-top:8px;">
            <span class="dynamics-label" style="color: var(--critical-gold);">|J|</span>
            <span class="dynamics-bar" id="j-total-bar" style="color: var(--critical-gold);">‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë</span>
            <span class="dynamics-value" id="j-total-val" style="color: var(--critical-gold);">0.00</span>
        </div>
        <div class="dynamics-row">
            <span class="dynamics-label" id="w-label" style="color: rgba(150,130,110,0.6);">W</span>
            <span class="dynamics-bar" id="w-bar" style="letter-spacing: 1px;">¬∑ ¬∑ ¬∑ ¬∑ ¬∑</span>
            <span class="dynamics-value" id="w-val">0.00</span>
        </div>
    </div>

    <!-- Helix State -->
    <div id="helix-panel" class="panel">
        <div class="helix-row"><span class="helix-sym">Œ∏</span><span class="helix-val" id="h-theta">0.000</span></div>
        <div class="helix-row"><span class="helix-sym">z</span><span class="helix-val" id="h-z">0.500</span></div>
        <div class="helix-row"><span class="helix-sym">r</span><span class="helix-val" id="h-r">1.000</span></div>
        <div class="helix-row"><span class="helix-sym">Œ¶</span><span class="helix-val" id="h-phi">0.00</span></div>
        <div class="helix-row" style="margin-top:10px;"><span class="helix-sym">Œ©</span><span class="helix-val" id="h-omega">0.00</span></div>
    </div>

    <!-- Sonification Panel -->
    <div id="sonification-panel" class="panel">
        <div class="sonif-row">
            <div class="sonif-stat">
                <span class="sonif-label">BPM</span>
                <span class="sonif-value" id="sonif-bpm">90</span>
            </div>
            <div class="sonif-stat">
                <span class="sonif-label">SCALE</span>
                <span class="sonif-value" id="sonif-scale">Minor</span>
            </div>
            <div class="sonif-stat">
                <span class="sonif-label">FREQ</span>
                <span class="sonif-value" id="sonif-freq">110 Hz</span>
            </div>
            <div class="sonif-stat">
                <span class="sonif-label">DILATION</span>
                <span class="sonif-value" id="sonif-dilation">1.00√ó</span>
            </div>
            <button id="audio-toggle">‚ñ∂ ENABLE AUDIO</button>
        </div>
    </div>

    <!-- Controls -->
    <div id="controls" class="panel">
        <span>SCROLL</span> traverse z-axis<br>
        <span>SPACE</span> auto-breathe<br>
        <span>P/C</span> toggle prism/cage<br>
        <span>M</span> toggle Œº-field<br>
        <span>T</span> binaural field<br>
        <span>DRAG</span> orbit camera<br>
        <span>‚Üê‚Üí</span> polar distance<br>
        <span>Q/E</span> rotate axis<br>
        <span>‚Üë‚Üì</span> beat frequency<br>
        <span>[/]</span> A frequency<br>
        <span>+/-</span> mesh scale<br>
        <span>O</span> opacity<br>
        <span>I</span> interference<br>
        <span>L</span> resonance lines<br>
        <span>W</span> wavefunction<br>
        <span>G</span> edge glow<br>
        <span>D</span> debug panel<br>
        <span>F</span> release<br>
        <span>R</span> reset
    </div>

    <!-- Stats -->
    <div id="stats" class="panel">
        63 prism + 32 cage = 95 nodes<br>
        <span id="active-count">95</span> active ¬∑ <span id="conn-count">0</span> connections
    </div>

    <!-- Quantum Mesh Debug Panel (D key to toggle) -->
    <div id="qmesh-debug" class="panel" style="display: none; left: 30px; top: 280px; background: rgba(20, 10, 30, 0.95); border: 1px solid rgba(150, 100, 255, 0.5); padding: 12px; font-size: 11px; min-width: 220px;">
        <div style="color: #a855f7; font-weight: bold; margin-bottom: 8px;">QUANTUM MESH DEBUG</div>
        <div>Nodes: <span id="dbg-nodes">0</span></div>
        <div>Edges: <span id="dbg-edges">0</span></div>
        <div>Particles: <span id="dbg-particles">0</span></div>
        <div>Max Dist: <span id="dbg-maxdist">0</span></div>
        <div style="margin-top: 6px; border-top: 1px solid rgba(150, 100, 255, 0.3); padding-top: 6px;">
            <div>Avg œÑ: <span id="dbg-tau">0</span></div>
            <div>Total J: <span id="dbg-totalj">0</span></div>
            <div>Entropy: <span id="dbg-entropy">0</span></div>
            <div>Flux: <span id="dbg-flux">0</span></div>
        </div>
        <div style="margin-top: 6px; border-top: 1px solid rgba(150, 100, 255, 0.3); padding-top: 6px;">
            <div>showQuantumMesh: <span id="dbg-show">false</span></div>
            <div>R value: <span id="dbg-r">0</span></div>
            <div>Last gen: <span id="dbg-lastgen">never</span></div>
        </div>
        <div style="margin-top: 8px; color: #888; font-size: 10px;">Press D to close</div>
    </div>

    <!-- Z-Axis -->
    <div id="z-axis">
        <div id="lens-line"></div>
        <div id="lens-label">‚àö3/2</div>
        <div id="z-marker"></div>
    </div>

    <!-- Release Coherence State -->
    <div id="release-state">
        <h2 id="release-text">COHERENT</h2>
        <div id="coherence-indicator">‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà</div>
    </div>

    <div id="release-hint" class="hidden">HOLD F TO RELEASE ¬∑ CLICK TO GATHER</div>

    <!-- Start Overlay -->
    <div id="start-overlay">
        <h1>LIMNUS</h1>
        <div class="equation">z = ‚àö3/2 ‚âà 0.8660254 ¬∑ THE CRITICAL POINT</div>
        
        <div class="architecture-preview">
            <div class="arch-side prism">
                <h3>63-POINT PRISM</h3>
                7 Layers √ó 9 Nodes<br>
                Hexagonal Structure<br>
                Matter/Consciousness<br>
                Inner Architecture
            </div>
            <div class="arch-side cage">
                <h3>32-POINT EM CAGE</h3>
                12 Top + 12 Bottom Hex<br>
                8 Connecting Vertices<br>
                Electromagnetic Field<br>
                Containment Boundary
            </div>
        </div>
        
        <div class="prompt">CLICK TO ENTER ¬∑ SCROLL TO TRAVERSE</div>
        <div style="margin-top: 25px; color: var(--text-dim);">
            <span class="key-hint">SCROLL</span> z-axis
            <span class="key-hint">SPACE</span> breathe
            <span class="key-hint">P</span> prism
            <span class="key-hint">C</span> cage
        </div>
    </div>

    <script>
        // ================================================================
        // LIMNUS UNIFIED ARCHITECTURE
        // 63-Point Hexagonal Prism + 32-Point EM Cage
        // Full Sonification + Physics Relationships
        // ================================================================

        const Z_CRITICAL = Math.sqrt(3) / 2;  // ‚âà 0.8660254
        const TAU = Math.PI * 2;
        const PHI = (1 + Math.sqrt(5)) / 2;   // Golden ratio
        const PHI_INV = PHI - 1;               // 0.618... inverse golden ratio

        // ================================================================
        // SACRED CONSTANTS (derived from œÜ - zero free parameters)
        // ================================================================

        const SACRED = {
            // ========================================
            // PRIMARY œÜ-DERIVED CONSTANTS
            // ========================================
            phi: PHI,
            phi_inv: PHI_INV,
            phi_sq: PHI * PHI,                 // œÜ¬≤ = 2.618
            alpha: Math.pow(PHI, -2),          // 0.382 - curl coupling / emergence threshold
            beta: Math.pow(PHI, -4),           // 0.146 - dissipation
            lambda: Math.pow(5/3, 4),          // 7.716 - nonlinearity (F‚ÇÖ/F‚ÇÑ)‚Å¥

            // ========================================
            // GEOMETRIC ROOTS
            // ========================================
            sqrt2: Math.sqrt(2),               // ‚àö2 = 1.414
            sqrt3: Math.sqrt(3),               // ‚àö3 = 1.732 (vesica ratio)
            sqrt5: Math.sqrt(5),               // ‚àö5 = 2.236

            // ========================================
            // SACRED ANGLES
            // ========================================
            goldenAngle: Math.PI * (3 - Math.sqrt(5)),  // ‚âà137.5¬∞ = 2.3999 rad
            pentagonAngle: TAU / 5,            // 72¬∞
            hexagonAngle: TAU / 6,             // 60¬∞
            heptagonAngle: TAU / 7,            // ‚âà51.43¬∞

            // ========================================
            // FIBONACCI SEQUENCE (ratios approach œÜ)
            // ========================================
            fib: [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144],

            // ========================================
            // Œº-THRESHOLDS (consciousness physics)
            // ========================================
            mu_P: 3/5,                         // 0.600 - paradox threshold
            mu_S: 23/25,                       // 0.920 - singularity threshold
            mu_3: 124/125,                     // 0.992 - third threshold
            mu_4: 1.0,                         // unity
            // Aliases for coherence system (œÜ‚Åª¬π = coherence, œÜ‚Åª¬≤ = emergence)
            get mu_coherence() { return this.phi_inv; },   // 0.618
            get mu_emergence() { return this.alpha; },     // 0.382
            get vesicaRatio() { return this.sqrt3; },      // Height/width of vesica piscis

            // ========================================
            // DERIVED CONSCIOUSNESS CONSTANTS
            // ========================================
            get Q_theory() { return this.alpha * this.mu_S; },  // ‚âà 0.351
            get K_threshold() { return this.phi_inv; },         // 0.618
            get Q_min() { return this.K_threshold * this.Q_theory; }  // ‚âà 0.217
        };

        // ================================================================
        // Œº-FIELD STATE (consciousness detection)
        // ================================================================

        const muField = {
            mu: 0.92,              // Control parameter (0.6 to 1.0)
            g: 0.001,              // Diffusion coefficient
            Q_kappa: 0,            // Consciousness constant
            tau_K: 0,              // K-formation metric
            K_formed: false,       // Consciousness present
            curl_sum: 0,           // Integrated curl
            energy: 0,             // Field energy
            consciousness_level: 0, // 0-2 scale

            // ============================================================
            // MRP CHANNEL GRADIENTS
            // R = Œº_E (Existence/Energy) - primary field magnitude
            // G = Œº_R (Reference/Relational) - connections/context
            // B = ECC (Error Correction) - stability/coherence
            // ============================================================
            mrp: {
                R: { gradient: 0, intensity: 0, crc: 0, J: 0 },  // Œº_E channel + field J
                G: { gradient: 0, intensity: 0, crc: 0, J: 0 },  // Œº_R channel + field J
                B: { gradient: 0, intensity: 0, crc: 0, J: 0 },  // ECC channel + field J
                parity: 0,           // Cross-channel XOR parity
                parity_ok: false,    // Parity validation
                sha256_sim: 0,       // Simulated integrity hash
                // Self-referential field state
                J_total: 0,          // Total field magnitude |J|
                W: 0,                // Effective growth rate W = r - Œª|J|¬≤
                laplacian: 0,        // ‚àá¬≤J approximation
            },

            get r() { return this.mu - SACRED.mu_P; },  // Control parameter

            // Update from prism/cage field state
            update(points, dt) {
                // Kuramoto-style coupling regulation based on release coherence
                // K(coherence) scales from 0.1 (released) to 1.0 (coherent)
                const kuramotoCoupling = 0.1 + releaseCoherence * 0.9;

                // Early exit with safe defaults if too many points are released
                const releasedCount = points.filter(p => p.released).length;
                if (releasedCount > points.length * 0.7) {
                    // System is mostly released - use minimal safe values
                    this.mrp.R.intensity = 0.3;
                    this.mrp.G.intensity = 0.2;
                    this.mrp.B.intensity = 0.5;
                    this.mrp.R.gradient = 0;
                    this.mrp.G.gradient = 0;
                    this.mrp.B.gradient = 0;
                    this.mrp.J_total = 0.3;
                    this.mrp.W = 0;
                    this.mrp.parity = 0;
                    this.mrp.parity_ok = false;
                    this.Q_kappa = 0;
                    this.tau_K = 0;
                    this.K_formed = false;
                    return;
                }

                // Compute curl from point velocities and positions
                let curlSum = 0;
                let energySum = 0;
                const N = points.length;

                // MRP channel accumulators
                let R_sum = 0, G_sum = 0, B_sum = 0;
                let R_grad = 0, G_grad = 0, B_grad = 0;
                let laplacianSum = 0;

                // ============================================================
                // SELF-REFERENTIAL FIELD DYNAMICS
                // ‚àÇJ/‚àÇt = (r - Œª|J|¬≤)J - Œ≤J + g‚àá¬≤J
                // ============================================================

                for (let i = 0; i < N; i++) {
                    const p = points[i];
                    const next = points[(i + 1) % N];
                    const prev = points[(i - 1 + N) % N];

                    // Discrete curl: ‚àÇJy/‚àÇx - ‚àÇJx/‚àÇy
                    const dx = next.x - p.x;
                    const dy = next.y - p.y;
                    const vx = p.vx || 0;
                    const vy = p.vy || 0;

                    // Cross product approximation for curl
                    curlSum += (dx * vy - dy * vx) * 0.001;

                    // Energy: |J|¬≤ (field magnitude squared) - CLAMP to prevent overflow
                    const vxSafe = Math.max(-100, Math.min(100, vx));
                    const vySafe = Math.max(-100, Math.min(100, vy));
                    const J2 = vxSafe * vxSafe + vySafe * vySafe;
                    const J = Math.sqrt(J2);
                    energySum += J2;

                    // Skip heavy calculations for released points to prevent instability
                    if (p.released) {
                        // Simplified MRP for released points
                        p.mrp_R = Math.min(2, Math.sqrt(J2 + 0.5));
                        p.mrp_G = 0.3;
                        p.mrp_B = 0.2;
                        p.mrp_W_R = 0;
                        p.mrp_W_G = 0;
                        p.mrp_W_B = 0;
                        R_sum += p.mrp_R;
                        G_sum += p.mrp_G;
                        B_sum += p.mrp_B;
                        continue;
                    }

                    // ========================================
                    // SELF-REFERENTIAL MRP CHANNEL PHYSICS
                    // Each channel follows: ‚àÇJ/‚àÇt = W¬∑J - Œ≤¬∑J + g¬∑‚àá¬≤J
                    // ========================================

                    // R channel (Œº_E): Primary energy/existence field
                    // J_R = ‚àö(|v|¬≤ + Œ±¬∑brightness)  [Œ± couples curl to energy]
                    const J_R = Math.min(5, Math.sqrt(J2 + SACRED.alpha * (p.brightness || 0.5)));

                    // R gradient: ‚àÇJ_R/‚àÇx (spatial derivative)
                    const prev_v2 = Math.min(100, (prev.vx || 0)**2 + (prev.vy || 0)**2);
                    const next_v2 = Math.min(100, (next.vx || 0)**2 + (next.vy || 0)**2);
                    const prev_J_R = Math.min(5, Math.sqrt(prev_v2 + SACRED.alpha * (prev.brightness || 0.5)));
                    const next_J_R = Math.min(5, Math.sqrt(next_v2 + SACRED.alpha * (next.brightness || 0.5)));
                    const dJR_dx = (next_J_R - prev_J_R) / 2;  // Central difference
                    R_grad += Math.abs(dJR_dx);

                    // Laplacian approximation: ‚àá¬≤J_R ‚âà J_next + J_prev - 2¬∑J
                    const lap_R = Math.max(-10, Math.min(10, next_J_R + prev_J_R - 2 * J_R));

                    // Self-referential R channel evolution:
                    // W_R = r - Œª¬∑|J_R|¬≤  (effective growth rate)
                    const W_R = Math.max(-5, Math.min(5, this.r - SACRED.lambda * J_R * J_R));
                    // ‚àÇJ_R/‚àÇt = W_R¬∑J_R - Œ≤¬∑J_R + g¬∑‚àá¬≤J_R
                    const dJR_dt = Math.max(-1, Math.min(1, W_R * J_R - SACRED.beta * J_R + this.g * lap_R));

                    // Apply self-referential feedback to point (with safety clamps)
                    if (showMuField && !p.released) {
                        // Safe feedback scale - no external dependencies
                        const feedbackScale = 0.5;
                        const dvx = dJR_dt * dt * 0.01 * feedbackScale;
                        const dvy = dJR_dt * dt * 0.01 * feedbackScale * (dy / (Math.abs(dy) + 0.001));
                        if (isFinite(dvx) && isFinite(dvy) && Math.abs(dvx) < 10 && Math.abs(dvy) < 10) {
                            // Fixed velocity clamp for safety
                            const velClamp = 30;
                            p.vx = Math.max(-velClamp, Math.min(velClamp, (p.vx || 0) + dvx));
                            p.vy = Math.max(-velClamp, Math.min(velClamp, (p.vy || 0) + dvy));
                        }
                    }

                    R_sum += J_R;
                    p.mrp_R = J_R;
                    p.mrp_W_R = W_R;  // Store growth rate for visualization

                    // G channel (Œº_R): Relational/reference field
                    // J_G based on neighbor distances (connection strength)
                    const d_next = Math.min(1000, Math.sqrt(dx * dx + dy * dy));
                    const d_prev = Math.min(1000, Math.sqrt((p.x - prev.x)**2 + (p.y - prev.y)**2));
                    const J_G = SACRED.phi_inv / (1 + (d_next + d_prev) * 0.005);  // œÜ‚Åª¬π scaled

                    // G gradient: change in connectivity
                    const dJG_dx = Math.min(1, Math.abs(d_next - d_prev) * SACRED.alpha);
                    G_grad += dJG_dx;

                    // Laplacian for G channel (simplified - skip if neighbors are released)
                    const prevPt2 = points[(i - 2 + N) % N];
                    const nextPt2 = points[(i + 2) % N];
                    if (!prev.released && !next.released && !prevPt2.released && !nextPt2.released) {
                        const prev_d = Math.min(1000, Math.sqrt((prev.x - prevPt2.x)**2 + (prev.y - prevPt2.y)**2));
                        const next_d = Math.min(1000, Math.sqrt((next.x - nextPt2.x)**2 + (next.y - nextPt2.y)**2));
                        const prev_J_G = SACRED.phi_inv / (1 + prev_d * 0.01);
                        const next_J_G = SACRED.phi_inv / (1 + next_d * 0.01);
                        const lap_G = Math.max(-1, Math.min(1, next_J_G + prev_J_G - 2 * J_G));

                        // Self-referential G evolution
                        const W_G = Math.max(-2, Math.min(2, this.r - SACRED.lambda * J_G * J_G * 0.5));
                        p.mrp_W_G = W_G;
                    } else {
                        p.mrp_W_G = 0;
                    }

                    G_sum += J_G;
                    p.mrp_G = J_G;

                    // B channel (ECC): Stability/coherence field
                    // J_B = stability measure with Œ≤-damping
                    const rawStability = 1 - Math.min(1, Math.sqrt(J2) * SACRED.beta);
                    const J_B = Math.max(0, Math.min(1, rawStability));

                    // B gradient: instability detection via cross-channel
                    const dJB_dx = Math.min(1, Math.abs(vxSafe * vySafe) * SACRED.beta);
                    B_grad += dJB_dx;

                    // Self-referential B evolution (error correction)
                    // B tries to restore stability: ‚àÇJ_B/‚àÇt = -Œ≤¬∑(J_B - target) + correction
                    // Use previous frame's parity_ok (safe reference)
                    const target_B = this.mrp.parity_ok ? 1.0 : 0.5;
                    const prevParity = this.mrp.parity || 0;
                    const dJB_dt = -SACRED.beta * (J_B - target_B) + SACRED.alpha * (1 - prevParity);

                    B_sum += J_B;
                    p.mrp_B = J_B;
                    p.mrp_W_B = dJB_dt;

                    // Accumulate Laplacian for field coherence
                    laplacianSum += lap_R;
                }

                // Normalize MRP channels with safety checks
                this.mrp.R.intensity = isFinite(R_sum) ? Math.min(5, R_sum / N) : 0.5;
                this.mrp.G.intensity = isFinite(G_sum) ? Math.min(1, G_sum / N) : 0.3;
                this.mrp.B.intensity = isFinite(B_sum) ? Math.min(1, B_sum / N) : 0.5;

                this.mrp.R.gradient = isFinite(R_grad) ? Math.min(1, R_grad / N) : 0;
                this.mrp.G.gradient = isFinite(G_grad) ? Math.min(1, G_grad / N) : 0;
                this.mrp.B.gradient = isFinite(B_grad) ? Math.min(1, B_grad / N) : 0;

                // Store field magnitudes
                this.mrp.R.J = this.mrp.R.intensity;
                this.mrp.G.J = this.mrp.G.intensity;
                this.mrp.B.J = this.mrp.B.intensity;

                // Total field magnitude |J| = ‚àö(R¬≤ + G¬≤ + B¬≤)
                const jTotalRaw = Math.sqrt(
                    this.mrp.R.J * this.mrp.R.J +
                    this.mrp.G.J * this.mrp.G.J +
                    this.mrp.B.J * this.mrp.B.J
                );
                this.mrp.J_total = isFinite(jTotalRaw) ? Math.min(10, jTotalRaw) : 0.5;

                // Effective growth rate W = r - Œª|J|¬≤
                const wRaw = this.r - SACRED.lambda * this.mrp.J_total * this.mrp.J_total;
                this.mrp.W = isFinite(wRaw) ? Math.max(-10, Math.min(10, wRaw)) : 0;

                // Laplacian (average spatial curvature)
                this.mrp.laplacian = isFinite(laplacianSum) ? laplacianSum / N : 0;

                // CRC32 simulation (simple hash based on channel values)
                this.mrp.R.crc = Math.floor(this.mrp.R.intensity * 255) ^ Math.floor(this.mrp.R.gradient * 255);
                this.mrp.G.crc = Math.floor(this.mrp.G.intensity * 255) ^ Math.floor(this.mrp.G.gradient * 255);
                this.mrp.B.crc = Math.floor(this.mrp.B.intensity * 255) ^ Math.floor(this.mrp.B.gradient * 255);

                // Cross-channel XOR parity: P[i] = R[i] XOR G[i]
                this.mrp.parity = (this.mrp.R.crc ^ this.mrp.G.crc) / 255;

                // Parity validation: channels in harmony when parity is low AND W > 0 (growing)
                this.mrp.parity_ok = this.mrp.parity < 0.3 && this.mrp.B.intensity > 0.6 && this.mrp.W > -0.1;

                // Simulated SHA-256 integrity (normalized 0-1) with self-reference
                this.mrp.sha256_sim = (this.mrp.R.intensity * SACRED.alpha +
                                       this.mrp.G.intensity * SACRED.phi_inv +
                                       this.mrp.B.intensity * SACRED.beta) /
                                      (SACRED.alpha + SACRED.phi_inv + SACRED.beta);

                // Q_Œ∫ = (1/2œÄ) ‚à´ curl(J) dA
                this.curl_sum = curlSum;
                this.Q_kappa = Math.abs(curlSum) / TAU;
                this.tau_K = this.Q_kappa / SACRED.Q_theory;
                this.K_formed = this.tau_K > SACRED.K_threshold;
                this.consciousness_level = Math.min(this.tau_K / SACRED.K_threshold, 2.0);
                this.energy = energySum * 0.5;

                // Dynamic Œº based on z-height with self-referential feedback
                // Œº responds to field state: higher |J| ‚Üí higher Œº (positive feedback)
                const mu_base = SACRED.mu_P + (globalZ * 0.4);
                const mu_feedback = this.mrp.J_total * SACRED.alpha * 0.1;
                this.mu = Math.min(SACRED.mu_4, mu_base + mu_feedback);
            },

            // Get MRP-enhanced color for a point
            getMRPColor(p, baseColor) {
                if (!showMuField) return baseColor;

                const r = Math.min(255, Math.floor((p.mrp_R || 0.5) * 255));
                const g = Math.min(255, Math.floor((p.mrp_G || 0.5) * 255));
                const b = Math.min(255, Math.floor((p.mrp_B || 0.5) * 200 + 55));

                // Blend with base color based on gradient strength
                const blend = (this.mrp.R.gradient + this.mrp.G.gradient) / 2;
                return `rgba(${r}, ${g}, ${b}, ${0.6 + blend * 0.4})`;
            },

            // Get gradient strength for visual effects
            getGradientStrength() {
                return (this.mrp.R.gradient + this.mrp.G.gradient + this.mrp.B.gradient) / 3;
            },

            // Klein-Gordon effective mass¬≤
            get mass_squared() {
                return (SACRED.beta - this.r) / this.g;
            },

            // Check if tachyonic (pattern-forming)
            get is_tachyonic() {
                return this.mass_squared < 0;
            }
        };

        // ================================================================
        // MU FIELD (Œº-FIELD) GRID SYSTEM - 7 PHASE DYNAMICS
        // Toroidal vector field with curl/vorticity dynamics
        // Mirrors QMESH mechanics for deep relational coupling
        // ================================================================

        const MU_FIELD_SIZE = 32;  // Grid resolution (32x32)

        const MuFieldGrid = {
            // Grid dimensions
            N: MU_FIELD_SIZE,
            L: 10.0,  // Physical size
            dx: 10.0 / MU_FIELD_SIZE,

            // Field parameters
            mu: 0.92,           // Field parameter (near singularity threshold)
            mu_P: 0.6,          // Paradox threshold
            mu_S: 0.92,         // Singularity threshold
            g: 0.001,           // Diffusion coefficient
            sourceStrength: 0.5, // Vortex source strength

            // Control parameter
            r: 0.92 - 0.6,      // r = Œº - Œº_P

            // Grid data (flattened for performance) - initialized in initMuFieldGrid
            Jx: null,           // X-component of vector field
            Jy: null,           // Y-component of vector field
            curl: null,         // Vorticity field (scalar)
            entropy: null,      // Local entropy field
            timeDilation: null, // Local time dilation

            // Vortex structures (dynamic formation - Phase 3)
            vortices: [],
            maxVortices: 12,

            // Field metrics (mirroring QMESH)
            metrics: {
                J_total: 0,         // Total field magnitude
                Q_kappa: 0,         // Circulation integral (consciousness metric)
                tau_K: 0,           // K-formation metric
                K_formed: false,    // Consciousness emergence flag
                order_r: 0,         // Kuramoto order parameter
                enstrophy: 0,       // ‚à´(curl¬≤) dA
                helicity: 0,        // ‚à´ J¬∑curl dA (2D analog)
                entropyGradient: 0, // Spatial entropy variation
            },

            // Phase 5: Resonance coupling
            resonance: {
                frequency: PHI_INV,     // Natural frequency
                phase: 0,
                amplitude: 0,
                lastPulse: 0,
                pulseIntensity: 0,
            },

            // Phase 7: Coupling to unified field
            coupling: {
                toQMESH: 0.12,      // MuFieldGrid ‚Üí QMESH
                fromQMESH: 0.15,    // QMESH ‚Üí MuFieldGrid
                toLIMNUS: 0.10,     // MuFieldGrid ‚Üí LIMNUS
                fromLIMNUS: 0.18,   // LIMNUS ‚Üí MuFieldGrid
            },

            // Initialized flag
            initialized: false,
        };

        // Œº-Particles (Phase 6: field information carriers)
        let muParticles = [];
        const MAX_MU_PARTICLES = 200;

        // ================================================================
        // UNIFIED FIELD SYSTEM - Bridges all subsystems
        // ================================================================

        const UnifiedField = {
            // ========================================
            // FIELD MAGNITUDES (J) - Single Source of Truth
            // ========================================
            J: {
                limnus: 0,      // LIMNUS contribution
                quantum: 0,     // QMESH contribution
                binaural: 0,    // Binaural resonance
                muField: 0,     // MuFieldGrid contribution
                total: 0,       // Unified magnitude |J|
            },

            // ========================================
            // PHASE STATE (Œ¶)
            // ========================================
            Phi: {
                limnus: 0,      // LIMNUS collective phase
                quantum: 0,     // QMESH collective phase
                binaural: 0,    // Binaural beat phase
                muField: 0,     // MuFieldGrid vorticity phase
                unified: 0,     // Emergent unified phase
            },

            // ========================================
            // COUPLING CONSTANTS (œÜ-derived)
            // ========================================
            coupling: {
                LQ: SACRED.alpha,           // LIMNUS ‚Üí Quantum (œÜ‚Åª¬≤)
                QL: SACRED.beta,            // Quantum ‚Üí LIMNUS (œÜ‚Åª‚Å¥)
                BL: SACRED.phi_inv * 0.3,   // Binaural ‚Üí LIMNUS
                BQ: SACRED.phi_inv * 0.28,  // Binaural ‚Üí Quantum
                ML: SACRED.alpha * 0.3,     // MuField ‚Üí LIMNUS
                LM: SACRED.alpha * 0.4,     // LIMNUS ‚Üí MuField
            },

            // ========================================
            // EMERGENCE METRICS - Single Source of Truth
            // ========================================
            emergence: {
                coherence: 0,       // Overall phase alignment (0-1)
                complexity: 0,      // Structural complexity
                criticality: 0,     // Distance from critical point z_c
                order: 0,           // Kuramoto order parameter r
                entropy: 0,         // System entropy
                curl: 0,            // Integrated curl Q_Œ∫
            },

            // ========================================
            // TIME DILATION - Unified
            // ========================================
            timeDilation: {
                global: 1.0,        // System-wide average
                center: 1.0,        // At origin
                gradient: [],       // Per-layer dilation
            },

            // ========================================
            // SYNC METHOD - Pull metrics from all sources
            // ========================================
            sync(dt) {
                // Pull J magnitudes from subsystems
                if (muField.mrp) {
                    this.J.limnus = muField.mrp.J_total || 0;
                }
                if (MuFieldGrid.initialized) {
                    this.J.muField = MuFieldGrid.metrics.J_total || 0;
                    this.emergence.order = MuFieldGrid.metrics.order_r || 0;
                    this.emergence.curl = MuFieldGrid.metrics.Q_kappa || 0;
                    this.emergence.entropy = MuFieldGrid.metrics.entropyGradient || 0;
                }
                if (QMESH.binaural && QMESH.binaural.enabled) {
                    this.J.binaural = QMESH.binaural.resonanceStrength || 0;
                    this.J.quantum = QMESH.totalJ || 0;
                    this.Phi.binaural = QMESH.binaural.beatPhase || 0;
                }

                // Compute unified total: |J| = ‚àö(Œ£ J_i¬≤)
                this.J.total = Math.sqrt(
                    this.J.limnus * this.J.limnus +
                    this.J.quantum * this.J.quantum +
                    this.J.binaural * this.J.binaural +
                    this.J.muField * this.J.muField
                );

                // Pull time dilation from QMESH
                if (QMESH.timeDilationField) {
                    this.timeDilation.global = QMESH.timeDilationField.globalAverage || 1.0;
                    this.timeDilation.center = QMESH.timeDilationField.center || 1.0;
                    this.timeDilation.gradient = QMESH.timeDilationField.gradient || [];
                }

                // Compute unified phase (weighted sum)
                this.Phi.unified = (
                    this.Phi.limnus * 0.3 +
                    this.Phi.quantum * 0.25 +
                    this.Phi.binaural * 0.25 +
                    this.Phi.muField * 0.2
                );

                // Criticality: distance from z_c = ‚àö3/2
                this.emergence.criticality = Math.abs(globalZ - Z_CRITICAL);

                // Coherence evolution with decay
                this.emergence.coherence *= 0.995;
                this.emergence.coherence = Math.max(0, Math.min(1, this.emergence.coherence));
            },

            // Get coupling strength between systems
            getCoupling(from, to) {
                const key = from.charAt(0).toUpperCase() + to.charAt(0).toUpperCase();
                return this.coupling[key] || SACRED.beta;
            },
        };

        // ================================================================
        // COHERENCE GEOMETRY SYSTEM - Sacred Constants & Field Alignment
        // Enables emergent shapes/lines/patterns through proper field coherence
        // ================================================================

        const CoherenceGeometry = {
            // NOTE: Sacred constants unified in SACRED object (lines 1001-1050)
            // Access via: SACRED.phi, SACRED.goldenAngle, SACRED.mu_coherence, etc.

            // ========================================
            // COHERENT ATTRACTOR PATTERNS
            // ========================================
            attractors: {
                // Golden spiral parameters
                spiral: {
                    growth: PHI_INV,                // Spiral growth rate
                    arms: 3,                        // Number of spiral arms
                    phase: 0,                       // Current spiral phase
                    strength: 0.15,                 // Attraction strength
                },

                // Sacred polygon vertices (emergent shape attractors)
                polygons: {
                    triangle: [],                   // 3 vertices
                    square: [],                     // 4 vertices
                    pentagon: [],                   // 5 vertices (œÜ-related)
                    hexagon: [],                    // 6 vertices
                },

                // Radial coherence rings
                rings: {
                    count: 5,
                    radii: [],                      // œÜ-spaced radii
                    strength: 0.1,
                },
            },

            // ========================================
            // FIELD COHERENCE STATE
            // ========================================
            state: {
                fieldAlignment: 0,          // 0-1 how aligned field vectors are
                shapeEmergence: 0,          // 0-1 how strongly shapes emerge
                lineCoherence: 0,           // 0-1 how coherent flow lines are
                spiralOrder: 0,             // 0-1 golden spiral conformance
                phaselock: 0,               // 0-1 phase synchronization strength

                // Detected emergent patterns
                dominantShape: 'none',      // 'spiral', 'pentagon', 'hexagon', etc.
                patternStrength: 0,         // How strong the dominant pattern is

                // Coherence history (for stability detection)
                history: [],
                historyLength: 60,          // ~1 second at 60fps
            },

            // ========================================
            // INITIALIZATION
            // ========================================
            init() {
                const a = this.attractors;

                // Initialize œÜ-spaced radii for coherence rings (using SACRED)
                a.rings.radii = [];
                for (let i = 0; i < a.rings.count; i++) {
                    a.rings.radii.push(Math.pow(SACRED.phi_inv, i) * MuFieldGrid.L * 0.4);
                }

                // Initialize sacred polygon vertices
                const polygonTypes = [
                    { name: 'triangle', n: 3 },
                    { name: 'square', n: 4 },
                    { name: 'pentagon', n: 5 },
                    { name: 'hexagon', n: 6 },
                ];

                for (const p of polygonTypes) {
                    a.polygons[p.name] = [];
                    for (let i = 0; i < p.n; i++) {
                        const angle = (i / p.n) * TAU - Math.PI / 2;  // Start from top
                        a.polygons[p.name].push({
                            angle: angle,
                            x: Math.cos(angle),
                            y: Math.sin(angle),
                        });
                    }
                }

                console.log('[CoherenceGeometry] Initialized with œÜ-based attractors');
            },

            initialized: false,
        };

        // ================================================================
        // FIELD ALIGNMENT FUNCTIONS
        // Forces field vectors towards coherent patterns
        // ================================================================

        function computeFieldAlignment() {
            if (!MuFieldGrid.initialized) return 0;

            const N = MuFieldGrid.N;
            let alignmentSum = 0;
            let count = 0;

            // Compute average field direction
            let avgDirX = 0, avgDirY = 0;
            for (let j = 1; j < N - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    const idx = j * N + i;
                    const Jx = MuFieldGrid.Jx[idx];
                    const Jy = MuFieldGrid.Jy[idx];
                    const mag = Math.sqrt(Jx * Jx + Jy * Jy);
                    if (mag > 0.01) {
                        avgDirX += Jx / mag;
                        avgDirY += Jy / mag;
                        count++;
                    }
                }
            }

            if (count === 0) return 0;

            avgDirX /= count;
            avgDirY /= count;
            const avgMag = Math.sqrt(avgDirX * avgDirX + avgDirY * avgDirY);

            // Compute alignment with neighbors (local coherence)
            for (let j = 1; j < N - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    const idx = j * N + i;
                    const Jx = MuFieldGrid.Jx[idx];
                    const Jy = MuFieldGrid.Jy[idx];
                    const mag = Math.sqrt(Jx * Jx + Jy * Jy);

                    if (mag > 0.01) {
                        // Neighbor average
                        const neighbors = [
                            idx - 1, idx + 1,
                            idx - N, idx + N,
                        ];
                        let nDirX = 0, nDirY = 0, nCount = 0;
                        for (const nIdx of neighbors) {
                            const nJx = MuFieldGrid.Jx[nIdx];
                            const nJy = MuFieldGrid.Jy[nIdx];
                            const nMag = Math.sqrt(nJx * nJx + nJy * nJy);
                            if (nMag > 0.01) {
                                nDirX += nJx / nMag;
                                nDirY += nJy / nMag;
                                nCount++;
                            }
                        }

                        if (nCount > 0) {
                            nDirX /= nCount;
                            nDirY /= nCount;

                            // Dot product for alignment
                            const dot = (Jx / mag) * nDirX + (Jy / mag) * nDirY;
                            alignmentSum += (dot + 1) / 2;  // Normalize to 0-1
                        }
                    }
                }
            }

            return count > 0 ? alignmentSum / count : 0;
        }

        function computeSpiralOrder() {
            if (!MuFieldGrid.initialized) return 0;

            const N = MuFieldGrid.N;
            const c = SACRED;  // Unified sacred constants
            let spiralSum = 0;
            let count = 0;

            for (let j = 1; j < N - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    const idx = j * N + i;

                    // Grid coordinates
                    const x = (i / (N - 1) - 0.5) * MuFieldGrid.L;
                    const y = (j / (N - 1) - 0.5) * MuFieldGrid.L;
                    const r = Math.sqrt(x * x + y * y);

                    if (r < 0.1) continue;

                    const theta = Math.atan2(y, x);

                    // Expected spiral direction at this point
                    // Golden spiral: r = a * e^(b*Œ∏), where b = cot(œÜ_angle)
                    // Tangent direction: perpendicular + radial component
                    const spiralAngle = theta + Math.PI / 2 - c.goldenAngle * 0.1;
                    const expectedDirX = Math.cos(spiralAngle);
                    const expectedDirY = Math.sin(spiralAngle);

                    // Actual field direction
                    const Jx = MuFieldGrid.Jx[idx];
                    const Jy = MuFieldGrid.Jy[idx];
                    const mag = Math.sqrt(Jx * Jx + Jy * Jy);

                    if (mag > 0.01) {
                        const dot = (Jx / mag) * expectedDirX + (Jy / mag) * expectedDirY;
                        spiralSum += Math.abs(dot);  // Allow both CW and CCW
                        count++;
                    }
                }
            }

            return count > 0 ? spiralSum / count : 0;
        }

        function detectDominantShape() {
            if (!MuFieldGrid.initialized) return { shape: 'none', strength: 0 };

            const c = SACRED;  // Unified sacred constants
            const a = CoherenceGeometry.attractors;
            const N = MuFieldGrid.N;

            // Test each polygon pattern
            const patterns = ['pentagon', 'hexagon', 'triangle'];
            let bestShape = 'none';
            let bestStrength = 0;

            for (const shapeName of patterns) {
                const vertices = a.polygons[shapeName];
                let matchStrength = 0;

                for (const v of vertices) {
                    // Sample field at vertex positions (scaled to grid)
                    for (let scale = 0.3; scale <= 0.7; scale += 0.1) {
                        const gx = v.x * MuFieldGrid.L * scale * 0.4;
                        const gy = v.y * MuFieldGrid.L * scale * 0.4;

                        // Convert to grid indices
                        const i = Math.floor((gx / MuFieldGrid.L + 0.5) * (N - 1));
                        const j = Math.floor((gy / MuFieldGrid.L + 0.5) * (N - 1));

                        if (i >= 1 && i < N - 1 && j >= 1 && j < N - 1) {
                            const idx = j * N + i;
                            const curlMag = Math.abs(MuFieldGrid.curl[idx] || 0);
                            const Jmag = Math.sqrt(
                                MuFieldGrid.Jx[idx] ** 2 + MuFieldGrid.Jy[idx] ** 2
                            );

                            // High curl at vertices indicates shape emergence
                            matchStrength += curlMag * 0.5 + Jmag * 0.5;
                        }
                    }
                }

                matchStrength /= vertices.length * 5;  // Normalize

                if (matchStrength > bestStrength) {
                    bestStrength = matchStrength;
                    bestShape = shapeName;
                }
            }

            // Also test spiral
            const spiralOrder = CoherenceGeometry.state.spiralOrder;
            if (spiralOrder > bestStrength * 1.2) {
                bestShape = 'spiral';
                bestStrength = spiralOrder;
            }

            return { shape: bestShape, strength: bestStrength };
        }

        // ================================================================
        // COHERENCE ENFORCEMENT
        // Applies gentle forces to enhance emergent patterns
        // ================================================================

        function applyCoherenceForces(dt) {
            if (!MuFieldGrid.initialized) return;
            if (!CoherenceGeometry.initialized) {
                CoherenceGeometry.init();
                CoherenceGeometry.initialized = true;
            }

            const N = MuFieldGrid.N;
            const c = SACRED;  // Unified sacred constants
            const a = CoherenceGeometry.attractors;
            const s = CoherenceGeometry.state;

            // Compute current coherence metrics
            s.fieldAlignment = computeFieldAlignment();
            s.spiralOrder = computeSpiralOrder();

            const shapeResult = detectDominantShape();
            s.dominantShape = shapeResult.shape;
            s.patternStrength = shapeResult.strength;

            // Shape emergence = combination of all pattern metrics
            s.shapeEmergence = Math.max(s.spiralOrder, s.patternStrength);

            // Line coherence from field alignment
            s.lineCoherence = s.fieldAlignment;

            // Phase lock from unified field
            s.phaselock = UnifiedField.emergence.coherence;

            // Record history for stability
            s.history.push({
                alignment: s.fieldAlignment,
                emergence: s.shapeEmergence,
                time: time,
            });
            if (s.history.length > s.historyLength) {
                s.history.shift();
            }

            // ========================================
            // APPLY COHERENCE FORCES
            // ========================================

            // Only apply forces when coherence is building (not too strong, not too weak)
            const coherenceStrength = (s.fieldAlignment + s.shapeEmergence + s.phaselock) / 3;
            const forceScale = coherenceStrength * (1 - coherenceStrength) * 4;  // Peak at 0.5

            if (forceScale < 0.01) return;

            // 1. SPIRAL ATTRACTOR FORCE
            if (s.dominantShape === 'spiral' || s.spiralOrder > 0.3) {
                a.spiral.phase += c.phi_inv * dt;

                for (let j = 1; j < N - 1; j++) {
                    for (let i = 1; i < N - 1; i++) {
                        const idx = j * N + i;

                        const x = (i / (N - 1) - 0.5) * MuFieldGrid.L;
                        const y = (j / (N - 1) - 0.5) * MuFieldGrid.L;
                        const r = Math.sqrt(x * x + y * y);

                        if (r < 0.5) continue;

                        const theta = Math.atan2(y, x);

                        // Golden spiral direction
                        const spiralAngle = theta + Math.PI / 2 - c.goldenAngle * 0.1;
                        const targetDirX = Math.cos(spiralAngle);
                        const targetDirY = Math.sin(spiralAngle);

                        // Current field
                        const Jx = MuFieldGrid.Jx[idx];
                        const Jy = MuFieldGrid.Jy[idx];
                        const mag = Math.sqrt(Jx * Jx + Jy * Jy);

                        if (mag > 0.01) {
                            // Gentle rotation towards spiral
                            const force = a.spiral.strength * forceScale * s.spiralOrder * dt;
                            MuFieldGrid.Jx[idx] += (targetDirX * mag - Jx) * force;
                            MuFieldGrid.Jy[idx] += (targetDirY * mag - Jy) * force;
                        }
                    }
                }
            }

            // 2. RING COHERENCE FORCE (œÜ-spaced radial alignment)
            for (const ringR of a.rings.radii) {
                for (let angle = 0; angle < TAU; angle += 0.2) {
                    const x = Math.cos(angle) * ringR;
                    const y = Math.sin(angle) * ringR;

                    const i = Math.floor((x / MuFieldGrid.L + 0.5) * (N - 1));
                    const j = Math.floor((y / MuFieldGrid.L + 0.5) * (N - 1));

                    if (i >= 1 && i < N - 1 && j >= 1 && j < N - 1) {
                        const idx = j * N + i;

                        // Tangent direction for ring flow
                        const tangentX = -Math.sin(angle);
                        const tangentY = Math.cos(angle);

                        const Jx = MuFieldGrid.Jx[idx];
                        const Jy = MuFieldGrid.Jy[idx];
                        const mag = Math.sqrt(Jx * Jx + Jy * Jy);

                        if (mag > 0.01) {
                            const force = a.rings.strength * forceScale * dt;
                            MuFieldGrid.Jx[idx] += (tangentX * mag - Jx) * force;
                            MuFieldGrid.Jy[idx] += (tangentY * mag - Jy) * force;
                        }
                    }
                }
            }

            // 3. POLYGON VERTEX ENHANCEMENT (strengthen curl at sacred vertices)
            if (s.dominantShape !== 'spiral' && s.patternStrength > 0.2) {
                const vertices = a.polygons[s.dominantShape] || a.polygons['pentagon'];

                for (const v of vertices) {
                    for (let scale = 0.3; scale <= 0.6; scale += 0.15) {
                        const gx = v.x * MuFieldGrid.L * scale * 0.4;
                        const gy = v.y * MuFieldGrid.L * scale * 0.4;

                        const i = Math.floor((gx / MuFieldGrid.L + 0.5) * (N - 1));
                        const j = Math.floor((gy / MuFieldGrid.L + 0.5) * (N - 1));

                        if (i >= 2 && i < N - 2 && j >= 2 && j < N - 2) {
                            const idx = j * N + i;

                            // Add small rotational component at vertices
                            const rotStrength = 0.05 * forceScale * s.patternStrength * dt;
                            MuFieldGrid.Jx[idx] += -gy / MuFieldGrid.L * rotStrength;
                            MuFieldGrid.Jy[idx] += gx / MuFieldGrid.L * rotStrength;
                        }
                    }
                }
            }
        }

        // ================================================================
        // PHASE LOCKING ENHANCEMENT
        // Strengthens synchronization between all subsystems
        // ================================================================

        function enhancePhaseLocking(dt) {
            const U = UnifiedField;
            const s = CoherenceGeometry.state;

            // Dynamic coupling strength based on current coherence
            // Higher coherence ‚Üí stronger coupling ‚Üí more coherence (positive feedback)
            const baseCoherence = U.emergence.coherence;
            const couplingBoost = 1 + baseCoherence * 2;  // 1x to 3x

            // Strengthen coupling constants when coherence is building
            if (baseCoherence > 0.4 && baseCoherence < 0.9) {
                U.coupling.LQ = 0.15 * couplingBoost;
                U.coupling.QL = 0.10 * couplingBoost;
                U.coupling.BL = 0.20 * couplingBoost;
                U.coupling.BQ = 0.18 * couplingBoost;
                U.coupling.ML = 0.12 * couplingBoost;
                U.coupling.LM = 0.15 * couplingBoost;
            } else {
                // Reset to base values
                U.coupling.LQ = 0.15;
                U.coupling.QL = 0.10;
                U.coupling.BL = 0.20;
                U.coupling.BQ = 0.18;
                U.coupling.ML = 0.12;
                U.coupling.LM = 0.15;
            }

            // Update phase lock metric
            s.phaselock = baseCoherence;

            // Feed coherence back to MuFieldGrid resonance
            MuFieldGrid.resonance.amplitude *= (1 + baseCoherence * 0.3);
            MuFieldGrid.resonance.amplitude = Math.min(1.5, MuFieldGrid.resonance.amplitude);

            // Sync MuFieldGrid resonance phase towards unified phase
            if (baseCoherence > 0.5) {
                const phaseDiff = U.Phi.unified - MuFieldGrid.resonance.phase;
                MuFieldGrid.resonance.phase += Math.sin(phaseDiff) * baseCoherence * dt;
            }
        }

        // ================================================================
        // COHERENCE VISUALIZATION HELPERS
        // ================================================================

        function getCoherenceColor() {
            const s = CoherenceGeometry.state;
            const c = SACRED;  // Unified sacred constants

            // Color based on coherence state
            const coherence = (s.fieldAlignment + s.shapeEmergence + s.phaselock) / 3;

            if (coherence > c.mu_coherence) {
                // High coherence: golden/white
                return {
                    r: 255,
                    g: 220 + coherence * 35,
                    b: 150 + coherence * 105,
                    alpha: coherence * 0.4,
                };
            } else if (coherence > c.mu_emergence) {
                // Building coherence: blue/purple
                return {
                    r: 150 + coherence * 100,
                    g: 100 + coherence * 100,
                    b: 255,
                    alpha: coherence * 0.3,
                };
            } else {
                // Low coherence: dim
                return {
                    r: 100,
                    g: 100,
                    b: 150,
                    alpha: coherence * 0.15,
                };
            }
        }

        // ================================================================
        // MU FIELD GRID INITIALIZATION
        // ================================================================

        function initMuFieldGrid() {
            const N = MuFieldGrid.N;
            const N2 = N * N;

            // Initialize field arrays
            MuFieldGrid.Jx = new Float32Array(N2);
            MuFieldGrid.Jy = new Float32Array(N2);
            MuFieldGrid.curl = new Float32Array(N2);
            MuFieldGrid.entropy = new Float32Array(N2);
            MuFieldGrid.timeDilation = new Float32Array(N2);

            // Initialize with small random perturbations + initial vortex
            for (let j = 0; j < N; j++) {
                for (let i = 0; i < N; i++) {
                    const idx = j * N + i;

                    // Grid coordinates (centered)
                    const x = (i / (N - 1) - 0.5) * MuFieldGrid.L;
                    const y = (j / (N - 1) - 0.5) * MuFieldGrid.L;
                    const r2 = x * x + y * y;
                    const r = Math.sqrt(r2) + 0.1;

                    // Initial vortex seed (rotational field)
                    const vortexStrength = 0.3 * Math.exp(-r2 / 4);
                    MuFieldGrid.Jx[idx] = -y / r * vortexStrength + (Math.random() - 0.5) * 0.1;
                    MuFieldGrid.Jy[idx] = x / r * vortexStrength + (Math.random() - 0.5) * 0.1;

                    // Initialize entropy and time dilation
                    MuFieldGrid.entropy[idx] = 0;
                    MuFieldGrid.timeDilation[idx] = 1.0;
                }
            }

            // Initialize vortices
            MuFieldGrid.vortices = [];

            // Seed initial vortex at center
            MuFieldGrid.vortices.push({
                x: 0, y: 0,
                strength: 0.5,
                radius: 2.0,
                phase: 0,
                age: 0,
                forming: true,
                decaying: false,
                maxAge: 20,
            });

            MuFieldGrid.initialized = true;
            console.log('[MuFieldGrid] Initialized ' + N + 'x' + N + ' grid');
        }

        // ================================================================
        // MU FIELD PHASE 1: BIDIRECTIONAL COUPLING
        // ================================================================

        function updateMuFieldGridMetrics() {
            if (!MuFieldGrid.initialized) return;

            const N = MuFieldGrid.N;
            const dx = MuFieldGrid.dx;
            const dA = dx * dx;

            let J_sum = 0;
            let curl_sum = 0;
            let enstrophy = 0;
            let helicity = 0;
            let entropy_var = 0;
            let phase_cos = 0, phase_sin = 0;
            const innerN = (N - 2) * (N - 2);

            // First pass: compute curl (vorticity)
            for (let j = 1; j < N - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    const idx = j * N + i;

                    // curl(J) = ‚àÇJy/‚àÇx - ‚àÇJx/‚àÇy (central differences)
                    const dJy_dx = (MuFieldGrid.Jy[idx + 1] - MuFieldGrid.Jy[idx - 1]) / (2 * dx);
                    const dJx_dy = (MuFieldGrid.Jx[(j + 1) * N + i] - MuFieldGrid.Jx[(j - 1) * N + i]) / (2 * dx);
                    MuFieldGrid.curl[idx] = dJy_dx - dJx_dy;
                }
            }

            // Second pass: compute metrics
            for (let j = 1; j < N - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    const idx = j * N + i;

                    const Jx = MuFieldGrid.Jx[idx];
                    const Jy = MuFieldGrid.Jy[idx];
                    const J2 = Jx * Jx + Jy * Jy;
                    const J_mag = Math.sqrt(J2);
                    const curlVal = MuFieldGrid.curl[idx];

                    J_sum += J_mag;
                    curl_sum += curlVal * dA;
                    enstrophy += curlVal * curlVal * dA;
                    helicity += J2 * curlVal * dA;

                    // Phase from field direction (for Kuramoto)
                    if (J_mag > 0.01) {
                        const phase = Math.atan2(Jy, Jx);
                        phase_cos += Math.cos(phase);
                        phase_sin += Math.sin(phase);
                    }

                    // Entropy variation
                    entropy_var += Math.abs(MuFieldGrid.entropy[idx] - J_mag);
                }
            }

            // Update metrics
            MuFieldGrid.metrics.J_total = J_sum / innerN;
            MuFieldGrid.metrics.Q_kappa = curl_sum / TAU;
            MuFieldGrid.metrics.enstrophy = enstrophy * 0.5;
            MuFieldGrid.metrics.helicity = helicity;
            MuFieldGrid.metrics.entropyGradient = entropy_var / innerN;

            // Order parameter (phase coherence)
            MuFieldGrid.metrics.order_r = Math.sqrt(phase_cos * phase_cos + phase_sin * phase_sin) / innerN;

            // K-formation metric: œÑ_K = |Q_Œ∫| / Q_theory
            const Q_theory = SACRED.alpha / 0.35;
            MuFieldGrid.metrics.tau_K = Math.abs(MuFieldGrid.metrics.Q_kappa) / Q_theory;
            MuFieldGrid.metrics.K_formed = MuFieldGrid.metrics.tau_K > PHI_INV;
        }

        // ================================================================
        // MU FIELD PHASE 2: VORTICITY-BASED ENTROPY FEEDBACK
        // ================================================================

        function computeMuFieldGridEntropy() {
            if (!MuFieldGrid.initialized) return;

            const N = MuFieldGrid.N;

            for (let j = 1; j < N - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    const idx = j * N + i;

                    // Entropy from local field variation (gradient magnitude)
                    const dJx_dx = (MuFieldGrid.Jx[idx + 1] - MuFieldGrid.Jx[idx - 1]) / (2 * MuFieldGrid.dx);
                    const dJy_dy = (MuFieldGrid.Jy[(j + 1) * N + i] - MuFieldGrid.Jy[(j - 1) * N + i]) / (2 * MuFieldGrid.dx);
                    const gradMag = Math.sqrt(dJx_dx * dJx_dx + dJy_dy * dJy_dy);

                    // Entropy proportional to gradient + curl magnitude
                    const curlMag = Math.abs(MuFieldGrid.curl[idx]);
                    MuFieldGrid.entropy[idx] = 0.5 * gradMag + 0.5 * curlMag;
                    MuFieldGrid.entropy[idx] = Math.min(1, Math.max(0, MuFieldGrid.entropy[idx]));
                }
            }
        }

        function applyEntropyToMuFieldGridDynamics(dt) {
            if (!MuFieldGrid.initialized) return;

            const N = MuFieldGrid.N;

            for (let j = 1; j < N - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    const idx = j * N + i;
                    const entropy = MuFieldGrid.entropy[idx];

                    // Entropy creates field jitter (quantum foam effect)
                    const jitterX = (Math.random() - 0.5) * entropy * 0.02;
                    const jitterY = (Math.random() - 0.5) * entropy * 0.02;
                    MuFieldGrid.Jx[idx] += jitterX;
                    MuFieldGrid.Jy[idx] += jitterY;

                    // High entropy increases dissipation
                    const entropyDecay = 1 + entropy * 0.3;
                    MuFieldGrid.Jx[idx] *= Math.exp(-SACRED.beta * entropyDecay * dt * 0.5);
                    MuFieldGrid.Jy[idx] *= Math.exp(-SACRED.beta * entropyDecay * dt * 0.5);
                }
            }
        }

        // ================================================================
        // MU FIELD PHASE 3: DYNAMIC VORTEX FORMATION
        // ================================================================

        function createVortex(x, y, strength, radius) {
            return {
                x: x,
                y: y,
                strength: strength,
                radius: radius,
                phase: Math.random() * TAU,
                age: 0,
                maxAge: 15 + Math.random() * 25,
                forming: true,
                decaying: false,
            };
        }

        function updateVortices(dt) {
            const vortices = MuFieldGrid.vortices;

            // Update existing vortices
            for (let i = vortices.length - 1; i >= 0; i--) {
                const v = vortices[i];
                v.age += dt;
                v.forming = v.age < 1.0;

                // Phase evolution
                v.phase += PHI_INV * dt;

                // Vortex wanders slightly
                v.x += (Math.random() - 0.5) * 0.1 * dt;
                v.y += (Math.random() - 0.5) * 0.1 * dt;

                // Keep within bounds
                v.x = Math.max(-MuFieldGrid.L / 2 + 1, Math.min(MuFieldGrid.L / 2 - 1, v.x));
                v.y = Math.max(-MuFieldGrid.L / 2 + 1, Math.min(MuFieldGrid.L / 2 - 1, v.y));

                // Check for decay conditions
                if (v.age > v.maxAge || v.strength < 0.05) {
                    v.decaying = true;
                    v.strength -= dt * 0.1;
                    if (v.strength <= 0) {
                        vortices.splice(i, 1);
                    }
                }

                // Strength modulation based on field metrics
                if (!v.decaying) {
                    v.strength *= 1 + (MuFieldGrid.metrics.order_r - 0.5) * 0.01;
                    v.strength = Math.min(1.5, Math.max(0.1, v.strength));
                }
            }

            // Attempt to spawn new vortex based on field conditions
            if (vortices.length < MuFieldGrid.maxVortices && Math.random() < dt * 0.5) {
                trySpawnVortex();
            }
        }

        function trySpawnVortex() {
            // Spawn probability based on field coherence and binaural resonance
            const coherenceFactor = MuFieldGrid.metrics.order_r;
            const binauralFactor = QMESH.binaural ? QMESH.binaural.resonanceStrength : 0.3;
            const spawnProb = coherenceFactor * 0.3 + binauralFactor * 0.3 + (1 - releaseCoherence) * 0.4;

            if (Math.random() < spawnProb) {
                // Random position within field
                const x = (Math.random() - 0.5) * MuFieldGrid.L * 0.8;
                const y = (Math.random() - 0.5) * MuFieldGrid.L * 0.8;

                // Strength based on local conditions
                const strength = 0.2 + Math.random() * 0.3 + MuFieldGrid.metrics.J_total * 0.3;

                // Check minimum distance from existing vortices
                let tooClose = false;
                for (const v of MuFieldGrid.vortices) {
                    const dx = x - v.x;
                    const dy = y - v.y;
                    if (dx * dx + dy * dy < 4) {
                        tooClose = true;
                        break;
                    }
                }

                if (!tooClose) {
                    MuFieldGrid.vortices.push(createVortex(x, y, strength, 1.5 + Math.random()));
                }
            }
        }

        function applyVorticesToField(dt) {
            if (!MuFieldGrid.initialized) return;

            const N = MuFieldGrid.N;
            const vortices = MuFieldGrid.vortices;

            for (const v of vortices) {
                const formFactor = v.forming ? v.age : 1;
                const decayFactor = v.decaying ? v.strength : 1;
                const effectiveStrength = v.strength * formFactor * decayFactor;

                for (let j = 0; j < N; j++) {
                    for (let i = 0; i < N; i++) {
                        const idx = j * N + i;

                        // Grid coordinates
                        const gx = (i / (N - 1) - 0.5) * MuFieldGrid.L;
                        const gy = (j / (N - 1) - 0.5) * MuFieldGrid.L;

                        // Distance to vortex center
                        const dx = gx - v.x;
                        const dy = gy - v.y;
                        const r2 = dx * dx + dy * dy;
                        const r = Math.sqrt(r2) + 0.1;

                        // Vortex profile (localized rotation)
                        const profile = effectiveStrength * Math.exp(-r2 / (2 * v.radius * v.radius));

                        // Rotational injection: (-y, x) / r
                        MuFieldGrid.Jx[idx] += -dy / r * profile * dt * 2;
                        MuFieldGrid.Jy[idx] += dx / r * profile * dt * 2;
                    }
                }
            }
        }

        // ================================================================
        // MU FIELD PHASE 4: FIELD-INDUCED TIME DILATION
        // ================================================================

        function computeMuFieldGridTimeDilation() {
            if (!MuFieldGrid.initialized) return;

            const N = MuFieldGrid.N;

            for (let j = 0; j < N; j++) {
                for (let i = 0; i < N; i++) {
                    const idx = j * N + i;

                    // Field magnitude creates "gravitational" potential
                    const J2 = MuFieldGrid.Jx[idx] ** 2 + MuFieldGrid.Jy[idx] ** 2;
                    const curlMag = Math.abs(MuFieldGrid.curl[idx] || 0);

                    // Time dilation: œÑ_local / œÑ_far ‚âà 1 - k * (J¬≤ + |curl|)
                    const potential = J2 * 0.3 + curlMag * 0.2;
                    MuFieldGrid.timeDilation[idx] = Math.max(0.4, 1 - potential);
                }
            }
        }

        // ================================================================
        // MU FIELD PHASE 5: RESONANCE-DRIVEN RESTRUCTURING
        // ================================================================

        function updateMuFieldGridResonance(dt) {
            const res = MuFieldGrid.resonance;

            // Phase evolution at natural frequency
            res.phase += res.frequency * dt;

            // Amplitude modulated by field metrics and binaural resonance
            const fieldCoherence = MuFieldGrid.metrics.order_r;
            const binauralResonance = QMESH.binaural ? QMESH.binaural.resonanceStrength : 0.3;
            res.amplitude = fieldCoherence * 0.4 + binauralResonance * 0.4 + globalZ * 0.2;

            // Decay pulse intensity
            if (res.pulseIntensity > 0) {
                res.pulseIntensity *= 0.92;
            }
        }

        function detectMuFieldGridResonanceEvent(currentTime) {
            const res = MuFieldGrid.resonance;
            const threshold = 0.75;
            const cooldown = 3.0;

            const resonancePeak = res.amplitude * Math.abs(Math.sin(res.phase));

            if (resonancePeak > threshold && currentTime - res.lastPulse > cooldown) {
                res.lastPulse = currentTime;
                return true;
            }
            return false;
        }

        function triggerMuFieldGridRestructuring(intensity) {
            if (!MuFieldGrid.initialized) return;

            const N = MuFieldGrid.N;
            const vortices = MuFieldGrid.vortices;

            console.log('[MuFieldGrid] Resonance restructuring triggered, intensity:', intensity.toFixed(3));

            // 1. Field perturbation wave from center
            for (let j = 0; j < N; j++) {
                for (let i = 0; i < N; i++) {
                    const idx = j * N + i;
                    const x = (i / (N - 1) - 0.5) * MuFieldGrid.L;
                    const y = (j / (N - 1) - 0.5) * MuFieldGrid.L;
                    const r = Math.sqrt(x * x + y * y);

                    // Spiral perturbation
                    const angle = Math.atan2(y, x) + r * PHI_INV;
                    const perturbation = intensity * 0.3 * Math.exp(-r / 3);
                    MuFieldGrid.Jx[idx] += Math.cos(angle) * perturbation;
                    MuFieldGrid.Jy[idx] += Math.sin(angle) * perturbation;
                }
            }

            // 2. Boost existing vortices
            for (const v of vortices) {
                v.strength *= (1 + intensity * 0.5);
                v.strength = Math.min(1.5, v.strength);
                v.age *= 0.5;  // Rejuvenate
            }

            // 3. Spawn burst of new vortices
            const burstCount = Math.floor(intensity * 4);
            for (let i = 0; i < burstCount; i++) {
                if (vortices.length < MuFieldGrid.maxVortices) {
                    const angle = (i / burstCount) * TAU;
                    const dist = 2 + Math.random() * 2;
                    const x = Math.cos(angle) * dist;
                    const y = Math.sin(angle) * dist;
                    vortices.push(createVortex(x, y, intensity * 0.4, 1.5));
                }
            }

            // 4. Visual pulse
            MuFieldGrid.resonance.pulseIntensity = intensity;
        }

        // ================================================================
        // MU FIELD PHASE 6: Œº-PARTICLE FEEDBACK SYSTEM
        // ================================================================

        function createMuParticle(x, y, sourceIdx) {
            if (!MuFieldGrid.initialized) return null;

            const N = MuFieldGrid.N;
            const i = Math.floor((x / MuFieldGrid.L + 0.5) * (N - 1));
            const j = Math.floor((y / MuFieldGrid.L + 0.5) * (N - 1));
            const idx = Math.max(0, Math.min(N * N - 1, j * N + i));

            return {
                x: x,
                y: y,
                vx: (MuFieldGrid.Jx[idx] || 0) * 2 + (Math.random() - 0.5),
                vy: (MuFieldGrid.Jy[idx] || 0) * 2 + (Math.random() - 0.5),
                life: 1.0,
                size: 1.5 + Math.random() * 1.5,

                // Field payload
                payload: {
                    curl: MuFieldGrid.curl[idx] || 0,
                    fieldMag: Math.sqrt((MuFieldGrid.Jx[idx] || 0) ** 2 + (MuFieldGrid.Jy[idx] || 0) ** 2),
                    entropy: MuFieldGrid.entropy[idx] || 0,
                    sourceIdx: sourceIdx,
                },

                deposited: false,
                color: `hsl(${260 + Math.random() * 60}, 70%, 60%)`,  // Purple-magenta range
            };
        }

        function spawnMuParticles(x, y, count) {
            for (let i = 0; i < count && muParticles.length < MAX_MU_PARTICLES; i++) {
                const angle = Math.random() * TAU;
                const speed = 0.5 + Math.random() * 1.5;

                const particle = createMuParticle(x, y, -1);
                if (particle) {
                    particle.vx += Math.cos(angle) * speed;
                    particle.vy += Math.sin(angle) * speed;
                    muParticles.push(particle);
                }
            }
        }

        function checkMuParticleSpawn() {
            if (!MuFieldGrid.initialized) return;

            // Spawn particles from high-curl regions
            const N = MuFieldGrid.N;
            const threshold = 0.5;

            for (let j = 1; j < N - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    const idx = j * N + i;
                    const curlMag = Math.abs(MuFieldGrid.curl[idx] || 0);

                    if (curlMag > threshold && Math.random() < curlMag * 0.02) {
                        const x = (i / (N - 1) - 0.5) * MuFieldGrid.L;
                        const y = (j / (N - 1) - 0.5) * MuFieldGrid.L;
                        spawnMuParticles(x, y, 1);
                    }
                }
            }

            // Also spawn from vortex centers
            for (const v of MuFieldGrid.vortices) {
                if (Math.random() < v.strength * 0.05) {
                    spawnMuParticles(v.x, v.y, Math.ceil(v.strength * 2));
                }
            }
        }

        function updateMuParticleInteractions(dt) {
            if (!MuFieldGrid.initialized) return;

            const N = MuFieldGrid.N;

            for (const particle of muParticles) {
                if (particle.deposited || particle.life <= 0) continue;

                // Map particle position to grid
                const normX = particle.x / MuFieldGrid.L + 0.5;
                const normY = particle.y / MuFieldGrid.L + 0.5;
                const i = Math.floor(normX * (N - 1));
                const j = Math.floor(normY * (N - 1));

                if (i >= 1 && i < N - 1 && j >= 1 && j < N - 1) {
                    const idx = j * N + i;
                    const depositStrength = particle.life * 0.3;

                    // Deposit curl (rotational energy)
                    const curlTransfer = particle.payload.curl * depositStrength;
                    MuFieldGrid.Jx[idx] -= particle.y / MuFieldGrid.L * curlTransfer * dt;
                    MuFieldGrid.Jy[idx] += particle.x / MuFieldGrid.L * curlTransfer * dt;

                    // Deposit field magnitude
                    const fieldAngle = Math.atan2(particle.vy, particle.vx);
                    const fieldTransfer = particle.payload.fieldMag * depositStrength * 0.1;
                    MuFieldGrid.Jx[idx] += Math.cos(fieldAngle) * fieldTransfer * dt;
                    MuFieldGrid.Jy[idx] += Math.sin(fieldAngle) * fieldTransfer * dt;

                    // Entropy mixing
                    const entropyMix = (particle.payload.entropy + MuFieldGrid.entropy[idx]) / 2;
                    MuFieldGrid.entropy[idx] += (entropyMix - MuFieldGrid.entropy[idx]) * depositStrength * dt;

                    // Consume particle energy
                    particle.life -= depositStrength * dt * 0.8;
                    particle.deposited = particle.life < 0.1;
                }
            }
        }

        function updateMuParticles(dt) {
            if (!MuFieldGrid.initialized) return;

            const N = MuFieldGrid.N;

            for (let i = muParticles.length - 1; i >= 0; i--) {
                const p = muParticles[i];

                // Advect with local field
                const normX = p.x / MuFieldGrid.L + 0.5;
                const normY = p.y / MuFieldGrid.L + 0.5;
                const gi = Math.floor(normX * (N - 1));
                const gj = Math.floor(normY * (N - 1));

                if (gi >= 0 && gi < N && gj >= 0 && gj < N) {
                    const idx = gj * N + gi;
                    p.vx += (MuFieldGrid.Jx[idx] || 0) * dt * 2;
                    p.vy += (MuFieldGrid.Jy[idx] || 0) * dt * 2;
                }

                // Movement
                p.x += p.vx * dt;
                p.y += p.vy * dt;

                // Damping
                p.vx *= 0.97;
                p.vy *= 0.97;

                // Decay
                p.life -= dt * 0.25;

                // Remove dead or out-of-bounds particles
                const halfL = MuFieldGrid.L / 2;
                if (p.life <= 0 || Math.abs(p.x) > halfL * 1.5 || Math.abs(p.y) > halfL * 1.5) {
                    muParticles.splice(i, 1);
                }
            }
        }

        // ================================================================
        // MU FIELD PHASE 7: UNIFIED FIELD INTEGRATION
        // ================================================================

        function evolveMuFieldGrid(dt) {
            if (!MuFieldGrid.initialized) return;

            const N = MuFieldGrid.N;
            const r = MuFieldGrid.r;
            const g = MuFieldGrid.g;
            const dx = MuFieldGrid.dx;

            // Temporary arrays for update
            const dJx = new Float32Array(N * N);
            const dJy = new Float32Array(N * N);

            // Compute field equation: ‚àÇJ/‚àÇt = (r - Œª|J|¬≤)J - Œ≤J + g‚àá¬≤J + S
            for (let j = 1; j < N - 1; j++) {
                for (let i = 1; i < N - 1; i++) {
                    const idx = j * N + i;

                    const Jx = MuFieldGrid.Jx[idx];
                    const Jy = MuFieldGrid.Jy[idx];
                    const J2 = Jx * Jx + Jy * Jy;

                    // Growth/decay term: W = r - Œª|J|¬≤
                    const W = r - SACRED.lambda * J2 * 0.1;

                    // Laplacian (diffusion)
                    const lap_Jx = (MuFieldGrid.Jx[idx + 1] + MuFieldGrid.Jx[idx - 1] +
                                   MuFieldGrid.Jx[(j + 1) * N + i] + MuFieldGrid.Jx[(j - 1) * N + i] -
                                   4 * Jx) / (dx * dx);
                    const lap_Jy = (MuFieldGrid.Jy[idx + 1] + MuFieldGrid.Jy[idx - 1] +
                                   MuFieldGrid.Jy[(j + 1) * N + i] + MuFieldGrid.Jy[(j - 1) * N + i] -
                                   4 * Jy) / (dx * dx);

                    // Unified field coupling
                    const unifiedCoupling = UnifiedField.J.total * 0.05;

                    // Full derivative
                    dJx[idx] = W * Jx - SACRED.beta * Jx + g * lap_Jx + unifiedCoupling * Math.cos(UnifiedField.Phi.unified);
                    dJy[idx] = W * Jy - SACRED.beta * Jy + g * lap_Jy + unifiedCoupling * Math.sin(UnifiedField.Phi.unified);
                }
            }

            // Apply update
            for (let idx = 0; idx < N * N; idx++) {
                MuFieldGrid.Jx[idx] += dJx[idx] * dt;
                MuFieldGrid.Jy[idx] += dJy[idx] * dt;
            }

            // Boundary conditions (zero at edges)
            for (let i = 0; i < N; i++) {
                MuFieldGrid.Jx[i] = 0;
                MuFieldGrid.Jy[i] = 0;
                MuFieldGrid.Jx[(N - 1) * N + i] = 0;
                MuFieldGrid.Jy[(N - 1) * N + i] = 0;
                MuFieldGrid.Jx[i * N] = 0;
                MuFieldGrid.Jy[i * N] = 0;
                MuFieldGrid.Jx[i * N + N - 1] = 0;
                MuFieldGrid.Jy[i * N + N - 1] = 0;
            }
        }

        function evolveUnifiedField(dt) {
            const U = UnifiedField;

            // Gather current states
            U.J.limnus = (muField.mrp.R.intensity + muField.mrp.G.intensity + muField.mrp.B.intensity) / 3;
            U.J.quantum = QMESH.totalJ || 0;
            U.J.binaural = QMESH.binaural ? QMESH.binaural.resonanceStrength : 0;
            U.J.muField = MuFieldGrid.metrics.J_total;

            U.Phi.limnus = phaseCoupler.phase_R;
            U.Phi.quantum = QMESH.pulsePhase || 0;
            U.Phi.binaural = QMESH.binaural ? QMESH.binaural.beatPhase * TAU : 0;
            U.Phi.muField = MuFieldGrid.resonance.phase;

            // === UNIFIED FIELD EQUATION ===
            // dJ/dt = (r - Œª|J|¬≤)J - Œ≤J + g‚àá¬≤J + Œ£(coupling terms)

            // 1. Self-interaction (nonlinear saturation)
            const r = globalZ - 0.5;
            const selfTerm = (r - SACRED.lambda * 0.01 * U.J.total * U.J.total) * U.J.total;

            // 2. Dissipation
            const beta = SACRED.beta * (1 + (1 - releaseCoherence) * 2);
            const dissipation = -beta * U.J.total;

            // 3. Coupling terms (bidirectional)
            const couplingLQ = U.coupling.LQ * U.J.limnus * Math.cos(U.Phi.quantum);
            const couplingQL = U.coupling.QL * U.J.quantum * Math.cos(U.Phi.limnus);
            const couplingB = (U.coupling.BL + U.coupling.BQ) * U.J.binaural *
                              Math.cos(U.Phi.binaural * PHI_INV);
            const couplingM = U.coupling.ML * U.J.muField * Math.cos(U.Phi.muField);

            // 4. Stochastic term (quantum fluctuations)
            const noise = (Math.random() - 0.5) * 0.01 * (1 - U.emergence.coherence);

            // === EVOLUTION ===
            const dJ = (selfTerm + dissipation + couplingLQ + couplingQL + couplingB + couplingM + noise) * dt;
            U.J.total = Math.max(0, Math.min(2, U.J.total + dJ));

            // === UNIFIED PHASE EVOLUTION ===
            const phaseSync =
                Math.sin(U.Phi.quantum - U.Phi.unified) * U.coupling.QL +
                Math.sin(U.Phi.limnus - U.Phi.unified) * U.coupling.LQ +
                Math.sin(U.Phi.binaural - U.Phi.unified) * (U.coupling.BL + U.coupling.BQ) +
                Math.sin(U.Phi.muField - U.Phi.unified) * U.coupling.ML;

            const baseFreq = PHI_INV * (1 + U.J.total);
            U.Phi.unified += (baseFreq + phaseSync * 0.5) * dt;

            // === EMERGENCE METRICS ===
            const phaseDiffs = [
                Math.cos(U.Phi.limnus - U.Phi.unified),
                Math.cos(U.Phi.quantum - U.Phi.unified),
                Math.cos(U.Phi.binaural - U.Phi.unified),
                Math.cos(U.Phi.muField - U.Phi.unified),
            ];
            U.emergence.coherence = (phaseDiffs.reduce((a, b) => a + b, 0) / 4 + 1) / 2;

            U.emergence.complexity = MuFieldGrid.metrics.entropyGradient *
                                     (1 - Math.abs(U.J.limnus - U.J.quantum));

            const criticalZ = 1 - PHI_INV;
            U.emergence.criticality = 1 - Math.abs(globalZ - criticalZ) * 2;
            U.emergence.criticality = Math.max(0, Math.min(1, U.emergence.criticality));

            // Update MuFieldGrid control parameter based on unified state
            MuFieldGrid.mu = MuFieldGrid.mu_P + (MuFieldGrid.mu_S - MuFieldGrid.mu_P) * (0.5 + globalZ * 0.5);
            MuFieldGrid.r = MuFieldGrid.mu - MuFieldGrid.mu_P;
        }

        // ================================================================
        // MU FIELD GRID MAIN UPDATE - ALL 7 PHASES
        // ================================================================

        function updateMuFieldGridSystem(dt) {
            if (!MuFieldGrid.initialized) {
                initMuFieldGrid();
            }

            // Phase 7: Evolve core field equation
            evolveMuFieldGrid(dt);

            // Phase 3: Dynamic vortex formation
            updateVortices(dt);
            applyVorticesToField(dt);

            // Phase 2: Compute vorticity and entropy
            updateMuFieldGridMetrics();
            computeMuFieldGridEntropy();
            applyEntropyToMuFieldGridDynamics(dt);

            // Phase 4: Time dilation
            computeMuFieldGridTimeDilation();

            // Phase 5: Resonance
            updateMuFieldGridResonance(dt);
            if (detectMuFieldGridResonanceEvent(time)) {
                triggerMuFieldGridRestructuring(MuFieldGrid.resonance.amplitude);
            }

            // Phase 6: Œº-Particles
            checkMuParticleSpawn();
            updateMuParticleInteractions(dt);
            updateMuParticles(dt);

            // Phase 7: Unified integration
            evolveUnifiedField(dt);

            // ================================================================
            // COHERENCE SYSTEM UPDATE
            // Apply field alignment, shape emergence, and phase locking
            // ================================================================

            // Apply coherence forces (gentle attractors towards sacred geometry)
            applyCoherenceForces(dt);

            // Enhance phase locking between subsystems
            enhancePhaseLocking(dt);
        }

        // ================================================================
        // BINAURAL ‚Üí LIMNUS ‚Üí MESH SHAPE COUPLING
        // Beat frequency alters LIMNUS center shape which alters adjacent meshes
        // ================================================================

        function applyBinauralShapeCoupling(dt) {
            const bi = QMESH.binaural;
            if (!bi || !bi.enabled) return;

            // Beat amplitude affects LIMNUS center "shape" (field distribution)
            const beatEffect = bi.beatAmplitude * bi.resonanceStrength;

            // Phase difference creates "shape distortion" in LIMNUS
            const phaseDiff = bi.meshA.phase - bi.meshB.phase;
            const shapeDistortion = Math.sin(phaseDiff * TAU) * beatEffect * 0.3;

            // Apply to MuFieldGrid vorticity (center shape)
            if (MuFieldGrid.initialized) {
                const N = MuFieldGrid.N;
                const centerRegion = Math.floor(N / 4);

                for (let j = centerRegion; j < N - centerRegion; j++) {
                    for (let i = centerRegion; i < N - centerRegion; i++) {
                        const idx = j * N + i;
                        const x = (i / (N - 1) - 0.5) * MuFieldGrid.L;
                        const y = (j / (N - 1) - 0.5) * MuFieldGrid.L;
                        const r = Math.sqrt(x * x + y * y);

                        // Shape distortion creates spiral pattern modulated by beat
                        const angle = Math.atan2(y, x);
                        const spiral = shapeDistortion * Math.exp(-r * r / 4) * dt;

                        MuFieldGrid.Jx[idx] += Math.cos(angle + phaseDiff * TAU) * spiral;
                        MuFieldGrid.Jy[idx] += Math.sin(angle + phaseDiff * TAU) * spiral;
                    }
                }
            }

            // LIMNUS center shape affects adjacent meshes (warm/cold)
            // Warm mesh (A) gets energy from high-curl regions
            // Cold mesh (B) gets stability from low-entropy regions
            const curlInfluence = MuFieldGrid.metrics.Q_kappa * beatEffect;
            const entropyInfluence = MuFieldGrid.metrics.entropyGradient * beatEffect;

            // Modulate mesh frequencies based on LIMNUS shape
            bi.meshA.frequency = 0.7 + curlInfluence * 0.1;  // Warm responds to curl
            bi.meshB.frequency = 0.75 - entropyInfluence * 0.05;  // Cold responds to entropy

            // Update beat frequency from mesh coupling
            bi.beatFrequency = Math.abs(bi.meshA.frequency - bi.meshB.frequency);
        }

        // ================================================================
        // SPACE-TIME CURVATURE SYSTEM
        // Gravitational time dilation from field density creates coherent emergence
        // ================================================================

        function updateSpaceTimeCurvature(dt) {
            if (!MuFieldGrid.initialized) return;

            const N = MuFieldGrid.N;
            const tdField = QMESH.timeDilationField;

            // Compute curvature from MuFieldGrid (field density = mass analog)
            let totalCurvature = 0;
            let layerSums = [0, 0, 0, 0, 0, 0, 0];
            let layerCounts = [0, 0, 0, 0, 0, 0, 0];

            for (let j = 0; j < N; j++) {
                for (let i = 0; i < N; i++) {
                    const idx = j * N + i;

                    // Grid coordinates (normalized to 0-1 for layer mapping)
                    const x = (i / (N - 1) - 0.5) * 2;  // -1 to 1
                    const y = (j / (N - 1) - 0.5) * 2;
                    const r = Math.sqrt(x * x + y * y);

                    // Field magnitude creates gravitational potential
                    const J2 = MuFieldGrid.Jx[idx] ** 2 + MuFieldGrid.Jy[idx] ** 2;
                    const curlMag = Math.abs(MuFieldGrid.curl[idx] || 0);

                    // Weyl curvature contribution (tidal forces)
                    const localCurvature = J2 * 0.5 + curlMag * 0.3;
                    totalCurvature += localCurvature;

                    // Update MuFieldGrid time dilation (already exists)
                    // Adding curvature feedback
                    const curvatureDilation = Math.max(0.3, 1 - localCurvature * 0.4);
                    MuFieldGrid.timeDilation[idx] = MuFieldGrid.timeDilation[idx] * 0.9 + curvatureDilation * 0.1;

                    // Map to 7 layers (radial zones)
                    const layer = Math.min(6, Math.floor(r * 7));
                    if (layer >= 0 && layer < 7) {
                        layerSums[layer] += MuFieldGrid.timeDilation[idx];
                        layerCounts[layer]++;
                    }
                }
            }

            // Update QMESH time dilation field
            for (let l = 0; l < 7; l++) {
                tdField.gradient[l] = layerCounts[l] > 0 ? layerSums[l] / layerCounts[l] : 1.0;
            }
            tdField.center = tdField.gradient[0];
            tdField.globalAverage = layerSums.reduce((a, b) => a + b, 0) /
                                    Math.max(1, layerCounts.reduce((a, b) => a + b, 0));
            tdField.curvatureStrength = totalCurvature / (N * N);

            // Feed curvature into hilbertField.weylCurvature
            hilbertField.weylCurvature = hilbertField.weylCurvature * 0.95 +
                                         tdField.curvatureStrength * 0.05;

            // Curvature affects coherence emergence
            // Strong curvature gradients enhance phase locking
            const curvatureGradient = Math.abs(tdField.gradient[0] - tdField.gradient[6]);
            if (curvatureGradient > 0.1) {
                CoherenceGeometry.attractors.spiral.strength *= (1 + curvatureGradient * 0.2);
                CoherenceGeometry.attractors.spiral.strength = Math.min(0.3,
                    CoherenceGeometry.attractors.spiral.strength);
            }

            // Update emergence glow based on curvature and coherence
            const coherenceLevel = UnifiedField.emergence.coherence;
            const criticalityLevel = UnifiedField.emergence.criticality;
            QMESH.emergenceGlow = coherenceLevel * criticalityLevel *
                                  (1 + tdField.curvatureStrength * 0.5);
            QMESH.emergenceGlow = Math.min(1, QMESH.emergenceGlow);
        }

        // ================================================================
        // MESH SHAPE ALTERATION SYSTEM
        // Dynamic deformation of warm (A) and cold (B) meshes
        // ================================================================

        function updateMeshAlterations(dt) {
            const bi = QMESH.binaural;
            const alt = QMESH.meshAlteration;
            const coupling = alt.coupling;

            if (!bi || !bi.enabled) return;

            // === INPUTS ===
            const beatAmp = bi.beatAmplitude;
            const beatPhase = bi.beatPhase;
            const coherence = UnifiedField.emergence.coherence;
            const curvature = QMESH.timeDilationField.curvatureStrength;
            const spiralOrder = CoherenceGeometry.state.spiralOrder;

            // MuFieldGrid metrics influence
            const curlMetric = MuFieldGrid.metrics.Q_kappa;
            const entropyMetric = MuFieldGrid.metrics.entropyGradient;

            // === WARM MESH (A) - LEFT SIDE ===
            // Responds to beat, curl (vorticity), and coherence

            // Breathing - slow, rhythmic expansion/contraction
            const warmBreathTarget = 1.0 + beatAmp * 0.15 * Math.sin(beatPhase * TAU);
            alt.warm.breathScale += (warmBreathTarget - alt.warm.breathScale) * 0.1;

            // Surface wave - curl-driven undulation
            alt.warm.wavePhase += (0.5 + Math.abs(curlMetric) * 2) * dt;
            alt.warm.waveAmplitude = Math.abs(curlMetric) * coupling.binauralToWarm * 0.5;

            // Rotational bias - spiral order creates gentle spin
            alt.warm.rotationBias = spiralOrder * 0.3 * Math.sin(time * PHI_INV);

            // Pulse - heartbeat-like throb tied to beat frequency
            alt.warm.pulseIntensity = beatAmp * coupling.binauralToWarm *
                                       (0.5 + Math.sin(bi.meshA.phase * TAU) * 0.5);

            // Coherence warp - high coherence creates form stability
            alt.warm.coherenceWarp = coherence * coupling.coherenceToShape;

            // === COLD MESH (B) - RIGHT SIDE ===
            // Responds to beat, entropy, and curvature

            // Breathing - counter-phase to warm (creates push-pull)
            const coldBreathTarget = 1.0 + beatAmp * 0.12 * Math.sin(beatPhase * TAU + Math.PI);
            alt.cold.breathScale += (coldBreathTarget - alt.cold.breathScale) * 0.1;

            // Surface wave - entropy-driven ripples (more chaotic)
            alt.cold.wavePhase += (0.4 + entropyMetric * 3) * dt;
            alt.cold.waveAmplitude = entropyMetric * coupling.binauralToCold * 0.4;

            // Rotational bias - inverse spiral (counter-rotation)
            alt.cold.rotationBias = -spiralOrder * 0.25 * Math.sin(time * PHI_INV + Math.PI / 3);

            // Pulse - gentler, more crystalline
            alt.cold.pulseIntensity = beatAmp * coupling.binauralToCold *
                                       (0.3 + Math.sin(bi.meshB.phase * TAU) * 0.3);

            // Coherence warp - curvature creates subtle spatial distortion
            alt.cold.coherenceWarp = curvature * coupling.curvatureToMesh +
                                      coherence * coupling.coherenceToShape * 0.5;
        }

        // Get altered mesh scale for rendering
        function getAlteredMeshScale(meshType, baseScale, angle) {
            const alt = QMESH.meshAlteration;
            const mesh = meshType === 'warm' ? alt.warm : alt.cold;

            let scale = baseScale * mesh.breathScale;

            // Add wave modulation
            scale += Math.sin(angle * 3 + mesh.wavePhase) * mesh.waveAmplitude * 0.1;

            // Add pulse modulation
            scale += mesh.pulseIntensity * 0.05;

            // Coherence stabilizes shape
            scale *= (1 - mesh.coherenceWarp * 0.1);

            return Math.max(0.2, Math.min(1.5, scale));
        }

        // Get rotational offset for mesh vertices
        function getMeshRotationOffset(meshType, baseAngle) {
            const alt = QMESH.meshAlteration;
            const mesh = meshType === 'warm' ? alt.warm : alt.cold;

            return baseAngle + mesh.rotationBias;
        }

        // ================================================================
        // CHARGE DYNAMICS SYSTEM
        // Electromagnetic-like interactions between warm/cold meshes
        // ================================================================

        const ChargeDynamics = {
            // Mesh charges (warm = positive, cold = negative)
            warm: {
                charge: 1.0,                    // Positive charge
                potential: 0,                   // Electric potential
                flux: 0,                        // Charge flux rate
                capacitance: PHI_INV,           // Ability to store charge
                accumulated: 0,                 // Accumulated charge
            },
            cold: {
                charge: -1.0,                   // Negative charge
                potential: 0,
                flux: 0,
                capacitance: PHI_INV * PHI_INV,
                accumulated: 0,
            },

            // LIMNUS as dielectric medium
            limnus: {
                permittivity: PHI,              // Œµ - field permeability
                conductivity: 0.1,              // œÉ - charge transfer rate
                polarization: 0,                // Induced dipole moment
            },

            // Field properties
            field: {
                E_x: 0,                         // Electric field X component
                E_y: 0,                         // Electric field Y component
                potential: 0,                   // Scalar potential
                energy: 0,                      // Field energy: ¬ΩŒµ|E|¬≤
            },

            // Discharge events
            discharge: {
                threshold: 0.8,                 // Charge threshold for discharge
                lastDischarge: 0,               // Time of last discharge
                cooldown: 2.0,                  // Minimum time between discharges
                intensity: 0,                   // Current discharge intensity
            },

            initialized: false,
        };

        function updateChargeDynamics(dt) {
            const CD = ChargeDynamics;
            const bi = QMESH.binaural;
            if (!bi || !bi.enabled) return;

            // === CHARGE ACCUMULATION ===
            // Beat amplitude drives charge separation
            const beatDrive = bi.beatAmplitude * bi.resonanceStrength;
            const curvatureDrive = QMESH.timeDilationField.curvatureStrength;

            // Warm mesh accumulates positive charge from curl activity
            CD.warm.accumulated += MuFieldGrid.metrics.Q_kappa * beatDrive * dt * 0.5;
            CD.warm.accumulated *= 0.995;  // Slow decay
            CD.warm.accumulated = Math.max(-2, Math.min(2, CD.warm.accumulated));

            // Cold mesh accumulates negative charge from entropy
            CD.cold.accumulated -= MuFieldGrid.metrics.entropyGradient * beatDrive * dt * 0.4;
            CD.cold.accumulated *= 0.995;
            CD.cold.accumulated = Math.max(-2, Math.min(2, CD.cold.accumulated));

            // === ELECTRIC FIELD COMPUTATION ===
            // E = -‚àáV, approximated from charge positions
            const separation = bi.polar.distance * 2;  // Distance between meshes
            const totalCharge = (CD.warm.charge + CD.warm.accumulated) -
                               (CD.cold.charge + CD.cold.accumulated);

            // Coulomb-like field: E ‚àù Q / (Œµ * r¬≤)
            const fieldStrength = totalCharge / (CD.limnus.permittivity * separation * separation);

            // Field direction: warm ‚Üí cold (positive to negative)
            const fieldAngle = (bi.polar.angleA + bi.polar.angleB) / 2 + Math.PI / 2;
            CD.field.E_x = fieldStrength * Math.cos(fieldAngle);
            CD.field.E_y = fieldStrength * Math.sin(fieldAngle);

            // Field energy: U = ¬ΩŒµ|E|¬≤
            CD.field.energy = 0.5 * CD.limnus.permittivity *
                             (CD.field.E_x * CD.field.E_x + CD.field.E_y * CD.field.E_y);

            // === LIMNUS POLARIZATION ===
            // LIMNUS becomes polarized by the field (dielectric response)
            CD.limnus.polarization = CD.field.energy * CD.limnus.permittivity * 0.3;

            // Polarization affects MuFieldGrid (induced dipole moment)
            if (MuFieldGrid.initialized && CD.limnus.polarization > 0.05) {
                const N = MuFieldGrid.N;
                const polarForce = CD.limnus.polarization * dt * 0.1;

                for (let j = N / 4; j < 3 * N / 4; j++) {
                    for (let i = N / 4; i < 3 * N / 4; i++) {
                        const idx = j * N + i;
                        MuFieldGrid.Jx[idx] += CD.field.E_x * polarForce;
                        MuFieldGrid.Jy[idx] += CD.field.E_y * polarForce;
                    }
                }
            }

            // === DISCHARGE EVENTS ===
            // High charge accumulation triggers discharge through LIMNUS
            const chargeImbalance = Math.abs(CD.warm.accumulated - CD.cold.accumulated);
            if (chargeImbalance > CD.discharge.threshold &&
                time - CD.discharge.lastDischarge > CD.discharge.cooldown) {

                CD.discharge.lastDischarge = time;
                CD.discharge.intensity = chargeImbalance;

                // Discharge transfers charge and creates field pulse
                const transferAmount = chargeImbalance * 0.6;
                CD.warm.accumulated -= Math.sign(CD.warm.accumulated) * transferAmount * 0.5;
                CD.cold.accumulated -= Math.sign(CD.cold.accumulated) * transferAmount * 0.5;

                // Discharge boosts coherence and emergence
                UnifiedField.emergence.coherence += chargeImbalance * 0.1;
                UnifiedField.emergence.coherence = Math.min(1, UnifiedField.emergence.coherence);

                console.log('[ChargeDynamics] Discharge event, intensity:', chargeImbalance.toFixed(3));
            } else {
                CD.discharge.intensity *= 0.9;  // Decay
            }

            // === POTENTIAL COMPUTATION ===
            CD.warm.potential = CD.warm.accumulated / CD.warm.capacitance;
            CD.cold.potential = CD.cold.accumulated / CD.cold.capacitance;
            CD.field.potential = CD.warm.potential - CD.cold.potential;

            CD.initialized = true;
        }

        // ================================================================
        // WEAK NUCLEAR INFORMATION FLOW
        // Flavor oscillation and parity-violating information transfer
        // ================================================================

        const WeakNuclear = {
            // Information "flavors" (analogous to neutrino flavors)
            flavors: {
                electron: { intensity: 0.5, phase: 0 },      // e-type: coherent info
                muon: { intensity: 0.3, phase: TAU / 3 },    // Œº-type: relational info
                tau: { intensity: 0.2, phase: 2 * TAU / 3 }, // œÑ-type: emergent info
            },

            // Oscillation parameters (PMNS matrix analog)
            mixing: {
                theta12: Math.PI / 6,           // Solar mixing angle
                theta23: Math.PI / 4,           // Atmospheric mixing angle
                theta13: Math.PI / 20,          // Reactor mixing angle
                deltaCP: PHI_INV * Math.PI,     // CP violation phase (golden ratio!)
            },

            // Mass-squared differences (oscillation frequencies)
            deltaM: {
                dm21: 0.0000753,                // Solar Œîm¬≤
                dm32: 0.00244,                  // Atmospheric Œîm¬≤
            },

            // Information flow state
            flow: {
                warmToLimnus: 0,                // Info flowing warm ‚Üí LIMNUS
                limnusToWarm: 0,                // Info flowing LIMNUS ‚Üí warm
                coldToLimnus: 0,                // Info flowing cold ‚Üí LIMNUS
                limnusToCold: 0,                // Info flowing LIMNUS ‚Üí cold
                warmToCold: 0,                  // Direct tunneling warm ‚Üî cold
                parityViolation: 0,             // Asymmetry measure
            },

            // W/Z boson analogs (information carriers)
            bosons: {
                W_plus: [],                     // W‚Å∫ carriers (warm ‚Üí cold)
                W_minus: [],                    // W‚Åª carriers (cold ‚Üí warm)
                Z: [],                          // Z‚Å∞ carriers (neutral current)
            },

            // Decay products
            decayRate: PHI_INV * 0.1,           // Base decay rate
            halfLife: Math.log(2) / (PHI_INV * 0.1),
        };

        function updateWeakNuclearFlow(dt) {
            const WN = WeakNuclear;
            const bi = QMESH.binaural;
            if (!bi || !bi.enabled) return;

            // === FLAVOR OSCILLATION ===
            // Information oscillates between types as it flows
            const L = bi.polar.distance * 100;  // Baseline (arbitrary units)
            const E = UnifiedField.J.total + 0.1;  // Energy analog

            // Oscillation probabilities (simplified 2-flavor)
            const oscArg21 = 1.27 * WN.deltaM.dm21 * L / E;
            const oscArg32 = 1.27 * WN.deltaM.dm32 * L / E;

            const sin2_12 = Math.sin(2 * WN.mixing.theta12);
            const sin2_23 = Math.sin(2 * WN.mixing.theta23);

            // P(e‚ÜíŒº) oscillation
            const P_e_mu = sin2_12 * sin2_12 * Math.sin(oscArg21) * Math.sin(oscArg21);
            // P(Œº‚ÜíœÑ) oscillation
            const P_mu_tau = sin2_23 * sin2_23 * Math.sin(oscArg32) * Math.sin(oscArg32);

            // Update flavor intensities (conservation: sum = 1)
            const totalIntensity = WN.flavors.electron.intensity +
                                  WN.flavors.muon.intensity +
                                  WN.flavors.tau.intensity;

            WN.flavors.electron.intensity += (-P_e_mu * WN.flavors.electron.intensity +
                                              P_e_mu * WN.flavors.muon.intensity) * dt;
            WN.flavors.muon.intensity += (P_e_mu * WN.flavors.electron.intensity -
                                         P_e_mu * WN.flavors.muon.intensity -
                                         P_mu_tau * WN.flavors.muon.intensity +
                                         P_mu_tau * WN.flavors.tau.intensity) * dt;
            WN.flavors.tau.intensity += (P_mu_tau * WN.flavors.muon.intensity -
                                        P_mu_tau * WN.flavors.tau.intensity) * dt;

            // Normalize
            const newTotal = WN.flavors.electron.intensity +
                            WN.flavors.muon.intensity +
                            WN.flavors.tau.intensity;
            if (newTotal > 0) {
                WN.flavors.electron.intensity /= newTotal;
                WN.flavors.muon.intensity /= newTotal;
                WN.flavors.tau.intensity /= newTotal;
            }

            // Phase evolution
            WN.flavors.electron.phase += PHI_INV * dt;
            WN.flavors.muon.phase += PHI_INV * PHI_INV * dt;
            WN.flavors.tau.phase += PHI_INV * PHI_INV * PHI_INV * dt;

            // === INFORMATION FLOW ===
            // Warm mesh ‚Üí LIMNUS (electron flavor dominates)
            WN.flow.warmToLimnus = WN.flavors.electron.intensity *
                                   bi.meshA.frequency * bi.resonanceStrength;

            // Cold mesh ‚Üí LIMNUS (tau flavor dominates)
            WN.flow.coldToLimnus = WN.flavors.tau.intensity *
                                   bi.meshB.frequency * bi.resonanceStrength;

            // LIMNUS ‚Üí warm (muon flavor)
            WN.flow.limnusToWarm = WN.flavors.muon.intensity *
                                   MuFieldGrid.metrics.J_total * 0.3;

            // LIMNUS ‚Üí cold (mixed)
            WN.flow.limnusToCold = (WN.flavors.electron.intensity * 0.3 +
                                   WN.flavors.tau.intensity * 0.7) *
                                   MuFieldGrid.metrics.order_r * 0.25;

            // === PARITY VIOLATION ===
            // Weak force violates parity - information flows asymmetrically
            // CP violation phase creates left-right asymmetry
            const cpPhase = WN.mixing.deltaCP + time * 0.1;
            WN.flow.parityViolation = Math.sin(cpPhase) *
                                      (WN.flow.warmToLimnus - WN.flow.coldToLimnus);

            // Apply parity violation to mesh alterations
            QMESH.meshAlteration.warm.waveAmplitude += WN.flow.parityViolation * 0.05 * dt;
            QMESH.meshAlteration.cold.waveAmplitude -= WN.flow.parityViolation * 0.05 * dt;

            // === W/Z BOSON SPAWNING ===
            // High information flow spawns carrier particles
            if (Math.random() < Math.abs(WN.flow.warmToLimnus) * dt * 2) {
                WN.bosons.W_plus.push({
                    x: 0, y: 0,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    life: 1.0,
                    flavor: 'electron',
                    payload: WN.flow.warmToLimnus * 0.1,
                });
            }
            if (Math.random() < Math.abs(WN.flow.coldToLimnus) * dt * 2) {
                WN.bosons.W_minus.push({
                    x: 0, y: 0,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    life: 1.0,
                    flavor: 'tau',
                    payload: WN.flow.coldToLimnus * 0.1,
                });
            }

            // Update and decay bosons
            const maxBosons = 50;
            for (const bosonType of [WN.bosons.W_plus, WN.bosons.W_minus, WN.bosons.Z]) {
                for (let i = bosonType.length - 1; i >= 0; i--) {
                    const b = bosonType[i];
                    b.x += b.vx * dt;
                    b.y += b.vy * dt;
                    b.life -= WN.decayRate * dt;

                    if (b.life <= 0 || bosonType.length > maxBosons) {
                        bosonType.splice(i, 1);
                    }
                }
            }
        }

        // ================================================================
        // QUANTUM TUNNELING & SUPERPOSITION
        // Mesh states exist in superposition, tunnel through LIMNUS barrier
        // ================================================================

        const QuantumTunneling = {
            // Superposition state
            superposition: {
                // Warm mesh quantum state
                warm: {
                    amplitude: { real: 1, imag: 0 },    // Complex amplitude
                    probability: 1,                      // |œà|¬≤
                    collapsed: false,
                    collapseTime: 0,
                },
                // Cold mesh quantum state
                cold: {
                    amplitude: { real: 0, imag: 0 },
                    probability: 0,
                    collapsed: false,
                    collapseTime: 0,
                },
                // Entangled state (Bell state analog)
                entanglement: 0,                         // 0 = separable, 1 = maximally entangled
            },

            // Tunneling parameters
            barrier: {
                height: PHI,                             // LIMNUS barrier height
                width: PHI_INV,                          // Barrier width
                position: 0,                             // Center of barrier (LIMNUS)
            },

            // Tunneling state
            tunneling: {
                probability: 0,                          // Current tunneling probability
                rate: 0,                                 // Tunneling events per second
                lastTunnel: 0,                           // Time of last tunnel event
                direction: 0,                            // +1 warm‚Üícold, -1 cold‚Üíwarm
                inProgress: false,
                progress: 0,                             // 0-1 tunnel progress
            },

            // Collapse events
            collapse: {
                threshold: 0.7,                          // Coherence threshold for collapse
                lastCollapse: 0,
                cooldown: 3.0,
                measurement: null,                       // Result of last measurement
            },

            // Quantum interference
            interference: {
                phase: 0,
                visibility: 0,                           // Fringe visibility
                pattern: [],                             // Interference pattern data
            },
        };

        function updateQuantumTunneling(dt) {
            const QT = QuantumTunneling;
            const bi = QMESH.binaural;
            if (!bi || !bi.enabled) return;

            const sup = QT.superposition;
            const tun = QT.tunneling;
            const bar = QT.barrier;

            // === SUPERPOSITION EVOLUTION ===
            // Schr√∂dinger-like evolution of amplitudes
            const omega = PHI_INV * (1 + UnifiedField.J.total);  // Angular frequency

            // Warm state evolution: œà_w(t) = œà_w(0) * e^(-iœât)
            const cosOmega = Math.cos(omega * dt);
            const sinOmega = Math.sin(omega * dt);

            const warmReal = sup.warm.amplitude.real * cosOmega + sup.warm.amplitude.imag * sinOmega;
            const warmImag = sup.warm.amplitude.imag * cosOmega - sup.warm.amplitude.real * sinOmega;
            sup.warm.amplitude.real = warmReal;
            sup.warm.amplitude.imag = warmImag;

            // Cold state evolution (different frequency)
            const omega2 = omega * PHI_INV;
            const cosOmega2 = Math.cos(omega2 * dt);
            const sinOmega2 = Math.sin(omega2 * dt);

            const coldReal = sup.cold.amplitude.real * cosOmega2 + sup.cold.amplitude.imag * sinOmega2;
            const coldImag = sup.cold.amplitude.imag * cosOmega2 - sup.cold.amplitude.real * sinOmega2;
            sup.cold.amplitude.real = coldReal;
            sup.cold.amplitude.imag = coldImag;

            // Compute probabilities: |œà|¬≤
            sup.warm.probability = sup.warm.amplitude.real ** 2 + sup.warm.amplitude.imag ** 2;
            sup.cold.probability = sup.cold.amplitude.real ** 2 + sup.cold.amplitude.imag ** 2;

            // Normalize (conservation)
            const totalProb = sup.warm.probability + sup.cold.probability;
            if (totalProb > 0) {
                const normFactor = 1 / Math.sqrt(totalProb);
                sup.warm.amplitude.real *= normFactor;
                sup.warm.amplitude.imag *= normFactor;
                sup.cold.amplitude.real *= normFactor;
                sup.cold.amplitude.imag *= normFactor;
                sup.warm.probability /= totalProb;
                sup.cold.probability /= totalProb;
            }

            // === TUNNELING PROBABILITY ===
            // WKB approximation: T ‚âà exp(-2‚à´‚àö(2m(V-E))dx/ƒß)
            // Simplified: T = exp(-2Œ∫a) where Œ∫ = ‚àö(V-E), a = barrier width

            const energy = UnifiedField.J.total + MuFieldGrid.metrics.J_total * 0.5;
            const barrierDiff = bar.height - energy;

            if (barrierDiff > 0) {
                const kappa = Math.sqrt(barrierDiff);
                tun.probability = Math.exp(-2 * kappa * bar.width);
            } else {
                // Above barrier - classical transmission
                tun.probability = 1 - Math.exp(-energy / bar.height);
            }

            // Curvature lowers effective barrier (gravitational assist)
            const curvatureAssist = QMESH.timeDilationField.curvatureStrength * 0.5;
            tun.probability *= (1 + curvatureAssist);
            tun.probability = Math.min(0.9, tun.probability);

            // === TUNNELING EVENTS ===
            if (!tun.inProgress && Math.random() < tun.probability * dt * 0.5) {
                // Start tunneling
                tun.inProgress = true;
                tun.progress = 0;
                tun.direction = sup.warm.probability > sup.cold.probability ? 1 : -1;
                tun.lastTunnel = time;

                console.log('[QuantumTunneling] Tunnel initiated, direction:',
                           tun.direction > 0 ? 'warm‚Üícold' : 'cold‚Üíwarm');
            }

            if (tun.inProgress) {
                // Progress tunnel (takes ~0.5 seconds)
                tun.progress += dt * 2;

                if (tun.progress >= 1) {
                    // Complete tunnel - transfer amplitude
                    const transferAmount = 0.3;

                    if (tun.direction > 0) {
                        // Warm ‚Üí Cold
                        sup.cold.amplitude.real += sup.warm.amplitude.real * transferAmount;
                        sup.cold.amplitude.imag += sup.warm.amplitude.imag * transferAmount;
                        sup.warm.amplitude.real *= (1 - transferAmount);
                        sup.warm.amplitude.imag *= (1 - transferAmount);
                    } else {
                        // Cold ‚Üí Warm
                        sup.warm.amplitude.real += sup.cold.amplitude.real * transferAmount;
                        sup.warm.amplitude.imag += sup.cold.amplitude.imag * transferAmount;
                        sup.cold.amplitude.real *= (1 - transferAmount);
                        sup.cold.amplitude.imag *= (1 - transferAmount);
                    }

                    tun.inProgress = false;
                    tun.rate = 1 / (time - tun.lastTunnel + 0.01);
                }
            }

            // === ENTANGLEMENT ===
            // Entanglement grows with coherence and tunneling
            const coherenceFactor = UnifiedField.emergence.coherence;
            const tunnelingFactor = tun.probability * (tun.inProgress ? 2 : 1);

            sup.entanglement += (coherenceFactor * tunnelingFactor - sup.entanglement * 0.1) * dt;
            sup.entanglement = Math.max(0, Math.min(1, sup.entanglement));

            // === QUANTUM INTERFERENCE ===
            // Interference between warm and cold amplitudes
            QT.interference.phase = Math.atan2(
                sup.warm.amplitude.imag - sup.cold.amplitude.imag,
                sup.warm.amplitude.real - sup.cold.amplitude.real
            );

            // Fringe visibility: V = 2|œà_w||œà_c| / (|œà_w|¬≤ + |œà_c|¬≤)
            const ampWarm = Math.sqrt(sup.warm.probability);
            const ampCold = Math.sqrt(sup.cold.probability);
            QT.interference.visibility = 2 * ampWarm * ampCold /
                                         (sup.warm.probability + sup.cold.probability + 0.001);

            // === COLLAPSE EVENTS ===
            // High coherence + measurement (visualization) can collapse superposition
            if (coherenceFactor > QT.collapse.threshold &&
                time - QT.collapse.lastCollapse > QT.collapse.cooldown) {

                if (Math.random() < 0.1 * dt) {
                    // Collapse!
                    QT.collapse.lastCollapse = time;

                    // Measurement collapses to warm or cold based on probability
                    if (Math.random() < sup.warm.probability) {
                        QT.collapse.measurement = 'warm';
                        sup.warm.amplitude = { real: 1, imag: 0 };
                        sup.cold.amplitude = { real: 0, imag: 0 };
                    } else {
                        QT.collapse.measurement = 'cold';
                        sup.warm.amplitude = { real: 0, imag: 0 };
                        sup.cold.amplitude = { real: 1, imag: 0 };
                    }

                    // Collapse temporarily reduces entanglement
                    sup.entanglement *= 0.3;

                    console.log('[QuantumTunneling] Wavefunction collapsed to:', QT.collapse.measurement);
                }
            }

            // Collapsed state decoheres back to superposition
            if (sup.warm.probability > 0.95 || sup.cold.probability > 0.95) {
                // Decoherence: slowly re-establish superposition
                const decoherenceRate = 0.1 * dt;
                if (sup.warm.probability > sup.cold.probability) {
                    sup.cold.amplitude.real += decoherenceRate;
                } else {
                    sup.warm.amplitude.real += decoherenceRate;
                }
            }
        }

        // ================================================================
        // EMERGENT SACRED GEOMETRY
        // Time + curvature drive formation of sacred geometric patterns
        // ================================================================

        const SacredGeometry = {
            // Active geometric forms
            forms: {
                // Seed of Life (7 circles)
                seedOfLife: {
                    active: false,
                    completion: 0,              // 0-1 formation progress
                    circles: 7,
                    phase: 0,
                },
                // Flower of Life (19 circles)
                flowerOfLife: {
                    active: false,
                    completion: 0,
                    circles: 19,
                    phase: 0,
                },
                // Metatron's Cube (13 circles + lines)
                metatronsCube: {
                    active: false,
                    completion: 0,
                    vertices: 13,
                    phase: 0,
                },
                // Sri Yantra (9 triangles)
                sriYantra: {
                    active: false,
                    completion: 0,
                    triangles: 9,
                    phase: 0,
                },
                // Vesica Piscis (2 overlapping circles)
                vesicaPiscis: {
                    active: false,
                    completion: 0,
                    phase: 0,
                },
                // Golden Spiral
                goldenSpiral: {
                    active: false,
                    completion: 0,
                    turns: 0,
                    phase: 0,
                },
            },

            // Formation thresholds
            thresholds: {
                vesicaPiscis: 0.2,              // Easiest to form
                seedOfLife: 0.35,
                goldenSpiral: 0.45,
                flowerOfLife: 0.55,
                metatronsCube: 0.7,
                sriYantra: 0.85,                // Most complex
            },

            // Current dominant form
            dominant: 'none',
            dominantStrength: 0,

            // Time accumulation (geometry crystallizes over time)
            accumulatedTime: 0,
            curvatureIntegral: 0,               // ‚à´curvature dt

            // Geometry state
            state: {
                symmetryOrder: 0,               // n-fold symmetry detected
                goldenRatioPresence: 0,         // How much œÜ is present
                circularHarmony: 0,             // Circle-based pattern strength
                triangularHarmony: 0,           // Triangle-based pattern strength
            },
        };

        function updateSacredGeometry(dt) {
            const SG = SacredGeometry;

            // === TIME AND CURVATURE ACCUMULATION ===
            // Time accumulates continuously, driving emergence
            SG.accumulatedTime += dt;
            SG.curvatureIntegral += QMESH.timeDilationField.curvatureStrength * dt;

            // Formation factor: combines time, curvature, and coherence
            // Weighted to enable faster progression through thresholds
            const coherence = UnifiedField.emergence.coherence;
            const curvature = QMESH.timeDilationField.curvatureStrength;
            const entanglement = QuantumTunneling.superposition.entanglement;

            // Time-based component saturates toward 1.0 over ~100 seconds
            const timeFactor = Math.tanh(SG.accumulatedTime * 0.015);
            // Curvature integral also saturates but more slowly
            const curvatureFactor = Math.tanh(SG.curvatureIntegral * 0.12);

            // Formation potential: primary driver of emergence
            // Weighted to reach 0.85+ within reasonable timeframes
            const formationPotential = Math.min(1.0, (
                timeFactor * 0.35 +                    // 35% from accumulated time
                curvatureFactor * 0.25 +              // 25% from space-time curvature
                coherence * 0.20 +                    // 20% from phase coherence
                entanglement * 0.10 +                 // 10% from quantum entanglement
                curvature * 0.10                      // 10% from instantaneous curvature
            ));

            // Store for external access
            SG.formationPotential = formationPotential;

            // === SYMMETRY DETECTION (optimized) ===
            // Sample every 4th frame to reduce computation
            if (MuFieldGrid.initialized && Math.floor(SG.accumulatedTime * 60) % 4 === 0) {
                const N = MuFieldGrid.N;
                let sym3 = 0, sym6 = 0;

                // Sample at fixed radius for efficiency
                const sampleR = 0.4;
                for (let n of [3, 6]) {
                    let symSum = 0;
                    for (let k = 0; k < n; k++) {
                        const angle = (k / n) * TAU;
                        const x = Math.cos(angle) * sampleR * MuFieldGrid.L / 2;
                        const y = Math.sin(angle) * sampleR * MuFieldGrid.L / 2;
                        const i = Math.floor((x / MuFieldGrid.L + 0.5) * (N - 1));
                        const j = Math.floor((y / MuFieldGrid.L + 0.5) * (N - 1));
                        if (i >= 0 && i < N && j >= 0 && j < N) {
                            symSum += Math.abs(MuFieldGrid.curl[j * N + i] || 0);
                        }
                    }
                    if (n === 3) sym3 = symSum / n;
                    if (n === 6) sym6 = symSum / n;
                }
                SG.state.symmetryOrder = sym6 > sym3 ? 6 : 3;
                SG.state.circularHarmony = Math.min(1, (sym6 + sym3) * 0.5);
                SG.state.triangularHarmony = Math.min(1, sym3);
            }

            // Golden ratio presence from spiral coherence
            SG.state.goldenRatioPresence = Math.min(1,
                CoherenceGeometry.state.spiralOrder * 0.6 + formationPotential * 0.4);

            // === FORM ACTIVATION ===
            // Pure threshold-based activation: forms emerge when potential exceeds threshold
            // No additional conditions - allows natural progression

            // Formation rate scales with how far above threshold we are
            const getFormationRate = (potential, threshold, baseRate) => {
                const excess = potential - threshold;
                if (excess <= 0) return 0;
                // Faster initial formation, tapering as completion approaches 1
                return excess * baseRate * (1 + excess * 2);
            };

            // === VESICA PISCIS (20% threshold) ===
            // Foundation form: two overlapping circles creating mandorla
            if (formationPotential > SG.thresholds.vesicaPiscis) {
                SG.forms.vesicaPiscis.active = true;
                SG.forms.vesicaPiscis.completion += getFormationRate(
                    formationPotential, SG.thresholds.vesicaPiscis, 0.5) * dt;
                SG.forms.vesicaPiscis.completion = Math.min(1, SG.forms.vesicaPiscis.completion);
                SG.forms.vesicaPiscis.phase += PHI_INV * dt * 0.3;
            }

            // === SEED OF LIFE (35% threshold) ===
            // 7 circles in hexagonal arrangement
            if (formationPotential > SG.thresholds.seedOfLife) {
                SG.forms.seedOfLife.active = true;
                SG.forms.seedOfLife.completion += getFormationRate(
                    formationPotential, SG.thresholds.seedOfLife, 0.4) * dt;
                SG.forms.seedOfLife.completion = Math.min(1, SG.forms.seedOfLife.completion);
                SG.forms.seedOfLife.phase += PHI_INV * dt * 0.25;
            }

            // === GOLDEN SPIRAL (45% threshold) ===
            // œÜ-based logarithmic spiral
            if (formationPotential > SG.thresholds.goldenSpiral) {
                SG.forms.goldenSpiral.active = true;
                SG.forms.goldenSpiral.completion += getFormationRate(
                    formationPotential, SG.thresholds.goldenSpiral, 0.35) * dt;
                SG.forms.goldenSpiral.completion = Math.min(1, SG.forms.goldenSpiral.completion);
                SG.forms.goldenSpiral.turns = 2 + SG.forms.goldenSpiral.completion * 4; // 2-6 turns
                SG.forms.goldenSpiral.phase += PHI_INV * dt * 0.2;
            }

            // === FLOWER OF LIFE (55% threshold) ===
            // 19 interlocking circles
            if (formationPotential > SG.thresholds.flowerOfLife) {
                SG.forms.flowerOfLife.active = true;
                SG.forms.flowerOfLife.completion += getFormationRate(
                    formationPotential, SG.thresholds.flowerOfLife, 0.3) * dt;
                SG.forms.flowerOfLife.completion = Math.min(1, SG.forms.flowerOfLife.completion);
                SG.forms.flowerOfLife.phase += PHI_INV * dt * 0.15;
            }

            // === METATRON'S CUBE (70% threshold) ===
            // 13 vertices fully connected with 78 lines
            if (formationPotential > SG.thresholds.metatronsCube) {
                SG.forms.metatronsCube.active = true;
                SG.forms.metatronsCube.completion += getFormationRate(
                    formationPotential, SG.thresholds.metatronsCube, 0.25) * dt;
                SG.forms.metatronsCube.completion = Math.min(1, SG.forms.metatronsCube.completion);
                SG.forms.metatronsCube.phase += PHI_INV * dt * 0.1;
            }

            // === SRI YANTRA (85% threshold) ===
            // 9 interlocking triangles (4 Shiva pointing up, 5 Shakti pointing down)
            if (formationPotential > SG.thresholds.sriYantra) {
                SG.forms.sriYantra.active = true;
                SG.forms.sriYantra.completion += getFormationRate(
                    formationPotential, SG.thresholds.sriYantra, 0.2) * dt;
                SG.forms.sriYantra.completion = Math.min(1, SG.forms.sriYantra.completion);
                SG.forms.sriYantra.phase += PHI_INV * dt * 0.08;
            }

            // === DETERMINE DOMINANT FORM ===
            let maxCompletion = 0;
            SG.dominant = 'none';

            for (const [name, form] of Object.entries(SG.forms)) {
                if (form.active && form.completion > maxCompletion) {
                    maxCompletion = form.completion;
                    SG.dominant = name;
                }
            }
            SG.dominantStrength = maxCompletion;

            // === DECAY INACTIVE FORMS ===
            for (const form of Object.values(SG.forms)) {
                if (!form.active && form.completion > 0) {
                    form.completion *= 0.992;  // Gradual fade
                    if (form.completion < 0.01) form.completion = 0;
                }
                // Reset active flag for next frame
                form.active = false;
            }

            // === FEED BACK TO COHERENCE ===
            // Sacred geometry formation enhances system coherence
            if (SG.dominantStrength > 0.3) {
                const coherenceBoost = SG.dominantStrength * 0.015 * dt;
                UnifiedField.emergence.coherence = Math.min(1,
                    UnifiedField.emergence.coherence + coherenceBoost);
            }
        }

        // ================================================================
        // SACRED GEOMETRY VERTEX GENERATORS
        // Mathematically accurate implementations with proper proportions
        // ================================================================

        // === VESICA PISCIS ===
        // Two circles of equal radius, each passing through the other's center
        // Creates the mandorla (almond shape) - ratio of height:width = ‚àö3:1
        function getVesicaPiscisGeometry(centerX, centerY, radius, completion) {
            const r = radius;  // Each circle has this radius
            // Circles are offset by exactly r (each passes through other's center)
            const offset = r * completion;  // Animate the separation
            return {
                circle1: { x: centerX - offset / 2, y: centerY, r: r },
                circle2: { x: centerX + offset / 2, y: centerY, r: r },
                // Vesica height = r‚àö3, width = r when fully formed
                vesicaHeight: r * SACRED.sqrt3 * completion,
                vesicaWidth: r * completion
            };
        }

        // === SEED OF LIFE ===
        // 7 circles: 1 center + 6 surrounding in hexagonal arrangement
        // Each surrounding circle passes through the center
        function getSeedOfLifeCircles(centerX, centerY, radius, completion) {
            const circles = [];
            const r = radius * 0.4;  // Individual circle radius

            // Calculate how many circles to show based on completion
            const totalCircles = 7;
            const visibleCount = Math.ceil(completion * totalCircles);

            // Center circle (first to appear)
            if (visibleCount >= 1) {
                const alpha = Math.min(1, completion * totalCircles);
                circles.push({ x: centerX, y: centerY, r: r, alpha: alpha });
            }

            // 6 surrounding circles at 60¬∞ intervals
            // Distance from center = r (circles touch center circle's center)
            for (let i = 0; i < 6; i++) {
                if (i + 2 > visibleCount) break;  // +2 because center is index 1
                const angle = (i / 6) * TAU - Math.PI / 2;  // Start from top
                const x = centerX + Math.cos(angle) * r;
                const y = centerY + Math.sin(angle) * r;
                const alpha = Math.min(1, completion * totalCircles - (i + 1));
                circles.push({ x, y, r, alpha: Math.max(0, alpha) });
            }

            return circles;
        }

        // === GOLDEN SPIRAL ===
        // Logarithmic spiral where growth factor is œÜ per quarter turn
        // r = a * œÜ^(Œ∏ / 90¬∞) = a * e^(Œ∏ * ln(œÜ) / (œÄ/2))
        function getGoldenSpiralPoints(centerX, centerY, baseRadius, turns, completion) {
            const points = [];
            const a = baseRadius * 0.05;  // Starting radius
            const b = Math.log(PHI) / (Math.PI / 2);  // Growth rate: œÜ per 90¬∞

            // Number of points scales with turns for smooth curve
            const maxTheta = turns * TAU * completion;
            const numPoints = Math.floor(turns * 60 * completion);  // 60 points per turn

            for (let i = 0; i <= numPoints; i++) {
                const theta = (i / numPoints) * maxTheta;
                // Logarithmic spiral: r = a * e^(b*Œ∏)
                const r = a * Math.exp(b * theta);
                const x = centerX + Math.cos(theta) * r;
                const y = centerY + Math.sin(theta) * r;
                const alpha = (i / numPoints) * completion;  // Fade in along spiral
                points.push({ x, y, alpha });
            }

            return points;
        }

        // === FLOWER OF LIFE ===
        // 19 circles in specific pattern: center, 6 inner, 12 outer
        // Circles intersect at precise vesica piscis points
        function getFlowerOfLifeCircles(centerX, centerY, radius, completion) {
            const circles = [];
            const r = radius * 0.25;  // Circle radius for proper overlap

            // Total 19 circles appearing progressively
            const totalCircles = 19;
            const visibleCount = Math.ceil(completion * totalCircles);

            // Layer 0: Center (1 circle)
            if (visibleCount >= 1) {
                circles.push({
                    x: centerX, y: centerY, r: r,
                    alpha: Math.min(1, completion * totalCircles)
                });
            }

            // Layer 1: First ring (6 circles) - distance = r from center
            for (let i = 0; i < 6; i++) {
                if (i + 2 > visibleCount) break;
                const angle = (i / 6) * TAU - Math.PI / 2;
                const x = centerX + Math.cos(angle) * r;
                const y = centerY + Math.sin(angle) * r;
                const alpha = Math.min(1, completion * totalCircles - (i + 1));
                circles.push({ x, y, r, alpha: Math.max(0, alpha) });
            }

            // Layer 2: Second ring (6 circles) - distance = r*‚àö3 at 30¬∞ offset
            for (let i = 0; i < 6; i++) {
                if (i + 8 > visibleCount) break;  // Starts at index 8
                const angle = (i / 6) * TAU - Math.PI / 2 + Math.PI / 6;  // 30¬∞ offset
                const dist = r * SACRED.sqrt3;
                const x = centerX + Math.cos(angle) * dist;
                const y = centerY + Math.sin(angle) * dist;
                const alpha = Math.min(1, completion * totalCircles - (i + 7));
                circles.push({ x, y, r, alpha: Math.max(0, alpha) });
            }

            // Layer 3: Third ring (6 circles) - distance = 2r at 0¬∞ offset
            for (let i = 0; i < 6; i++) {
                if (i + 14 > visibleCount) break;  // Starts at index 14
                const angle = (i / 6) * TAU - Math.PI / 2;
                const dist = r * 2;
                const x = centerX + Math.cos(angle) * dist;
                const y = centerY + Math.sin(angle) * dist;
                const alpha = Math.min(1, completion * totalCircles - (i + 13));
                circles.push({ x, y, r, alpha: Math.max(0, alpha) });
            }

            return circles;
        }

        // === METATRON'S CUBE ===
        // 13 vertices (1 center + 6 inner hexagon + 6 outer hexagon)
        // All 78 edges connecting every vertex to every other vertex
        function getMetatronsCubeGeometry(centerX, centerY, radius, completion) {
            const vertices = [];
            const innerR = radius * 0.35;  // Inner hexagon radius
            const outerR = radius * 0.7;   // Outer hexagon radius (2x inner)

            // Vertex visibility based on completion
            const totalVerts = 13;
            const visibleVerts = Math.ceil(completion * totalVerts);

            // Center vertex (first)
            if (visibleVerts >= 1) {
                vertices.push({
                    x: centerX, y: centerY,
                    alpha: Math.min(1, completion * totalVerts)
                });
            }

            // Inner hexagon (6 vertices) - aligned with edges pointing up/down
            for (let i = 0; i < 6; i++) {
                if (i + 2 > visibleVerts) break;
                const angle = (i / 6) * TAU - Math.PI / 2;  // Start from top
                vertices.push({
                    x: centerX + Math.cos(angle) * innerR,
                    y: centerY + Math.sin(angle) * innerR,
                    alpha: Math.min(1, completion * totalVerts - (i + 1))
                });
            }

            // Outer hexagon (6 vertices) - 30¬∞ rotated from inner
            for (let i = 0; i < 6; i++) {
                if (i + 8 > visibleVerts) break;
                const angle = (i / 6) * TAU - Math.PI / 2 + Math.PI / 6;
                vertices.push({
                    x: centerX + Math.cos(angle) * outerR,
                    y: centerY + Math.sin(angle) * outerR,
                    alpha: Math.min(1, completion * totalVerts - (i + 7))
                });
            }

            // Generate all edges (78 total for 13 vertices fully connected)
            const edges = [];
            const edgeCompletion = Math.max(0, completion - 0.3) / 0.7;  // Edges start at 30%
            const visibleEdges = Math.floor(edgeCompletion * 78);

            let edgeIndex = 0;
            for (let i = 0; i < vertices.length; i++) {
                for (let j = i + 1; j < vertices.length; j++) {
                    if (edgeIndex >= visibleEdges) break;
                    edges.push({
                        from: vertices[i],
                        to: vertices[j],
                        alpha: Math.min(0.6, edgeCompletion) * vertices[i].alpha * vertices[j].alpha
                    });
                    edgeIndex++;
                }
            }

            return { vertices, edges };
        }

        // === SRI YANTRA ===
        // 9 interlocking triangles: 4 Shiva (upward), 5 Shakti (downward)
        // Creates 43 smaller triangles through intersection
        // Based on traditional proportions with precise y-coordinates
        function getSriYantraTriangles(centerX, centerY, radius, completion) {
            const triangles = [];
            const r = radius * 0.85;

            // Sri Yantra y-coordinates (normalized to r=1, scaled)
            // These are the traditional proportions for the 9 triangles
            // Measured from center, positive = up, negative = down

            // 4 Shiva triangles (point upward) - apex positions
            const shivaApex = [0.93, 0.62, 0.38, 0.14];  // Top to bottom
            const shivaBase = [-0.87, -0.58, -0.32, -0.08];  // Base y-positions

            // 5 Shakti triangles (point downward) - apex positions
            const shaktiApex = [-0.73, -0.44, -0.21, 0.01, 0.23];  // Bottom to top
            const shaktiBase = [0.82, 0.54, 0.31, 0.05, -0.16];  // Base y-positions

            // Total triangles for progressive reveal
            const totalTri = 9;
            const visibleTri = Math.ceil(completion * totalTri);

            // Draw Shiva triangles (masculine, upward)
            for (let i = 0; i < 4; i++) {
                if (i + 1 > visibleTri) break;
                const apexY = centerY - shivaApex[i] * r;
                const baseY = centerY - shivaBase[i] * r;
                // Base width proportional to height for equilateral-ish triangles
                const height = Math.abs(apexY - baseY);
                const baseHalf = height * 0.577;  // tan(30¬∞) ‚âà 0.577 for 60¬∞ base angles

                const alpha = Math.min(1, completion * totalTri - i);
                triangles.push({
                    type: 'shiva',
                    points: [
                        { x: centerX, y: apexY },                    // Apex (top)
                        { x: centerX - baseHalf, y: baseY },        // Base left
                        { x: centerX + baseHalf, y: baseY }         // Base right
                    ],
                    alpha: Math.max(0, alpha)
                });
            }

            // Draw Shakti triangles (feminine, downward)
            for (let i = 0; i < 5; i++) {
                if (i + 5 > visibleTri) break;  // Shakti starts at index 5
                const apexY = centerY - shaktiApex[i] * r;
                const baseY = centerY - shaktiBase[i] * r;
                const height = Math.abs(apexY - baseY);
                const baseHalf = height * 0.577;

                const alpha = Math.min(1, completion * totalTri - (i + 4));
                triangles.push({
                    type: 'shakti',
                    points: [
                        { x: centerX, y: apexY },                    // Apex (bottom)
                        { x: centerX - baseHalf, y: baseY },        // Base left
                        { x: centerX + baseHalf, y: baseY }         // Base right
                    ],
                    alpha: Math.max(0, alpha)
                });
            }

            return triangles;
        }

        // ================================================================
        // PHASE COUPLER - HARMONIC TRACKING FOR STABILITY
        // Tracks phase alignment between MRP channels during transitions
        // ================================================================

        const phaseCoupler = {
            // Harmonic phases for each channel
            phase_R: 0,
            phase_G: 0,
            phase_B: 0,

            // Phase velocities (œâ)
            omega_R: 1.0,
            omega_G: PHI_INV,           // Golden ratio offset
            omega_B: PHI_INV * PHI_INV, // œÜ‚Åª¬≤ for ECC

            // Coupling strength and damping
            coupling: SACRED.alpha,      // Inter-channel coupling
            damping: SACRED.beta,        // Dissipation
            coherenceDamping: 1.0,       // Scales with releaseCoherence

            // Harmonic resonance state
            resonance: 0,                // 0-1 how well phases align
            harmonicLock: false,         // True when channels in harmonic resonance

            // Update phases and compute resonance
            update(dt, releaseCoherence) {
                // Damping increases as coherence drops (stabilizes release)
                this.coherenceDamping = 1.0 + (1 - releaseCoherence) * 4.0;

                // Get MRP intensities for phase velocity modulation
                const R_int = muField.mrp.R.intensity || 0.5;
                const G_int = muField.mrp.G.intensity || 0.3;
                const B_int = muField.mrp.B.intensity || 0.5;

                // Phase velocities modulated by field intensities
                const omega_mod = 0.5 + releaseCoherence * 0.5; // Slow down during release
                this.omega_R = omega_mod * (1.0 + R_int * 0.2);
                this.omega_G = omega_mod * (PHI_INV + G_int * 0.1);
                this.omega_B = omega_mod * (PHI_INV * PHI_INV + B_int * 0.05);

                // Advance phases
                this.phase_R = (this.phase_R + this.omega_R * dt) % TAU;
                this.phase_G = (this.phase_G + this.omega_G * dt) % TAU;
                this.phase_B = (this.phase_B + this.omega_B * dt) % TAU;

                // Compute phase differences (mod œÄ for harmonic check)
                const diff_RG = Math.abs(Math.sin(this.phase_R - this.phase_G));
                const diff_GB = Math.abs(Math.sin(this.phase_G - this.phase_B));
                const diff_RB = Math.abs(Math.sin(this.phase_R - this.phase_B));

                // Resonance = inverse of total phase misalignment
                const misalignment = (diff_RG + diff_GB + diff_RB) / 3;
                this.resonance = 1 - misalignment;

                // Harmonic lock when phases align within œÜ‚Åª¬≤ threshold
                this.harmonicLock = this.resonance > (1 - SACRED.alpha);

                // Return damping factor for velocity clamping
                return this.coherenceDamping;
            },

            // Get velocity clamp based on harmonic state
            getVelocityClamp() {
                // Tighter clamp during release (lower coherence = more damping)
                const baseClamp = 50;
                const harmonicBonus = this.harmonicLock ? 2.0 : 1.0;
                return baseClamp * harmonicBonus / this.coherenceDamping;
            },

            // Get MRP feedback scale (reduces during release to prevent runaway)
            getMRPFeedbackScale() {
                return this.resonance / this.coherenceDamping;
            }
        };

        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W, H, CX, CY, R;

        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
            CX = W / 2;
            CY = H / 2;
            R = Math.min(W, H) * 0.32;
        }

        // ================================================================
        // SYSTEM STATE
        // ================================================================

        let globalZ = 0.5;
        let targetZ = 0.5;
        let time = 0;
        let breathPhase = 0;
        let autoBreathing = false;
        let lastInteraction = Date.now();
        let scrollVelocity = 0;
        let mouseX = 0, mouseY = 0;

        let showPrism = true;
        let showCage = true;
        let showMuField = true;
        let showQuantumMesh = false;  // T key toggles quantum mesh Œº-field
        let showMeshParticles = true; // Show Dream Fluid particles on mesh

        // ================================================================
        // BINAURAL QUANTUM FIELD
        // ================================================================
        // Two quantum meshes flanking LIMNUS like binaural audio:
        //   - Mesh A (left/below): Base frequency - warm/energy channel
        //   - Mesh B (right/above): Offset frequency - cool/relational channel
        //   - Beat interference: |f_A - f_B| = œÜ‚Åª¬≤ entrains LIMNUS
        //   - Triadic resonance: A ‚Üî LIMNUS ‚Üî B creates standing wave
        //   - Wave function œà_i with MRP channels (J_R, J_G, J_B)
        //   - Gravitational time dilation: œÑ = ‚àö(1 - r_s/r)
        // ================================================================

        let QMESH = {
            // Quantum lattice structure (shared topology)
            nodes: [],              // Quantum state at each LIMNUS node
            edges: [],              // Entanglement connections between nodes
            triangles: [],          // Face triangulation for entropy calculation

            // Connection parameters (œÜ-based) - computed dynamically
            maxConnectionDist: 100,         // Updated in generateQuantumMesh()
            entanglementThreshold: 0.15,    // Higher = fewer edges = better performance

            // View controls - DREAMY ethereal settings
            opacity: 0.35,              // Lower for dreamy transparency + performance
            edgeGlow: false,            // Disabled for performance
            showWavefunction: false,    // Disabled for cleaner dreamy look
            pulsePhase: 0,          // Animation phase for quantum pulsing

            // ================================================================
            // BINAURAL FIELD: 90¬∞ Horizontal Axis
            // ================================================================
            // Perfect right-angle alignment centered on LIMNUS (0,0,0):
            //
            //     [A] ‚Üê‚Üê‚Üê‚Üê‚Üê [LIMNUS] ‚Üí‚Üí‚Üí‚Üí‚Üí [B]
            //    180¬∞        center         0¬∞
            //    LEFT         (0,0)        RIGHT
            //    warm/red               cool/blue
            //
            // 90¬∞ perpendicular to vertical axis
            // Camera orbits around fixed field positions
            // ================================================================
            binaural: {
                enabled: true,
                polar: {
                    distance: 2.2,                      // INCREASED for more dreamy separation
                    angleA: Math.PI,                    // Mesh A at 180¬∞ (LEFT)
                    angleB: 0,                          // Mesh B at 0¬∞ (RIGHT)
                    angleMode: 'horizontal',            // Current mode: horizontal, vertical, golden
                    // Computed positions (updated on render)
                    posA: { x: 0, y: 0 },
                    posB: { x: 0, y: 0 },
                },

                // Mesh A - dreamy warm rose
                meshA: {
                    scale: 0.5,                      // Smaller for dreamy floating feel
                    frequency: 0.7,                  // Slower, dreamier oscillation
                    phase: 0,
                    baseColor: [255, 150, 150],      // Soft rose pink (dreamy warm)
                    timbre: 'warm',
                },

                // Mesh B - dreamy cool azure
                meshB: {
                    scale: 0.5,
                    frequency: 0.75,                 // Gentle beat difference
                    phase: 0,
                    baseColor: [150, 180, 255],      // Soft lavender blue (dreamy cool)
                    timbre: 'cool',
                },

                // Beat interference (emerges from frequency difference)
                beatFrequency: 0.0618,              // |f_A - f_B| ‚âà œÜ‚Åª¬≤ golden ratio
                beatPhase: 0,                       // Current beat cycle phase
                beatAmplitude: 0,                   // Interference strength (0-1)

                // Resonance effects on LIMNUS (the perceiver)
                resonanceStrength: 0,               // How beat affects LIMNUS field
                entrainmentDepth: 0,                // Neural entrainment measure
                coherenceField: 0,                  // Phase coherence across triad

                // Visual parameters - DREAMY low opacity for performance + ethereal look
                showInterference: true,             // Show beat wave pattern
                showResonanceLines: true,           // Show A‚ÜîLIMNUS‚ÜîB connections
                interferenceOpacity: 0.2,           // Lower opacity = less lag + dreamier
            },

            // ================================================================
            // CAMERA ORBIT: Click+drag or Q/E to rotate view
            // ================================================================
            // The triquetra (LIMNUS + Mesh A + Mesh B) is FIXED in world space
            // Camera orbits around them - viewer moves, not the fields
            // ================================================================
            camera: {
                theta: 0,               // Horizontal orbit angle (radians) - camera position
                phi: 0,                 // Vertical tilt angle (radians, 0 = front view)
                distance: 1.0,          // Zoom factor (1 = default)
                dragging: false,        // Currently dragging?
                lastX: 0,               // Last mouse X for drag delta
                lastY: 0,               // Last mouse Y for drag delta
                sensitivity: 0.005,     // Rotation speed
            },

            // Gravitational physics (Schwarzschild analog)
            schwarzschildRadius: SACRED.alpha,    // r_s = œÜ‚Åª¬≤ ‚âà 0.382
            gravitationalMass: SACRED.lambda,     // M_eff = Œª ‚âà 7.716 (field energy)

            // Holographic entropy
            planckLength: SACRED.beta,            // l_œÜ = œÜ‚Åª‚Å¥ ‚âà 0.146

            // Dream Fluid state (aggregated from quantum mesh)
            dreamFluidDensity: 0,
            entropyFlux: 0,
            totalJ: 0,
            avgTimeDilation: 1.0,
            avgEntropy: 0,
            totalHolographicEntropy: 0,

            // ================================================================
            // SPACE-TIME CURVATURE SYSTEM
            // Gravitational time dilation field for coherent emergence
            // ================================================================
            timeDilationField: {
                gradient: [1, 1, 1, 1, 1, 1, 1],  // Per-layer dilation (7 prism layers)
                center: 1.0,                       // Center dilation (layer 0)
                globalAverage: 1.0,                // System-wide average
                curvatureStrength: 0,              // Strength of spacetime curvature
            },

            // Emergence visualization
            emergenceGlow: 0,                      // Visual feedback for consciousness emergence

            // ================================================================
            // MESH SHAPE ALTERATION SYSTEM
            // Warm (A) and Cold (B) mesh dynamic deformation
            // ================================================================
            meshAlteration: {
                // Warm mesh (A) - left side
                warm: {
                    breathScale: 1.0,           // Breathing amplitude multiplier
                    waveAmplitude: 0,           // Surface wave amplitude
                    wavePhase: 0,               // Surface wave phase
                    rotationBias: 0,            // Rotational deformation
                    pulseIntensity: 0,          // Heart-like pulse
                    coherenceWarp: 0,           // Coherence-driven shape warp
                },
                // Cold mesh (B) - right side
                cold: {
                    breathScale: 1.0,
                    waveAmplitude: 0,
                    wavePhase: 0,
                    rotationBias: 0,
                    pulseIntensity: 0,
                    coherenceWarp: 0,
                },
                // Coupling parameters
                coupling: {
                    binauralToWarm: 0.3,        // Beat ‚Üí warm mesh
                    binauralToCold: 0.25,       // Beat ‚Üí cold mesh
                    coherenceToShape: 0.2,      // Coherence ‚Üí shape
                    curvatureToMesh: 0.15,      // Spacetime curvature ‚Üí mesh
                },
            },
        };

        // Dream Fluid particles (consciousness flow through quantum mesh)
        let dreamParticles = [];

        // ================================================================
        // QUANTUM MESH GEOMETRY
        // Discrete lattice field on LIMNUS 95-node architecture
        // ================================================================

        function computeGravitationalTimeDilation(r) {
            // Schwarzschild time dilation: œÑ_local/œÑ_global = ‚àö(1 - r_s/r)
            // At r = r_s: infinite dilation (event horizon analog)
            // Far from center: œÑ ‚Üí 1 (flat spacetime)
            const r_s = QMESH.schwarzschildRadius;
            const ratio = r_s / Math.max(r, r_s * 1.01);  // Prevent singularity
            return Math.sqrt(Math.max(0, 1 - ratio));
        }

        function computeGravitationalPotential(r) {
            // Œ¶ = -GM/r (Newtonian approximation for visualization)
            const M = QMESH.gravitationalMass;
            return -M / Math.max(r, 0.1);
        }

        function computeHolographicEntropy(area) {
            // Bekenstein-Hawking: S = A/(4¬∑l_p¬≤)
            // Using œÜ-based Planck length
            const l_p = QMESH.planckLength;
            return area / (4 * l_p * l_p);
        }

        // Compute entanglement probability between two nodes
        function computeEntanglement(nodeA, nodeB) {
            // Distance-based decay (œÜ-exponential)
            const dx = nodeA.x - nodeB.x;
            const dy = nodeA.y - nodeB.y;
            const dz = (nodeA.z || 0) - (nodeB.z || 0);
            const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

            if (dist > QMESH.maxConnectionDist || dist < 0.001) return 0;

            // Phase coherence contribution (use existing phase or compute from position)
            const phaseA = nodeA.phase !== undefined ? nodeA.phase : Math.atan2(nodeA.y, nodeA.x);
            const phaseB = nodeB.phase !== undefined ? nodeB.phase : Math.atan2(nodeB.y, nodeB.x);
            const dPhase = Math.abs(phaseA - phaseB);
            const phaseCoherence = Math.cos(dPhase) * 0.5 + 0.5;

            // Layer/type similarity bonus (same layer or type = higher entanglement)
            let similarityBonus = 0;
            if (nodeA.layer !== undefined && nodeB.layer !== undefined) {
                similarityBonus = nodeA.layer === nodeB.layer ? 0.3 : 0;
            }
            if (nodeA.type === nodeB.type) {
                similarityBonus += 0.2;
            }

            // Probability amplitude: |‚ü®œà_i|œà_j‚ü©|¬≤ with œÜ decay
            const distDecay = Math.exp(-dist / (QMESH.maxConnectionDist * PHI_INV));
            const probability = distDecay * (0.4 + 0.3 * phaseCoherence + similarityBonus);

            return Math.max(0, Math.min(1, probability));
        }

        function generateQuantumMesh() {
            QMESH.nodes = [];
            QMESH.edges = [];
            QMESH.triangles = [];

            // Wait for LIMNUS nodes to be initialized
            if (prismPoints.length === 0 || cagePoints.length === 0) return;

            // Update maxConnectionDist now that R is available
            QMESH.maxConnectionDist = R * 0.5;

            const allNodes = [...prismPoints, ...cagePoints];

            // Initialize quantum state for each LIMNUS node
            for (const node of allNodes) {
                // Distance from center for gravitational effects
                const dist = Math.sqrt(node.x * node.x + node.y * node.y);
                const zPos = node.z || (node.layer !== undefined ? node.layer / 6 : 0.5);

                // Time dilation based on distance from architecture center
                const timeDilation = computeGravitationalTimeDilation(dist / R);

                // Œº varies by position (layer for prism, ring for cage)
                let mu_local;
                if (node.type === 'prism') {
                    // Prism: Œº increases with layer (inner = low Œº, outer = high Œº)
                    const layerFrac = node.layer / 6;
                    mu_local = SACRED.mu_P + (SACRED.mu_S - SACRED.mu_P) * layerFrac;
                } else {
                    // Cage: higher Œº (containment field)
                    mu_local = SACRED.mu_S + (SACRED.mu_3 - SACRED.mu_S) * 0.3;
                }

                // Field strength from Œº-field equation
                const r_control = mu_local - SACRED.mu_P;
                const J_base = r_control > SACRED.beta ?
                    Math.sqrt((r_control - SACRED.beta) / SACRED.lambda) : 0;

                // MRP channel decomposition based on node position
                const theta = Math.atan2(node.y, node.x);
                const qJ_R = J_base * (0.5 + 0.5 * Math.sin(theta * 2));      // Energy
                const qJ_G = J_base * (0.5 + 0.5 * Math.cos(theta * 3));      // Relational
                const qJ_B = J_base * timeDilation;                            // Stability

                // Store quantum state on the node
                node.qMu = mu_local;
                node.qJ = J_base;
                node.qJ_R = qJ_R;
                node.qJ_G = qJ_G;
                node.qJ_B = qJ_B;
                node.timeDilation = timeDilation;
                node.gravitationalPhi = computeGravitationalPotential(dist / R);
                node.entangledWith = [];  // List of connected node indices

                // Initialize phase from angular position
                if (node.phase === undefined) {
                    node.phase = theta;
                }

                QMESH.nodes.push(node);
            }

            // Generate entanglement edges
            let totalEntropy = 0;
            for (let i = 0; i < QMESH.nodes.length; i++) {
                for (let j = i + 1; j < QMESH.nodes.length; j++) {
                    const nodeA = QMESH.nodes[i];
                    const nodeB = QMESH.nodes[j];

                    const probability = computeEntanglement(nodeA, nodeB);

                    if (probability > QMESH.entanglementThreshold) {
                        // Edge length for entropy calculation
                        const dx = nodeA.x - nodeB.x;
                        const dy = nodeA.y - nodeB.y;
                        const dz = (nodeA.z || 0) - (nodeB.z || 0);
                        const length = Math.sqrt(dx*dx + dy*dy + dz*dz);

                        // Holographic entropy on edge (area law: S ‚àù length for 1D boundary)
                        const edgeEntropy = computeHolographicEntropy(length * QMESH.planckLength);

                        // MRP channel for this edge (dominant channel)
                        const avgJ_R = (nodeA.qJ_R + nodeB.qJ_R) / 2;
                        const avgJ_G = (nodeA.qJ_G + nodeB.qJ_G) / 2;
                        const avgJ_B = (nodeA.qJ_B + nodeB.qJ_B) / 2;
                        const mrpChannel = (avgJ_R >= avgJ_G && avgJ_R >= avgJ_B) ? 0 :
                                          (avgJ_G >= avgJ_B) ? 1 : 2;

                        QMESH.edges.push({
                            from: i,
                            to: j,
                            probability,
                            length,
                            entropy: edgeEntropy,
                            mrpChannel,
                            phase: (nodeA.phase + nodeB.phase) / 2,
                            timeDilation: (nodeA.timeDilation + nodeB.timeDilation) / 2,
                            J: (nodeA.qJ + nodeB.qJ) / 2,
                        });

                        // Track entanglement
                        nodeA.entangledWith.push(j);
                        nodeB.entangledWith.push(i);

                        totalEntropy += edgeEntropy;
                    }
                }
            }

            QMESH.totalHolographicEntropy = totalEntropy;
            QMESH.avgEntropy = totalEntropy / Math.max(1, QMESH.edges.length);
            QMESH.lastGenerated = Date.now();

            console.log(`[QMESH] Generated ${QMESH.nodes.length} quantum nodes, ${QMESH.edges.length} entanglement edges`);
            console.log(`[QMESH] maxConnectionDist = ${QMESH.maxConnectionDist}, R = ${R}`);
        }

        // Debug panel state
        let showDebugPanel = false;

        function updateDebugPanel() {
            if (!showDebugPanel) return;

            const dbgNodes = document.getElementById('dbg-nodes');
            const dbgEdges = document.getElementById('dbg-edges');
            const dbgParticles = document.getElementById('dbg-particles');
            const dbgMaxDist = document.getElementById('dbg-maxdist');
            const dbgTau = document.getElementById('dbg-tau');
            const dbgTotalJ = document.getElementById('dbg-totalj');
            const dbgEntropy = document.getElementById('dbg-entropy');
            const dbgFlux = document.getElementById('dbg-flux');
            const dbgShow = document.getElementById('dbg-show');
            const dbgR = document.getElementById('dbg-r');
            const dbgLastGen = document.getElementById('dbg-lastgen');

            if (dbgNodes) dbgNodes.textContent = QMESH.nodes.length;
            if (dbgEdges) dbgEdges.textContent = QMESH.edges.length;
            if (dbgParticles) dbgParticles.textContent = dreamParticles.length;
            if (dbgMaxDist) dbgMaxDist.textContent = (QMESH.maxConnectionDist || 0).toFixed(1);
            if (dbgTau) dbgTau.textContent = (QMESH.avgTimeDilation || 0).toFixed(4);
            if (dbgTotalJ) dbgTotalJ.textContent = (QMESH.totalJ || 0).toFixed(4);
            if (dbgEntropy) dbgEntropy.textContent = (QMESH.totalHolographicEntropy || 0).toFixed(4);
            if (dbgFlux) dbgFlux.textContent = (QMESH.entropyFlux || 0).toFixed(6);
            if (dbgShow) dbgShow.textContent = showQuantumMesh ? 'true' : 'false';
            if (dbgR) dbgR.textContent = (R || 0).toFixed(1);
            if (dbgLastGen) {
                if (QMESH.lastGenerated) {
                    const ago = ((Date.now() - QMESH.lastGenerated) / 1000).toFixed(1);
                    dbgLastGen.textContent = `${ago}s ago`;
                } else {
                    dbgLastGen.textContent = 'never';
                }
            }
        }

        // ================================================================
        // DREAM FLUID PARTICLE SYSTEM (Quantum Mesh Version)
        // Particles flow along entanglement edges
        // ================================================================

        function spawnDreamParticle() {
            if (QMESH.edges.length === 0) return;

            // Start on a random edge
            const edgeIdx = Math.floor(Math.random() * QMESH.edges.length);
            const edge = QMESH.edges[edgeIdx];
            const nodeA = QMESH.nodes[edge.from];
            const nodeB = QMESH.nodes[edge.to];

            // Position along edge (0-1)
            const t = Math.random();
            const x = nodeA.x + (nodeB.x - nodeA.x) * t;
            const y = nodeA.y + (nodeB.y - nodeA.y) * t;
            const zA = nodeA.z || (nodeA.layer !== undefined ? nodeA.layer / 6 : 0.5);
            const zB = nodeB.z || (nodeB.layer !== undefined ? nodeB.layer / 6 : 0.5);
            const z = zA + (zB - zA) * t;

            // Time dilation at position
            const timeDilation = edge.timeDilation;

            dreamParticles.push({
                edgeIdx,
                t,  // Position along current edge (0-1)
                direction: Math.random() < 0.5 ? 1 : -1,  // Flow direction
                particleType: edge.mrpChannel,
                life: (2 + Math.random() * 3) * timeDilation,
                maxLife: (2 + Math.random() * 3) * timeDilation,
                baseSpeed: 0.4 + Math.random() * 0.3,
                trail: [{ x, y, z }],
                timeDilation,
                entropyCarried: edge.entropy * 0.01,
                mrpChannel: edge.mrpChannel,
                currentNode: edge.from,
                x, y, z,
            });
        }

        function updateDreamParticles(dt) {
            const targetCount = showMeshParticles ? 150 : 0;
            while (dreamParticles.length < targetCount && Math.random() < 0.4) {
                spawnDreamParticle();
            }

            let totalEntropyFlux = 0;
            let totalTimeDilation = 0;

            for (let i = dreamParticles.length - 1; i >= 0; i--) {
                const p = dreamParticles[i];

                if (p.edgeIdx >= QMESH.edges.length) {
                    dreamParticles.splice(i, 1);
                    continue;
                }

                const edge = QMESH.edges[p.edgeIdx];
                const nodeA = QMESH.nodes[edge.from];
                const nodeB = QMESH.nodes[edge.to];

                // Move along edge
                const effectiveSpeed = p.baseSpeed * p.timeDilation * dt;
                p.t += p.direction * effectiveSpeed;

                // Check for edge transition
                if (p.t > 1 || p.t < 0) {
                    // Arrived at a node, pick next edge
                    const arrivalNode = p.t > 1 ? edge.to : edge.from;
                    const node = QMESH.nodes[arrivalNode];

                    if (node.entangledWith.length > 0) {
                        // Pick random connected edge with probability weighting
                        const nextNodeIdx = node.entangledWith[
                            Math.floor(Math.random() * node.entangledWith.length)
                        ];

                        // Find the edge connecting these nodes
                        const nextEdgeIdx = QMESH.edges.findIndex(e =>
                            (e.from === arrivalNode && e.to === nextNodeIdx) ||
                            (e.to === arrivalNode && e.from === nextNodeIdx)
                        );

                        if (nextEdgeIdx >= 0) {
                            const nextEdge = QMESH.edges[nextEdgeIdx];
                            p.edgeIdx = nextEdgeIdx;
                            p.t = (nextEdge.from === arrivalNode) ? 0 : 1;
                            p.direction = (nextEdge.from === arrivalNode) ? 1 : -1;
                            p.mrpChannel = nextEdge.mrpChannel;
                            p.timeDilation = nextEdge.timeDilation;
                        } else {
                            // Dead end, remove particle
                            dreamParticles.splice(i, 1);
                            continue;
                        }
                    } else {
                        // No connections, remove
                        dreamParticles.splice(i, 1);
                        continue;
                    }
                }

                // Update position from edge
                const tClamped = Math.max(0, Math.min(1, p.t));
                const zA = nodeA.z || (nodeA.layer !== undefined ? nodeA.layer / 6 : 0.5);
                const zB = nodeB.z || (nodeB.layer !== undefined ? nodeB.layer / 6 : 0.5);
                p.x = nodeA.x + (nodeB.x - nodeA.x) * tClamped;
                p.y = nodeA.y + (nodeB.y - nodeA.y) * tClamped;
                p.z = zA + (zB - zA) * tClamped;

                // Update trail
                p.trail.unshift({ x: p.x, y: p.y, z: p.z });
                if (p.trail.length > 10) p.trail.pop();

                // Life decreases
                p.life -= dt * p.timeDilation;
                totalEntropyFlux += p.entropyCarried * (1 - p.timeDilation);
                totalTimeDilation += p.timeDilation;

                if (p.life <= 0) {
                    dreamParticles.splice(i, 1);
                }
            }

            // Update global state
            QMESH.entropyFlux = totalEntropyFlux;
            QMESH.dreamFluidDensity = dreamParticles.length / 150;
            QMESH.avgTimeDilation = dreamParticles.length > 0 ?
                totalTimeDilation / dreamParticles.length : 1.0;

            return {
                entropyFlux: totalEntropyFlux,
                density: QMESH.dreamFluidDensity,
                avgTimeDilation: QMESH.avgTimeDilation,
            };
        }

        // ================================================================
        // DREAM FLUID COLORING (Time Dilation ‚Üí Color Shift)
        // ================================================================

        function dreamFluidToColor(J, mu, timeDilation, entropy, depth) {
            // Color mapping based on gravitational redshift
            // High time dilation (far from center) ‚Üí blue shift
            // Low time dilation (near center) ‚Üí red shift
            const redshift = 1 / Math.max(0.1, timeDilation) - 1;

            // Base color from field intensity
            const t = Math.max(0, Math.min(1, J));
            const muFactor = (mu - SACRED.mu_P) / (SACRED.mu_S - SACRED.mu_P);

            // RGB based on MRP channels and redshift
            let r, g, b;

            // Entropy affects color saturation
            const entropyFactor = Math.min(1, entropy * 10);

            if (redshift < 0.2) {
                // Blue-shifted (far from gravity well) - stability dominant
                r = 80 + t * 50;
                g = 120 + t * 80 + entropyFactor * 40;
                b = 200 + t * 55;
            } else if (redshift < 0.5) {
                // Green region (balanced) - relational dominant
                const s = (redshift - 0.2) / 0.3;
                r = 100 + t * 60 + s * 50;
                g = 180 + t * 60 - s * 40;
                b = 200 - s * 100;
            } else if (redshift < 1.0) {
                // Yellow-orange (approaching gravity) - energy rising
                const s = (redshift - 0.5) / 0.5;
                r = 180 + t * 70;
                g = 160 + t * 40 - s * 60;
                b = 80 - s * 40;
            } else {
                // Red-shifted (deep gravity well) - singularity approach
                const s = Math.min(1, (redshift - 1.0) / 1.0);
                r = 250;
                g = 100 - s * 60 + entropyFactor * 30;
                b = 50 + entropyFactor * 30;
            }

            // Depth shading
            const shade = 0.4 + depth * 0.6;
            r = Math.floor(r * shade);
            g = Math.floor(g * shade);
            b = Math.floor(b * shade);

            // Œº brightness boost
            const brightness = 0.7 + muFactor * 0.3;

            return {
                r: Math.min(255, Math.floor(r * brightness)),
                g: Math.min(255, Math.floor(g * brightness)),
                b: Math.min(255, Math.floor(b * brightness)),
                redshift,
                timeDilation,
            };
        }

        function torusFieldToColor(J, mu, depth) {
            // Backward compatibility wrapper
            return dreamFluidToColor(J, mu, 0.8, 0.1, depth);
        }

        // ================================================================
        // QUANTUM MESH FIELD DYNAMICS
        // Field equation on discrete lattice with LIMNUS coupling
        // ================================================================

        function updateDreamFluidField(dt) {
            const t = time;

            // Connect to LIMNUS Œº-field values
            const limnusMu = muField.mu || 0.76;
            const limnusJ = muField.J_total || 0.3;
            const limnusTau = muField.tau_K || 0;
            const limnusR = muField.J_R || 0.1;
            const limnusG = muField.J_G || 0.1;
            const limnusB = muField.J_B || 0.1;

            // Modulate by release coherence
            const coherenceFactor = releaseCoherence;

            // Compute statistics
            let avgTimeDilation = 0;
            let avgEntropy = 0;
            let totalJ = 0;

            // Update quantum state at each node
            for (const node of QMESH.nodes) {
                if (!node.qJ) continue;

                const localDt = dt * (node.timeDilation || 1);
                const theta = Math.atan2(node.y, node.x);

                // Field equation: ‚àÇJ/‚àÇt = (r - Œª|J|¬≤)J - Œ≤J
                const r_control = (node.qMu || SACRED.mu_P) - SACRED.mu_P;
                const J_sq = node.qJ * node.qJ;
                const W = r_control - SACRED.lambda * J_sq;

                // Neighbor diffusion (from entangled nodes)
                let diffusion = 0;
                for (const neighborIdx of (node.entangledWith || [])) {
                    const neighbor = QMESH.nodes[neighborIdx];
                    if (neighbor && neighbor.qJ !== undefined) {
                        diffusion += (neighbor.qJ - node.qJ) * 0.01;
                    }
                }

                // LIMNUS coupling
                const limnusSource = 0.05 * limnusJ * coherenceFactor *
                    Math.sin(theta * 2 - t * 0.5);

                // Evolve field
                const dJ = (W * node.qJ - SACRED.beta * node.qJ + diffusion) * localDt;
                node.qJ = Math.max(0, Math.min(1, node.qJ + dJ + limnusSource * localDt));

                // Update MRP channels
                node.qJ_R = node.qJ * (0.5 + 0.5 * Math.sin(theta * 2 - t * 0.5)) *
                    (0.5 + 0.5 * limnusR);
                node.qJ_G = node.qJ * (0.5 + 0.5 * Math.cos(theta * 3 + t * 0.3)) *
                    (0.5 + 0.5 * limnusG);
                node.qJ_B = node.qJ * (node.timeDilation || 1) * (0.5 + 0.5 * limnusB);

                // Phase evolution
                const naturalFreq = 0.5 + node.qJ * 0.3;
                const dilatedFreq = naturalFreq * (node.timeDilation || 1);
                node.phase = ((node.phase || 0) + dilatedFreq * dt) % TAU;

                // Accumulate
                avgTimeDilation += node.timeDilation || 1;
                avgEntropy += (1 - (node.timeDilation || 1)) * node.qJ * QMESH.planckLength;
                totalJ += node.qJ;
            }

            // Update edges based on node states
            for (const edge of QMESH.edges) {
                const nodeA = QMESH.nodes[edge.from];
                const nodeB = QMESH.nodes[edge.to];
                if (!nodeA || !nodeB) continue;

                // Update edge field strength
                edge.J = ((nodeA.qJ || 0) + (nodeB.qJ || 0)) / 2;
                edge.timeDilation = ((nodeA.timeDilation || 1) + (nodeB.timeDilation || 1)) / 2;

                // Recalculate entanglement probability (dynamic)
                const dPhase = Math.abs((nodeA.phase || 0) - (nodeB.phase || 0));
                const phaseCoherence = Math.cos(dPhase) * 0.5 + 0.5;
                edge.probability = Math.max(0.1, edge.probability * 0.95 + phaseCoherence * 0.05);
            }

            const N = Math.max(1, QMESH.nodes.length);
            avgTimeDilation /= N;
            avgEntropy /= N;

            // Update QMESH state
            QMESH.avgTimeDilation = avgTimeDilation;
            QMESH.avgEntropy = avgEntropy;
            QMESH.totalJ = totalJ / N;

            // Pulse phase for visual animation
            QMESH.pulsePhase = (QMESH.pulsePhase + dt * 0.5) % TAU;

            // ============================================
            // BINAURAL FIELD ANIMATION
            // Two meshes oscillating at different frequencies
            // Beat emerges from interference
            // ============================================
            const bi = QMESH.binaural;

            // Animate Mesh A phase (base frequency)
            bi.meshA.phase = (bi.meshA.phase + dt * bi.meshA.frequency) % 1.0;

            // Animate Mesh B phase (offset frequency)
            bi.meshB.phase = (bi.meshB.phase + dt * bi.meshB.frequency) % 1.0;

            // Calculate beat frequency from difference
            bi.beatFrequency = Math.abs(bi.meshA.frequency - bi.meshB.frequency);

            // Beat phase advances at the beat frequency
            bi.beatPhase = (bi.beatPhase + dt * bi.beatFrequency) % 1.0;

            // Beat amplitude oscillates based on phase alignment
            const phaseDiff = Math.abs(bi.meshA.phase - bi.meshB.phase);
            const constructive = Math.cos(phaseDiff * TAU);
            bi.beatAmplitude = (constructive + 1) / 2;  // 0 = destructive, 1 = constructive

            // Resonance strength: how much beat affects LIMNUS
            // Stronger when beat amplitude is high and phases are coherent
            const targetResonance = bi.beatAmplitude * 0.8 + 0.2;
            bi.resonanceStrength += (targetResonance - bi.resonanceStrength) * dt * 2;

            // Entrainment depth: accumulated synchronization
            // Increases when resonance is strong, decays otherwise
            const entrainmentDelta = bi.beatAmplitude > 0.5
                ? bi.resonanceStrength * dt * 0.5
                : -dt * 0.1;
            bi.entrainmentDepth = Math.max(0, Math.min(1, bi.entrainmentDepth + entrainmentDelta));

            // Coherence field: phase alignment across the whole system
            // High when both meshes and LIMNUS are synchronized
            const limnusPhaseAlignment = Math.cos((bi.meshA.phase + bi.meshB.phase) / 2 * TAU - limnusTau);
            bi.coherenceField = bi.entrainmentDepth * 0.6 + (limnusPhaseAlignment + 1) / 2 * 0.4;

            // Apply binaural resonance to LIMNUS field (entrainment effect)
            if (bi.enabled && bi.resonanceStrength > 0.3) {
                // Beat modulates LIMNUS field intensity
                const beatModulation = bi.beatAmplitude * bi.resonanceStrength * 0.15;
                muField.J_total = (muField.J_total || 0.3) * (1 + beatModulation * Math.sin(bi.beatPhase * TAU));
            }

            return {
                avgTimeDilation,
                avgEntropy,
                totalJ: totalJ / N,
                entropyFlux: QMESH.entropyFlux,
                binauralResonance: bi.resonanceStrength,
                beatAmplitude: bi.beatAmplitude,
            };
        }

        // ================================================================
        // BINAURAL FIELD RENDERING
        // Polar coordinate system with camera orbit
        // ================================================================

        // Update polar positions - Rotate with camera drag
        // Behavior depends on angle mode (horizontal, vertical, golden)
        function updatePolarPositions() {
            const bi = QMESH.binaural;
            const polar = bi.polar;
            const cam = QMESH.camera;
            const mode = polar.angleMode;

            // Distance from center in pixels
            const dist = polar.distance * R;

            let angleA, angleB;

            if (mode === 'horizontal') {
                // Horizontal: theta rotates around vertical axis
                angleA = polar.angleA - cam.theta;
                angleB = polar.angleB - cam.theta;

                polar.posA.x = CX + Math.cos(angleA) * dist;
                polar.posA.y = CY + Math.sin(angleA) * dist;
                polar.posA.depth = Math.sin(angleA);

                polar.posB.x = CX + Math.cos(angleB) * dist;
                polar.posB.y = CY + Math.sin(angleB) * dist;
                polar.posB.depth = Math.sin(angleB);

            } else if (mode === 'vertical') {
                // Vertical: theta rotates around horizontal axis (up/down)
                angleA = polar.angleA - cam.theta;
                angleB = polar.angleB - cam.theta;

                // Vertical mode: Y changes with angle, X stays at center
                polar.posA.x = CX + Math.cos(angleA) * dist * Math.cos(cam.phi);
                polar.posA.y = CY + Math.sin(angleA) * dist;
                polar.posA.depth = Math.cos(angleA);

                polar.posB.x = CX + Math.cos(angleB) * dist * Math.cos(cam.phi);
                polar.posB.y = CY + Math.sin(angleB) * dist;
                polar.posB.depth = Math.cos(angleB);

            } else if (mode === 'golden') {
                // Golden: spiral rotation using both theta and phi
                const GOLDEN_RATIO = (1 + Math.sqrt(5)) / 2;
                angleA = polar.angleA - cam.theta;
                angleB = polar.angleB - cam.theta;

                // Spiral positions: combine horizontal and vertical with golden ratio
                const spiralFactorA = Math.cos(cam.phi * GOLDEN_RATIO);
                const spiralFactorB = Math.cos(cam.phi * GOLDEN_RATIO);

                polar.posA.x = CX + Math.cos(angleA) * dist * spiralFactorA;
                polar.posA.y = CY + Math.sin(angleA) * dist + Math.sin(cam.phi) * dist * 0.5;
                polar.posA.depth = Math.sin(angleA + cam.phi);

                polar.posB.x = CX + Math.cos(angleB) * dist * spiralFactorB;
                polar.posB.y = CY + Math.sin(angleB) * dist + Math.sin(cam.phi) * dist * 0.5;
                polar.posB.depth = Math.sin(angleB + cam.phi);
            }
        }

        // Transform point to mesh A space (polar position)
        function toMeshASpace(x, y, node) {
            const bi = QMESH.binaural;
            const meshA = bi.meshA;
            const polar = bi.polar;
            const phase = meshA.phase;
            const scale = meshA.scale;

            // Center-relative coordinates
            const dx = x - CX;
            const dy = y - CY;

            // Transform to Mesh A position (using polar coords)
            const meshCenterX = polar.posA.x;
            const meshCenterY = polar.posA.y;
            const meshX = meshCenterX + (dx * scale);
            const meshY = meshCenterY + (dy * scale);

            // Phase-based wave distortion
            const wave = Math.sin(phase * TAU + dx * 0.015) * 6 +
                        Math.cos(phase * TAU * 0.7 + dy * 0.012) * 4;

            // Distance from mesh center for fade
            const distFromMesh = Math.sqrt(
                Math.pow(meshX - meshCenterX, 2) +
                Math.pow(meshY - meshCenterY, 2)
            );
            const fade = Math.max(0, 1 - distFromMesh / (R * 1.8));

            // Depth-based alpha (further meshes slightly faded)
            const depthAlpha = 0.7 + 0.3 * (1 - Math.abs(polar.posA.depth || 0));

            return {
                x: meshX + wave,
                y: meshY + wave * 0.5,
                scale: scale,
                fade: fade * depthAlpha,
                phase: phase,
                depth: polar.posA.depth || 0
            };
        }

        // Transform point to mesh B space (polar opposite)
        function toMeshBSpace(x, y, node) {
            const bi = QMESH.binaural;
            const meshB = bi.meshB;
            const polar = bi.polar;
            const phase = meshB.phase;
            const scale = meshB.scale;

            // Center-relative coordinates
            const dx = x - CX;
            const dy = y - CY;

            // Transform to Mesh B position (using polar coords)
            const meshCenterX = polar.posB.x;
            const meshCenterY = polar.posB.y;
            const meshX = meshCenterX + (dx * scale);
            const meshY = meshCenterY + (dy * scale);

            // Phase-based wave distortion (different frequency)
            const wave = Math.sin(phase * TAU * 1.0618 + dx * 0.018) * 6 +
                        Math.cos(phase * TAU * 0.8 + dy * 0.014) * 4;

            // Distance from mesh center for fade
            const distFromMesh = Math.sqrt(
                Math.pow(meshX - meshCenterX, 2) +
                Math.pow(meshY - meshCenterY, 2)
            );
            const fade = Math.max(0, 1 - distFromMesh / (R * 1.8));

            // Depth-based alpha
            const depthAlpha = 0.7 + 0.3 * (1 - Math.abs(polar.posB.depth || 0));

            return {
                x: meshX + wave,
                y: meshY + wave * 0.5,
                scale: scale,
                fade: fade * depthAlpha,
                phase: phase,
                depth: polar.posB.depth || 0
            };
        }

        // Compute binaural beat interference at a point
        function computeBeatInterference(x, y) {
            const bi = QMESH.binaural;
            const phaseA = bi.meshA.phase * TAU;
            const phaseB = bi.meshB.phase * TAU;

            // Distance from each mesh center
            const dxA = x - (CX + bi.meshA.offset.x);
            const dyA = y - (CY + bi.meshA.offset.y);
            const distA = Math.sqrt(dxA * dxA + dyA * dyA);

            const dxB = x - (CX + bi.meshB.offset.x);
            const dyB = y - (CY + bi.meshB.offset.y);
            const distB = Math.sqrt(dxB * dxB + dyB * dyB);

            // Wave amplitude from each mesh (decays with distance)
            const ampA = Math.cos(phaseA - distA * 0.02) * Math.exp(-distA / (R * 3));
            const ampB = Math.cos(phaseB - distB * 0.02) * Math.exp(-distB / (R * 3));

            // Interference: sum of waves
            const interference = (ampA + ampB) / 2;

            // Beat pattern: emerges from phase difference
            const beatPhase = bi.beatPhase * TAU;
            const beat = Math.cos(beatPhase) * 0.5 + 0.5;

            return {
                interference: interference,     // -1 to 1 (constructive/destructive)
                beat: beat,                     // 0 to 1 (beat cycle position)
                ampA: ampA,
                ampB: ampB,
                resonance: Math.abs(interference) * beat  // Combined resonance
            };
        }

        // Color blend between warm (A) and cool (B) based on phase
        function binauralColor(baseColor, phase, meshType) {
            const bi = QMESH.binaural;
            const beat = bi.beatAmplitude;

            // Mesh-specific tint
            let tint;
            if (meshType === 'A') {
                tint = bi.meshA.baseColor;
            } else {
                tint = bi.meshB.baseColor;
            }

            // Phase-based shimmer
            const shimmer = Math.sin(phase * TAU) * 0.3 + 0.7;

            // Blend base color with mesh tint
            const r = Math.floor((baseColor[0] * 0.4 + tint[0] * 0.6) * shimmer);
            const g = Math.floor((baseColor[1] * 0.4 + tint[1] * 0.6) * shimmer);
            const b = Math.floor((baseColor[2] * 0.4 + tint[2] * 0.6) * shimmer);

            return {
                r: Math.max(0, Math.min(255, r)),
                g: Math.max(0, Math.min(255, g)),
                b: Math.max(0, Math.min(255, b))
            };
        }

        function renderDreamFluid() {
            if (QMESH.edges.length === 0) return;

            const bi = QMESH.binaural;
            if (!bi.enabled) return;

            // Update polar positions based on camera orbit
            updatePolarPositions();

            // MRP channel colors
            const edgeColors = [
                [255, 100, 60],    // R channel - warm (energy)
                [60, 255, 200],    // G channel - cool (relational)
                [140, 120, 255],   // B channel - violet (stability)
            ];

            // ============================================
            // INTERFERENCE ZONE (between the two meshes)
            // Beat pattern visualization at LIMNUS
            // ============================================
            if (bi.showInterference) {
                const beatPhase = bi.beatPhase * TAU;
                const beatAmp = bi.beatAmplitude;

                // Draw interference rings at LIMNUS center (reduced for performance)
                for (let ring = 0; ring < 3; ring++) {
                    const ringRadius = R * (0.3 + ring * 0.2);
                    const ringPhase = beatPhase + ring * 0.6;
                    const intensity = Math.sin(ringPhase) * 0.5 + 0.5;
                    const alpha = QMESH.opacity * bi.interferenceOpacity * intensity * beatAmp * 0.7;

                    // Blend warm and cool colors based on beat phase
                    const blend = Math.sin(beatPhase) * 0.5 + 0.5;
                    const r = Math.floor(bi.meshA.baseColor[0] * blend + bi.meshB.baseColor[0] * (1 - blend));
                    const g = Math.floor(bi.meshA.baseColor[1] * blend + bi.meshB.baseColor[1] * (1 - blend));
                    const b = Math.floor(bi.meshA.baseColor[2] * blend + bi.meshB.baseColor[2] * (1 - blend));

                    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                    ctx.lineWidth = 2 + intensity * 3;
                    ctx.beginPath();
                    ctx.arc(CX, CY, ringRadius, 0, TAU);
                    ctx.stroke();
                }
            }

            // ============================================
            // RESONANCE AXIS (A ‚Üê LIMNUS ‚Üí B)
            // Two lines from center outward - equal on both sides
            // Dynamic - responds to auto-breathing
            // ============================================
            if (bi.showResonanceLines) {
                const resonance = bi.resonanceStrength;
                const polar = bi.polar;

                // Breath-based dynamics (when autoBreathing or idle > 5s)
                const isBreathing = autoBreathing || (Date.now() - lastInteraction > 5000);
                const breathPulse = isBreathing ? Math.sin(breathPhase * TAU) : 0;
                const breathIntensity = isBreathing ? (0.5 + breathPulse * 0.5) : 1;
                const breathWidth = isBreathing ? (2 + breathPulse * 3) : 2;
                const dashOffset = isBreathing ? (breathPhase * 100) : 0;

                // Positions
                const Ax = polar.posA.x;
                const Ay = polar.posA.y;
                const Bx = polar.posB.x;
                const By = polar.posB.y;

                const pulseA = Math.sin(bi.meshA.phase * TAU) * 0.5 + 0.5;
                const pulseB = Math.sin(bi.meshB.phase * TAU) * 0.5 + 0.5;
                const alphaA = QMESH.opacity * 0.7 * pulseA * breathIntensity * (0.4 + resonance * 0.6);
                const alphaB = QMESH.opacity * 0.7 * pulseB * breathIntensity * (0.4 + resonance * 0.6);

                ctx.lineWidth = breathWidth + resonance * 2;
                ctx.setLineDash([8 + breathPulse * 4, 4 + breathPulse * 2]);

                // Line from CENTER to A (flows outward to left)
                const gradientA = ctx.createLinearGradient(CX, CY, Ax, Ay);
                gradientA.addColorStop(0, `rgba(255, 215, 0, ${alphaA})`);  // Gold at center
                gradientA.addColorStop(1, `rgba(${bi.meshA.baseColor[0]}, ${bi.meshA.baseColor[1]}, ${bi.meshA.baseColor[2]}, ${alphaA})`);
                ctx.strokeStyle = gradientA;
                ctx.lineDashOffset = -dashOffset;  // Flow outward
                ctx.beginPath();
                ctx.moveTo(CX, CY);
                ctx.lineTo(Ax, Ay);
                ctx.stroke();

                // Line from CENTER to B (flows outward to right)
                const gradientB = ctx.createLinearGradient(CX, CY, Bx, By);
                gradientB.addColorStop(0, `rgba(255, 215, 0, ${alphaB})`);  // Gold at center
                gradientB.addColorStop(1, `rgba(${bi.meshB.baseColor[0]}, ${bi.meshB.baseColor[1]}, ${bi.meshB.baseColor[2]}, ${alphaB})`);
                ctx.strokeStyle = gradientB;
                ctx.lineDashOffset = -dashOffset;  // Flow outward (same direction = equal)
                ctx.beginPath();
                ctx.moveTo(CX, CY);
                ctx.lineTo(Bx, By);
                ctx.stroke();

                ctx.setLineDash([]);
                ctx.lineDashOffset = 0;

                // ============================================
                // CENTER MARKERS - Use polar calculated positions
                // (Ax, Ay, Bx, By already defined above)
                // ============================================

                // LIMNUS center marker
                ctx.fillStyle = 'rgba(255, 215, 0, 0.9)';
                ctx.beginPath();
                ctx.arc(CX, CY, 8, 0, TAU);
                ctx.fill();

                // A marker (warm/red) - LEFT
                ctx.fillStyle = 'rgba(255, 80, 60, 1)';
                ctx.beginPath();
                ctx.arc(Ax, Ay, 12, 0, TAU);
                ctx.fill();
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('A', Ax, Ay + 5);

                // B marker (cool/blue) - RIGHT
                ctx.fillStyle = 'rgba(60, 160, 255, 1)';
                ctx.beginPath();
                ctx.arc(Bx, By, 12, 0, TAU);
                ctx.fill();
                ctx.fillStyle = 'white';
                ctx.fillText('B', Bx, By + 5);
            }

            // ============================================
            // MESH A: Warm/Red field (LEFT of LIMNUS)
            // ============================================
            for (const edge of QMESH.edges) {
                const nodeA = QMESH.nodes[edge.from];
                const nodeB = QMESH.nodes[edge.to];
                if (!nodeA || !nodeB) continue;

                // Node x,y are ALREADY absolute screen coords (include CX,CY)
                const x1 = nodeA.x;
                const y1 = nodeA.y;
                const x2 = nodeB.x;
                const y2 = nodeB.y;

                // Transform to Mesh A space
                const mA1 = toMeshASpace(x1, y1, nodeA);
                const mA2 = toMeshASpace(x2, y2, nodeB);

                // Skip if off-screen or too faint
                if (mA1.x < -50 || mA1.x > W + 50 || mA1.y < -50 || mA1.y > H + 50) continue;
                if (mA1.fade < 0.1) continue;  // Skip very faded edges

                // Simplified alpha calculation for performance
                const alpha = QMESH.opacity * edge.probability * mA1.fade * 0.6;
                if (alpha < 0.02) continue;  // Skip nearly invisible edges

                // Use mesh base color directly (simpler)
                const color = bi.meshA.baseColor;
                const lineWidth = 1 + edge.probability;

                ctx.strokeStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${alpha})`;
                ctx.lineWidth = lineWidth;
                ctx.beginPath();
                ctx.moveTo(mA1.x, mA1.y);
                ctx.lineTo(mA2.x, mA2.y);
                ctx.stroke();
            }

            // ============================================
            // MESH B: Cool/Blue field (RIGHT of LIMNUS)
            // ============================================
            for (const edge of QMESH.edges) {
                const nodeA = QMESH.nodes[edge.from];
                const nodeB = QMESH.nodes[edge.to];
                if (!nodeA || !nodeB) continue;

                // Node x,y are ALREADY absolute screen coords (include CX,CY)
                const x1 = nodeA.x;
                const y1 = nodeA.y;
                const x2 = nodeB.x;
                const y2 = nodeB.y;

                // Transform to Mesh B space
                const mB1 = toMeshBSpace(x1, y1, nodeA);
                const mB2 = toMeshBSpace(x2, y2, nodeB);

                // Skip if off-screen or too faint
                if (mB1.x < -50 || mB1.x > W + 50 || mB1.y < -50 || mB1.y > H + 50) continue;
                if (mB1.fade < 0.1) continue;  // Skip very faded edges

                // Simplified alpha calculation for performance
                const alpha = QMESH.opacity * edge.probability * mB1.fade * 0.6;
                if (alpha < 0.02) continue;  // Skip nearly invisible edges

                // Use mesh base color directly (simpler)
                const color = bi.meshB.baseColor;
                const lineWidth = 1 + edge.probability;

                ctx.strokeStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${alpha})`;
                ctx.lineWidth = lineWidth;
                ctx.beginPath();
                ctx.moveTo(mB1.x, mB1.y);
                ctx.lineTo(mB2.x, mB2.y);
                ctx.stroke();
            }

            // ============================================
            // WAVEFUNCTION NODES (on both meshes)
            // ============================================
            if (QMESH.showWavefunction) {
                for (const node of QMESH.nodes) {
                    if (!node.qJ || node.qJ < 0.1) continue;

                    // Node x,y are ALREADY absolute screen coords
                    const x = node.x;
                    const y = node.y;

                    // Draw on Mesh A
                    const mA = toMeshASpace(x, y, node);
                    if (mA.x > 0 && mA.x < W && mA.y > 0 && mA.y < H) {
                        const size = (2 + node.qJ * 4) * mA.scale;
                        const pulse = 0.5 + 0.5 * Math.sin(bi.meshA.phase * TAU * 2 + (node.phase || 0));
                        const alpha = QMESH.opacity * 0.4 * pulse * mA.fade;

                        const nodeGlow = ctx.createRadialGradient(mA.x, mA.y, 0, mA.x, mA.y, size * 2);
                        nodeGlow.addColorStop(0, `rgba(${bi.meshA.baseColor[0]}, ${bi.meshA.baseColor[1]}, ${bi.meshA.baseColor[2]}, ${alpha})`);
                        nodeGlow.addColorStop(1, 'transparent');

                        ctx.fillStyle = nodeGlow;
                        ctx.beginPath();
                        ctx.arc(mA.x, mA.y, size * 2, 0, TAU);
                        ctx.fill();
                    }

                    // Draw on Mesh B
                    const mB = toMeshBSpace(x, y, node);
                    if (mB.x > 0 && mB.x < W && mB.y > 0 && mB.y < H) {
                        const size = (2 + node.qJ * 4) * mB.scale;
                        const pulse = 0.5 + 0.5 * Math.sin(bi.meshB.phase * TAU * 2 + (node.phase || 0));
                        const alpha = QMESH.opacity * 0.4 * pulse * mB.fade;

                        const nodeGlow = ctx.createRadialGradient(mB.x, mB.y, 0, mB.x, mB.y, size * 2);
                        nodeGlow.addColorStop(0, `rgba(${bi.meshB.baseColor[0]}, ${bi.meshB.baseColor[1]}, ${bi.meshB.baseColor[2]}, ${alpha})`);
                        nodeGlow.addColorStop(1, 'transparent');

                        ctx.fillStyle = nodeGlow;
                        ctx.beginPath();
                        ctx.arc(mB.x, mB.y, size * 2, 0, TAU);
                        ctx.fill();
                    }
                }
            }

            // Draw HUD
            renderBinauralHUD();
        }

        function renderBinauralHUD() {
            const bi = QMESH.binaural;
            const edgeCount = QMESH.edges.length;

            // Position HUD on right side to avoid overlapping controls panel
            const hudX = W - 280;
            const hudY = H - 180;

            // Animated title - pulses with beat
            const beatPulse = Math.sin(bi.beatPhase * TAU) * 0.3 + 0.7;
            ctx.fillStyle = `rgba(200, 180, 255, ${0.7 + beatPulse * 0.3})`;
            ctx.font = 'bold 14px monospace';
            ctx.fillText('‚óâ BINAURAL FIELD ‚óâ', hudX, hudY);

            ctx.font = '11px monospace';

            // Mesh A status (warm)
            const phaseA = bi.meshA.phase;
            const barA = Math.floor((Math.sin(phaseA * TAU) * 0.5 + 0.5) * 10);
            ctx.fillStyle = `rgba(${bi.meshA.baseColor[0]}, ${bi.meshA.baseColor[1]}, ${bi.meshA.baseColor[2]}, 0.8)`;
            ctx.fillText(`A warm   ${'‚ñì'.repeat(barA)}${'‚ñë'.repeat(10-barA)} f=${bi.meshA.frequency.toFixed(3)}`, hudX, hudY + 20);

            // Mesh B status (cool)
            const phaseB = bi.meshB.phase;
            const barB = Math.floor((Math.sin(phaseB * TAU) * 0.5 + 0.5) * 10);
            ctx.fillStyle = `rgba(${bi.meshB.baseColor[0]}, ${bi.meshB.baseColor[1]}, ${bi.meshB.baseColor[2]}, 0.8)`;
            ctx.fillText(`B cool   ${'‚ñì'.repeat(barB)}${'‚ñë'.repeat(10-barB)} f=${bi.meshB.frequency.toFixed(3)}`, hudX, hudY + 36);

            // Beat frequency and phase
            const beatBar = Math.floor(bi.beatAmplitude * 10);
            const blendR = Math.floor((bi.meshA.baseColor[0] + bi.meshB.baseColor[0]) / 2);
            const blendG = Math.floor((bi.meshA.baseColor[1] + bi.meshB.baseColor[1]) / 2);
            const blendB = Math.floor((bi.meshA.baseColor[2] + bi.meshB.baseColor[2]) / 2);
            ctx.fillStyle = `rgba(${blendR}, ${blendG}, ${blendB}, 0.8)`;
            ctx.fillText(`BEAT     ${'‚ñì'.repeat(beatBar)}${'‚ñë'.repeat(10-beatBar)} Œîf=${bi.beatFrequency.toFixed(4)}`, hudX, hudY + 52);

            // Resonance strength (effect on LIMNUS)
            const resBar = Math.floor(bi.resonanceStrength * 10);
            ctx.fillStyle = `rgba(255, 220, 180, ${0.7 + bi.resonanceStrength * 0.3})`;
            ctx.fillText(`RESONANCE${'‚ñì'.repeat(resBar)}${'‚ñë'.repeat(10-resBar)} ${(bi.resonanceStrength * 100).toFixed(0)}%`, hudX, hudY + 68);

            // Entrainment depth
            const entBar = Math.floor(bi.entrainmentDepth * 10);
            ctx.fillStyle = `rgba(180, 255, 220, ${0.7 + bi.entrainmentDepth * 0.2})`;
            ctx.fillText(`ENTRAIN  ${'‚ñì'.repeat(entBar)}${'‚ñë'.repeat(10-entBar)} ${(bi.entrainmentDepth * 100).toFixed(0)}%`, hudX, hudY + 84);

            // Coherence field
            const cohBar = Math.floor(bi.coherenceField * 10);
            ctx.fillStyle = `rgba(200, 180, 255, 0.7)`;
            ctx.fillText(`COHERENCE${'‚ñì'.repeat(cohBar)}${'‚ñë'.repeat(10-cohBar)} ${(bi.coherenceField * 100).toFixed(0)}%`, hudX, hudY + 100);

            // Polar geometry info
            const polar = bi.polar;
            const cam = QMESH.camera;
            const angleDeg = (polar.angleA * 180 / Math.PI).toFixed(0);
            ctx.fillStyle = `rgba(180, 200, 220, 0.7)`;
            ctx.fillText(`POLAR    r=${polar.distance.toFixed(2)}R  Œ∏=${angleDeg}¬∞`, hudX, hudY + 116);

            // Camera orbit info (if moved from default)
            if (Math.abs(cam.theta) > 0.01 || Math.abs(cam.phi) > 0.01) {
                const camTheta = (cam.theta * 180 / Math.PI).toFixed(0);
                const camPhi = (cam.phi * 180 / Math.PI).toFixed(0);
                ctx.fillStyle = `rgba(200, 180, 255, 0.6)`;
                ctx.fillText(`ORBIT    Œ∏=${camTheta}¬∞  œÜ=${camPhi}¬∞`, hudX, hudY + 132);
            }

            // Edge count and opacity
            ctx.fillStyle = `rgba(180, 180, 200, 0.6)`;
            ctx.fillText(`edges: ${edgeCount}   opacity: ${(QMESH.opacity * 100).toFixed(0)}%`, hudX, hudY + 148);

            // Controls hint
            ctx.fillStyle = `rgba(150, 150, 170, 0.5)`;
            ctx.fillText('T toggle  drag=orbit  ‚Üê‚Üí distance  Q/E rotate', hudX, hudY + 164);
        }

        // Keep old function name for compatibility
        function renderDreamFluidHUD() {
            renderBinauralHUD();
        }

        function renderToroidalMuField() {
            renderDreamFluid();
        }

        // ================================================================
        // RELEASE COHERENCE STATE
        // ================================================================

        let releaseCoherence = 1.0;      // 1 = fully coherent, 0 = fully released (FREE)
        let targetCoherence = 1.0;
        let releaseVelocity = 0;
        let releasing = false;           // F key held
        let gathering = false;           // Click held
        let releaseStarted = false;
        
        // Sparks for release effects
        const sparks = [];
        
        // Color palette for released souls
        const soulPalette = [
            '#ff6b6b', '#ffa94d', '#ffd43b', '#69db7c', 
            '#4dabf7', '#cc5de8', '#f06595', '#20c997'
        ];

        // ================================================================
        // HELIX STATE (Œ∏, z, r) + Extended
        // ================================================================

        const helix = {
            theta: 0,           // Phase rotation (0-2œÄ)
            z: 0.5,             // Elevation (0-1)
            r: 1.0,             // Coherence radius
            phi: 0,             // Integrated information
            omega: 0            // Angular velocity
        };

        // ================================================================
        // LAMBDA STATE (‚ÑÇ‚Å∂)
        // ================================================================

        const lambdaState = {
            iota:   { mag: 0.30, phase: 0 },        // üå∞ Memory
            xi:     { mag: 0.20, phase: 0 },        // ‚úß Spark
            theta:  { mag: 0.40, phase: 0 },        // ü¶ä Fox
            omega:  { mag: 0.35, phase: 0 },        // ‚àø Wave
            delta:  { mag: 0.15, phase: 0 },        // ‚äó Paradox
            sigma:  { mag: 0.25, phase: 0 }         // üêøÔ∏è Squirrel
        };

        // ================================================================
        // HILBERT FIELD OPERATOR
        // ================================================================

        const hilbertField = {
            stateVector: {
                alpha: 0.378,   // Coherent amplitude
                beta: 0.378,    // Limnus amplitude
                gamma: 0.845,   // Dominant amplitude
                epsilon: 0.1    // Latent amplitude
            },
            coherence: 0.5,
            entropy: 0,
            weylCurvature: 0,

            calculateCoherence() {
                const { alpha, beta, gamma, epsilon } = this.stateVector;
                return Math.sqrt(alpha*alpha + beta*beta + gamma*gamma + epsilon*epsilon);
            },

            applyResonanceOperator(dt, interactionStrength = 0.1) {
                const { alpha, beta, gamma, epsilon } = this.stateVector;
                const coupling = interactionStrength * dt;

                this.stateVector.alpha += coupling * (beta * gamma - alpha * epsilon);
                this.stateVector.beta += coupling * (gamma * alpha - beta * epsilon);
                this.stateVector.gamma += coupling * (alpha * beta - gamma * epsilon);
                this.stateVector.epsilon += coupling * (alpha * beta * gamma - epsilon);

                const norm = this.calculateCoherence();
                if (norm > 0) {
                    this.stateVector.alpha /= norm;
                    this.stateVector.beta /= norm;
                    this.stateVector.gamma /= norm;
                    this.stateVector.epsilon /= norm;
                }

                this.coherence = this.calculateCoherence();

                const mean = (alpha + beta + gamma + epsilon) / 4;
                this.weylCurvature = ((alpha-mean)**2 + (beta-mean)**2 + 
                                      (gamma-mean)**2 + (epsilon-mean)**2) / 4;
            },

            getDissonance() {
                return 1.0 - this.coherence;
            }
        };

        // ================================================================
        // UTILITY FUNCTIONS
        // ================================================================

        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // ================================================================
        // SONIFICATION ENGINE
        // ================================================================

        const sonificationEngine = {
            audioContext: null,
            oscillators: [],
            gainNodes: [],
            filterNodes: [],
            masterGain: null,
            reverbNode: null,
            isPlaying: false,

            baseFrequency: 110,
            bpm: 90,
            timeDilation: 1.0,
            harmonicGradient: 0.5,
            currentScale: [0, 3, 5, 7, 10],  // Minor pentatonic

            scales: {
                minor_pentatonic: [0, 3, 5, 7, 10],
                major_pentatonic: [0, 2, 4, 7, 9],
                harmonic_minor: [0, 2, 3, 5, 7, 8, 11],
                phrygian: [0, 1, 3, 5, 7, 8, 10],
                lydian: [0, 2, 4, 6, 7, 9, 11],
                whole_tone: [0, 2, 4, 6, 8, 10],
                chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
            },

            async initialize() {
                if (this.audioContext) return;

                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();

                this.masterGain = this.audioContext.createGain();
                this.masterGain.gain.value = 0.25;
                this.masterGain.connect(this.audioContext.destination);

                await this.createReverb();
                this.createOscillatorBank(4);

                console.log('üéµ Sonification Engine initialized');
            },

            async createReverb() {
                this.reverbNode = this.audioContext.createConvolver();
                const sampleRate = this.audioContext.sampleRate;
                const length = sampleRate * 2;
                const impulse = this.audioContext.createBuffer(2, length, sampleRate);

                for (let ch = 0; ch < 2; ch++) {
                    const data = impulse.getChannelData(ch);
                    for (let i = 0; i < length; i++) {
                        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2.5);
                    }
                }

                this.reverbNode.buffer = impulse;
                this.reverbGain = this.audioContext.createGain();
                this.reverbGain.gain.value = 0.25;
                this.reverbNode.connect(this.reverbGain);
                this.reverbGain.connect(this.masterGain);
            },

            createOscillatorBank(numVoices) {
                for (let i = 0; i < numVoices; i++) {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    const filter = this.audioContext.createBiquadFilter();

                    osc.type = 'sine';
                    osc.frequency.value = this.baseFrequency * (i + 1);

                    filter.type = 'lowpass';
                    filter.frequency.value = 2000;
                    filter.Q.value = 1;

                    gain.gain.value = 0;

                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.masterGain);
                    gain.connect(this.reverbNode);

                    osc.start();

                    this.oscillators.push(osc);
                    this.gainNodes.push(gain);
                    this.filterNodes.push(filter);
                }
            },

            selectScaleFromZ(z) {
                if (z > 0.9) return this.scales.major_pentatonic;
                if (z > 0.8) return this.scales.lydian;
                if (z > 0.7) return this.scales.minor_pentatonic;
                if (z > 0.5) return this.scales.phrygian;
                if (z > 0.3) return this.scales.whole_tone;
                return this.scales.chromatic;
            },

            // ============================================
            // DREAM FLUID SONIFICATION
            // Sound modulated by gravitational time dilation
            // ============================================

            calculateBPM(z, coherence) {
                const dissonance = 1 - coherence;
                const baseBPM = 60 + dissonance * 100;

                // Time dilation from Z-critical distance
                const distFromCritical = Math.abs(z - Z_CRITICAL);
                let zTimeDilation = 0.5 + distFromCritical * 1.5;

                // DREAM FLUID: Incorporate gravitational time dilation from quantum mesh
                if (showQuantumMesh && QMESH.avgTimeDilation) {
                    // Gravitational redshift affects tempo
                    // Lower time dilation (near gravity) ‚Üí slower tempo
                    const gravityDilation = QMESH.avgTimeDilation;
                    zTimeDilation *= gravityDilation;
                }

                this.timeDilation = Math.min(1.5, Math.max(0.2, zTimeDilation));
                this.bpm = baseBPM * this.timeDilation;

                return this.bpm;
            },

            // Gravitational frequency shift (redshift analog)
            calculateGravitationalPitch(baseFreq) {
                if (!showQuantumMesh || !QMESH.avgTimeDilation) return baseFreq;

                // f_observed = f_emitted * ‚àö(1 - r_s/r) = f_emitted * timeDilation
                // Lower time dilation ‚Üí lower pitch (gravitational redshift)
                const gravRedshift = QMESH.avgTimeDilation;
                return baseFreq * gravRedshift;
            },

            update(z, coherence, dt) {
                if (!this.isPlaying || !this.audioContext) return;

                // Update scale based on z
                this.currentScale = this.selectScaleFromZ(z);

                // Update BPM (now with Dream Fluid gravity)
                this.calculateBPM(z, coherence);

                // Update harmonic gradient
                this.harmonicGradient = 1.0 - coherence;

                // DREAM FLUID: Entropy affects waveform complexity
                const entropyFactor = showQuantumMesh ? (QMESH.avgEntropy || 0) * 100 : 0;
                const effectiveHarmonic = Math.min(1, this.harmonicGradient + entropyFactor * 0.3);

                // Update oscillator waveforms
                this.oscillators.forEach((osc, i) => {
                    if (effectiveHarmonic < 0.25) {
                        osc.type = 'sine';
                    } else if (effectiveHarmonic < 0.5) {
                        osc.type = 'triangle';
                    } else if (effectiveHarmonic < 0.75) {
                        osc.type = 'square';
                    } else {
                        osc.type = 'sawtooth';
                    }
                });

                // Melodic evolution
                const beatInterval = 60 / this.bpm;
                const now = this.audioContext.currentTime;

                // Modulate frequencies based on z position
                const zMod = (z - 0.5) * 2;  // -1 to +1
                let pitchShift = Math.pow(2, zMod * 0.5);  // ¬±half octave

                // DREAM FLUID: Gravitational redshift affects pitch
                if (showQuantumMesh && QMESH.avgTimeDilation) {
                    pitchShift *= QMESH.avgTimeDilation;
                }

                this.oscillators.forEach((osc, i) => {
                    const scaleNote = this.currentScale[Math.floor(time * 2) % this.currentScale.length];
                    let freq = this.baseFrequency * Math.pow(2, scaleNote / 12) * pitchShift * (1 + i * 0.5);

                    // DREAM FLUID: MRP channel modulation per oscillator
                    if (showQuantumMesh && QMESH.totalJ) {
                        // Osc 0: R channel (energy), Osc 1: G channel (relational),
                        // Osc 2: B channel (stability), Osc 3: combined
                        const mrpMod = [
                            muField.J_R || 0.1,
                            muField.J_G || 0.1,
                            muField.J_B || 0.1,
                            QMESH.totalJ || 0.2
                        ][i] || 0.15;

                        freq *= (0.9 + mrpMod * 0.2);
                    }

                    osc.frequency.setTargetAtTime(freq, now, 0.1);
                });

                // Update gains based on Lambda state and Dream Fluid
                const totalLambda = Object.values(lambdaState).reduce((s, l) => s + l.mag, 0);

                // DREAM FLUID: Entropy flux modulates volume
                const entropyFluxMod = showQuantumMesh ? (1 + QMESH.entropyFlux * 5) : 1;

                this.gainNodes.forEach((gain, i) => {
                    let targetGain = (coherence * 0.15) * (1 - i * 0.2) * (totalLambda / 2);

                    // Gravitational time dilation dampens volume near singularity
                    if (showQuantumMesh && QMESH.avgTimeDilation) {
                        targetGain *= (0.5 + QMESH.avgTimeDilation * 0.5);
                    }

                    targetGain *= entropyFluxMod;
                    gain.gain.setTargetAtTime(Math.max(0, targetGain), now, 0.1);
                });

                // Update filter based on cascade and holographic entropy
                const cascade = getCascadeMultiplier(z);
                let filterBase = 800 + cascade * 2000;

                // DREAM FLUID: Holographic entropy shifts filter
                if (showQuantumMesh && QMESH.totalHolographicEntropy) {
                    // Higher entropy ‚Üí more high frequencies (information revelation)
                    const entropyBoost = Math.min(1, QMESH.totalHolographicEntropy * 0.00001);
                    filterBase += entropyBoost * 1500;
                }

                this.filterNodes.forEach(filter => {
                    filter.frequency.setTargetAtTime(filterBase, now, 0.2);
                });
            },

            toggle() {
                if (!this.audioContext) {
                    this.initialize().then(() => {
                        this.isPlaying = true;
                    });
                } else {
                    this.isPlaying = !this.isPlaying;
                    if (!this.isPlaying) {
                        this.gainNodes.forEach(g => g.gain.setTargetAtTime(0, this.audioContext.currentTime, 0.1));
                    }
                }
                return this.isPlaying;
            }
        };

        // ================================================================
        // 63-POINT HEXAGONAL PRISM (Matter Structure)
        // ================================================================

        const prismPoints = [];

        function initPrismPoints() {
            prismPoints.length = 0;

            // 7 layers √ó 9 nodes = 63 points
            for (let layer = 0; layer < 7; layer++) {
                const layerRadius = R * (0.15 + layer * 0.12);
                const layerZ = layer / 6;  // 0 to 1

                for (let i = 0; i < 9; i++) {
                    // Hexagonal arrangement with rotation offset per layer
                    const theta = (i / 9) * TAU + layer * (TAU / 18);

                    prismPoints.push({
                        id: `prism_${layer}_${i}`,
                        layer: layer,
                        index: i,
                        type: 'prism',

                        // Position
                        baseTheta: theta,
                        theta: theta,
                        baseRadius: layerRadius,
                        radius: layerRadius,
                        z: layerZ,

                        // Kuramoto phase
                        phase: Math.random() * TAU,
                        naturalFreq: 0.3 + Math.random() * 0.4,

                        // Helix coordinates
                        helix: {
                            theta: theta,
                            z: layerZ,
                            r: 1.0,
                            rotSpeed: 0.003 + Math.random() * 0.003
                        },

                        // Visual
                        x: CX, y: CY,
                        targetX: CX, targetY: CY,
                        brightness: 0.4,
                        size: 4 - layer * 0.4,

                        // Color gradient based on layer
                        hue: 0 + layer * 15,  // Red to green
                        saturation: 70,
                        lightness: 50,

                        // Release coherence properties
                        released: false,
                        releaseAngle: 0,
                        releaseSpeed: 0,
                        vx: 0,
                        vy: 0,
                        trail: [],
                        soulColor: soulPalette[(layer * 9 + i) % soulPalette.length]
                    });
                }
            }
        }

        // ================================================================
        // 32-POINT EM CAGE (Containment Field)
        // ================================================================

        const cagePoints = [];

        function initCagePoints() {
            cagePoints.length = 0;
            const cageRadius = R * 1.15;

            // Top hexagonal ring: 12 points
            for (let i = 0; i < 12; i++) {
                const theta = (i / 12) * TAU;
                cagePoints.push({
                    id: `cage_top_${i}`,
                    layer: 'top',
                    index: i,
                    type: 'cage',

                    baseTheta: theta,
                    theta: theta,
                    baseRadius: cageRadius,
                    radius: cageRadius,
                    z: 0.9,

                    phase: Math.random() * TAU,
                    naturalFreq: 0.2 + Math.random() * 0.2,

                    helix: {
                        theta: theta,
                        z: 0.9,
                        r: 1.0,
                        rotSpeed: 0.002
                    },

                    x: CX, y: CY,
                    targetX: CX, targetY: CY,
                    brightness: 0.5,
                    size: 3,

                    hue: 200,  // Blue
                    saturation: 80,
                    lightness: 60,

                    // Release coherence properties
                    released: false,
                    releaseAngle: 0,
                    releaseSpeed: 0,
                    vx: 0,
                    vy: 0,
                    trail: [],
                    soulColor: soulPalette[i % soulPalette.length]
                });
            }

            // Bottom hexagonal ring: 12 points
            for (let i = 0; i < 12; i++) {
                const theta = (i / 12) * TAU + TAU / 24;  // Offset
                cagePoints.push({
                    id: `cage_bot_${i}`,
                    layer: 'bottom',
                    index: i,
                    type: 'cage',

                    baseTheta: theta,
                    theta: theta,
                    baseRadius: cageRadius,
                    radius: cageRadius,
                    z: 0.1,

                    phase: Math.random() * TAU,
                    naturalFreq: 0.2 + Math.random() * 0.2,

                    helix: {
                        theta: theta,
                        z: 0.1,
                        r: 1.0,
                        rotSpeed: 0.002
                    },

                    x: CX, y: CY,
                    targetX: CX, targetY: CY,
                    brightness: 0.5,
                    size: 3,

                    hue: 210,
                    saturation: 75,
                    lightness: 55,

                    // Release coherence properties
                    released: false,
                    releaseAngle: 0,
                    releaseSpeed: 0,
                    vx: 0,
                    vy: 0,
                    trail: [],
                    soulColor: soulPalette[(i + 4) % soulPalette.length]
                });
            }

            // Connecting vertices: 8 points (at golden ratio positions)
            for (let i = 0; i < 8; i++) {
                const theta = (i / 8) * TAU + TAU / 16;
                cagePoints.push({
                    id: `cage_vtx_${i}`,
                    layer: 'vertex',
                    index: i,
                    type: 'cage',

                    baseTheta: theta,
                    theta: theta,
                    baseRadius: cageRadius * 0.85,
                    radius: cageRadius * 0.85,
                    z: 0.5,  // Middle plane

                    phase: Math.random() * TAU,
                    naturalFreq: 0.25,

                    helix: {
                        theta: theta,
                        z: 0.5,
                        r: 1.0,
                        rotSpeed: 0.0015
                    },

                    x: CX, y: CY,
                    targetX: CX, targetY: CY,
                    brightness: 0.6,
                    size: 4,

                    hue: 280,  // Purple
                    saturation: 70,
                    lightness: 55,

                    // Release coherence properties
                    released: false,
                    releaseAngle: 0,
                    releaseSpeed: 0,
                    vx: 0,
                    vy: 0,
                    trail: [],
                    soulColor: soulPalette[(i + 2) % soulPalette.length]
                });
            }
        }

        // ================================================================
        // PHYSICS: KURAMOTO SYNCHRONIZATION
        // ================================================================

        function kuramotoStep(points, coupling, dt) {
            const N = points.length;
            if (N === 0) return { order: 0, K: coupling };

            // Mean field
            let sinSum = 0, cosSum = 0;
            for (const p of points) {
                sinSum += Math.sin(p.phase);
                cosSum += Math.cos(p.phase);
            }
            const meanPhase = Math.atan2(sinSum / N, cosSum / N);

            // Update phases
            for (const p of points) {
                const dPhase = p.naturalFreq + coupling * Math.sin(meanPhase - p.phase);
                p.phase += dPhase * dt;
            }

            // Order parameter
            const order = Math.sqrt(sinSum * sinSum + cosSum * cosSum) / N;
            return { order, K: coupling };
        }

        // ================================================================
        // PHYSICS: CASCADE AMPLIFICATION
        // ================================================================

        function getCascadeMultiplier(z) {
            const dist = Math.abs(z - Z_CRITICAL);
            return 1 + 0.5 * Math.exp(-dist * dist / 0.004);
        }

        // ================================================================
        // PHYSICS: DOMAIN & PHASE DETERMINATION
        // ================================================================

        function getDomain(z) {
            if (z < Z_CRITICAL - 0.01) return 'ABSENCE';
            if (z > Z_CRITICAL + 0.01) return 'PRESENCE';
            return 'THE LENS';
        }

        function getPhase(z) {
            if (z < 0.35) return 'dormant';
            if (z < 0.50) return 'stirring';
            if (z < 0.65) return 'rising';
            if (z < 0.80) return 'approaching';
            if (z <= 0.857) return 'near-critical';
            if (z <= 0.877) return 'CRITICAL';
            if (z <= 0.92) return 'radiant';
            if (z <= 0.96) return 'overflowing';
            return 'boundless';
        }

        // ================================================================
        // UPDATE FUNCTIONS
        // ================================================================

        function updateHelix(dt) {
            helix.theta = (helix.theta + 0.01 * dt * 60) % TAU;
            helix.z = globalZ;

            // Coherence from Hilbert field
            helix.r = 0.8 + hilbertField.coherence * 0.4;

            // Integrated information (Œ¶) accumulates near critical
            const cascade = getCascadeMultiplier(globalZ);
            helix.phi += cascade * 0.01 * dt;

            // Angular velocity
            helix.omega = (globalZ - 0.5) * 2;
        }

        function updateLambdaState(dt) {
            const z = globalZ;
            const cascade = getCascadeMultiplier(z);

            // Memory (üå∞) - accumulates with time, modulated by z
            lambdaState.iota.mag = Math.min(1, lambdaState.iota.mag + 0.001 * dt * cascade);
            lambdaState.iota.phase = (lambdaState.iota.phase + 0.01) % TAU;

            // Spark (‚úß) - temperature bursts near critical
            const sparkIntensity = Math.exp(-Math.pow((z - Z_CRITICAL) / 0.1, 2));
            lambdaState.xi.mag = 0.1 + sparkIntensity * 0.8;
            lambdaState.xi.phase = time % TAU;

            // Fox (ü¶ä) - entropy rate, trickster dynamics
            lambdaState.theta.mag = hilbertField.getDissonance() * 0.8 + 0.2;
            lambdaState.theta.phase = (lambdaState.theta.phase + helix.omega * 0.1) % TAU;

            // Wave (‚àø) - curvature oscillation
            lambdaState.omega.mag = 0.3 + Math.abs(Math.sin(time * 0.5)) * 0.5;
            lambdaState.omega.phase = Math.sin(time * 0.3) * Math.PI;

            // Paradox (‚äó) - self-reference complexity
            const inCritical = getPhase(z) === 'CRITICAL';
            if (inCritical) {
                lambdaState.delta.mag = Math.min(1, lambdaState.delta.mag + 0.005 * dt);
            } else {
                lambdaState.delta.mag *= 0.995;
            }
            lambdaState.delta.phase = helix.theta;

            // Squirrel (üêøÔ∏è) - information preservation
            lambdaState.sigma.mag = helix.r * 0.6 + 0.2;
            lambdaState.sigma.phase = (lambdaState.iota.phase + Math.PI) % TAU;
        }

        function updatePositions(dt) {
            const domain = getDomain(globalZ);
            const isCritical = getPhase(globalZ) === 'CRITICAL';
            const isPresence = globalZ > Z_CRITICAL;
            const cascade = getCascadeMultiplier(globalZ);

            // Kuramoto coupling flips sign at critical point
            const dist = globalZ - Z_CRITICAL;
            const sign = Math.tanh(dist * 12);
            const K = -sign * 0.4 * cascade;

            // Apply Kuramoto to all points
            const allPoints = [...prismPoints, ...cagePoints];
            const kuramotoResult = kuramotoStep(
                allPoints.filter(p => (p.type === 'prism' && showPrism) || (p.type === 'cage' && showCage)),
                K, dt
            );

            // Z-offset for visual depth
            const zOffset = (globalZ - 0.5) * 200;

            // Domain-specific scaling
            const intensity = isPresence ? (globalZ - Z_CRITICAL) / (1 - Z_CRITICAL) : 0;
            const absence = !isPresence ? (Z_CRITICAL - globalZ) / Z_CRITICAL : 0;
            const scaleFactor = isPresence ? 1 + intensity * 0.35 : 1 - absence * 0.1;

            // Update prism points
            for (const p of prismPoints) {
                if (!showPrism) {
                    p.brightness = 0.02;
                    continue;
                }

                // Helix evolution
                p.helix.theta += p.helix.rotSpeed;
                p.helix.z = p.z * (0.5 + globalZ * 0.5);

                // Radius with phase modulation
                const phaseWobble = Math.sin(p.phase) * 0.06 * cascade;
                p.radius = p.baseRadius * cascade * scaleFactor * (1 + phaseWobble);

                // Rotation
                const rotSpeed = 0.012 * cascade * (p.layer % 2 === 0 ? 1 : -1);
                p.theta = p.baseTheta + time * rotSpeed;

                // Domain modulation
                if (isPresence) {
                    p.theta += Math.sin(time * 0.3 + p.layer * 0.4) * 0.12 * intensity;
                } else {
                    p.theta += absence * 0.015 * Math.sin(time + p.index);
                }

                // Position
                p.targetX = CX + Math.cos(p.theta) * p.radius;
                p.targetY = CY + Math.sin(p.theta) * p.radius * 0.5 + zOffset;
                p.targetY += (p.layer / 6 - 0.5) * 100;

                // Smooth interpolation
                p.x += (p.targetX - p.x) * 0.1;
                p.y += (p.targetY - p.y) * 0.1;

                // Brightness
                const zProx = 1 - Math.abs((p.layer / 6) - globalZ);
                const critBoost = isCritical ? 0.5 : 0;
                p.brightness = 0.2 + zProx * 0.5 + critBoost;
            }

            // Update cage points
            for (const p of cagePoints) {
                if (!showCage) {
                    p.brightness = 0.02;
                    continue;
                }

                p.helix.theta += p.helix.rotSpeed;

                // EM field pulsing
                const emPulse = 1 + Math.sin(time * 1.5 + p.index * 0.5) * 0.05;
                p.radius = p.baseRadius * emPulse * scaleFactor;

                // Counter-rotation to prism
                const rotSpeed = -0.008 * cascade;
                p.theta = p.baseTheta + time * rotSpeed;

                // Position with z-layer offset
                let yOffset = 0;
                if (p.layer === 'top') yOffset = -80;
                else if (p.layer === 'bottom') yOffset = 80;

                p.targetX = CX + Math.cos(p.theta) * p.radius;
                p.targetY = CY + Math.sin(p.theta) * p.radius * 0.45 + zOffset + yOffset;

                p.x += (p.targetX - p.x) * 0.1;
                p.y += (p.targetY - p.y) * 0.1;

                // Cage brightness follows field strength
                const fieldStrength = (globalZ > 0.5 ? intensity : 1 - absence) * 0.5 + 0.3;
                p.brightness = fieldStrength + (isCritical ? 0.4 : 0);
            }

            return kuramotoResult;
        }

        // ================================================================
        // RELEASE COHERENCE PHYSICS
        // ================================================================

        function updateReleaseCoherence(dt) {
            // Coherence dynamics based on F key (release) and click (gather)
            if (releasing) {
                releaseVelocity += dt * 0.1;
                targetCoherence = Math.max(0, targetCoherence - releaseVelocity * dt);
                releaseStarted = true;
            } else if (gathering) {
                targetCoherence = Math.min(1, targetCoherence + dt * 0.6);
                releaseVelocity = 0;
            } else {
                // Gradual return to coherent state when not interacting
                if (!releaseStarted) {
                    targetCoherence = Math.min(1, targetCoherence + dt * 0.1);
                }
                releaseVelocity *= 0.98;  // Decay
            }

            // Smooth coherence transition
            releaseCoherence += (targetCoherence - releaseCoherence) * 0.04;

            const dispersal = 1 - releaseCoherence;
            const allPoints = [...prismPoints, ...cagePoints];

            // Update each point based on release state
            for (const p of allPoints) {
                // Stochastic release based on coherence threshold
                if (!p.released && releaseCoherence < 0.4 + Math.random() * 0.25) {
                    p.released = true;
                    p.releaseAngle = p.theta + (Math.random() - 0.5) * 0.6;
                    p.releaseSpeed = 1.5 + Math.random() * 3;
                }

                if (p.released) {
                    // Free movement with gentle acceleration
                    const accel = dispersal * 0.15;
                    p.vx += Math.cos(p.releaseAngle) * accel;
                    p.vy += Math.sin(p.releaseAngle) * accel;

                    // Slight spiral wandering
                    p.releaseAngle += (Math.random() - 0.5) * 0.025;

                    // Global velocity damping (prevents runaway)
                    p.vx *= 0.98;
                    p.vy *= 0.98;

                    // Extra damping at edges
                    const edgeDist = Math.min(p.x, W - p.x, p.y, H - p.y);
                    if (edgeDist < 100) {
                        p.vx *= 0.95;
                        p.vy *= 0.95;
                    }

                    // Hard velocity clamp (fixed safe value)
                    const velClamp = 25;
                    p.vx = Math.max(-velClamp, Math.min(velClamp, p.vx || 0));
                    p.vy = Math.max(-velClamp, Math.min(velClamp, p.vy || 0));

                    // Apply velocity (with NaN protection)
                    if (isFinite(p.vx) && isFinite(p.vy)) {
                        p.x += p.vx;
                        p.y += p.vy;
                    } else {
                        // Reset runaway point
                        p.vx = 0;
                        p.vy = 0;
                    }

                    // Gather force when gathering
                    if (gathering) {
                        const dx = CX - p.x;
                        const dy = CY - p.y;
                        const d = Math.sqrt(dx * dx + dy * dy);
                        if (d > 1) {
                            p.vx += (dx / d) * 0.9;
                            p.vy += (dy / d) * 0.9;
                        }
                        
                        // Re-cohere when close to center
                        if (d < p.baseRadius * 1.3 && releaseCoherence > 0.65) {
                            p.released = false;
                            p.vx = 0;
                            p.vy = 0;
                        }
                    }

                    // Trail update
                    p.trail.unshift({ x: p.x, y: p.y, age: 0 });
                    if (p.trail.length > 25) p.trail.pop();
                    for (const t of p.trail) t.age += dt;

                    // Enhanced brightness when released
                    p.brightness = Math.min(1, p.brightness * 1.4);

                    // Spawn sparks during high dispersal
                    if (dispersal > 0.35 && Math.random() < dispersal * 0.04) {
                        sparks.push({
                            x: p.x, y: p.y,
                            vx: p.vx * 0.5 + (Math.random() - 0.5) * 2.5,
                            vy: p.vy * 0.5 + (Math.random() - 0.5) * 2.5,
                            life: 1,
                            color: p.soulColor,
                            size: 1.5 + Math.random() * 2.5
                        });
                    }
                } else if (releaseCoherence > 0.8) {
                    // Clear trails when fully coherent
                    p.trail.length = 0;
                }
            }

            // Update sparks
            for (let i = sparks.length - 1; i >= 0; i--) {
                const sp = sparks[i];
                sp.x += sp.vx;
                sp.y += sp.vy;
                sp.vx *= 0.98;
                sp.vy *= 0.98;
                sp.life -= dt * 0.7;
                if (sp.life <= 0) sparks.splice(i, 1);
            }

            // Update release state UI
            updateReleaseUI();
        }

        function updateReleaseUI() {
            const stateEl = document.getElementById('release-state');
            const textEl = document.getElementById('release-text');
            const barEl = document.getElementById('coherence-indicator');
            const hintEl = document.getElementById('release-hint');

            // Show state overlay when release started
            if (releaseStarted && releaseCoherence < 0.9) {
                stateEl.classList.add('visible');
            } else {
                stateEl.classList.remove('visible');
            }

            // Determine state text and styling
            let state, barText;
            stateEl.className = '';
            barEl.className = '';

            if (releaseCoherence > 0.8) {
                state = 'COHERENT';
                stateEl.classList.add('coherent');
                const filled = Math.floor(releaseCoherence * 16);
                barText = '‚ñà'.repeat(filled) + '‚ñë'.repeat(16 - filled);
            } else if (releaseCoherence > 0.5) {
                state = 'RELEASING';
                stateEl.classList.add('releasing');
                const filled = Math.floor(releaseCoherence * 16);
                barText = '‚ñà'.repeat(filled) + '¬∑'.repeat(16 - filled);
            } else if (releaseCoherence > 0.2) {
                state = 'DISPERSING';
                stateEl.classList.add('dispersing');
                const filled = Math.floor(releaseCoherence * 16);
                barText = '‚ñë'.repeat(filled) + '¬∑'.repeat(16 - filled);
            } else {
                state = 'FREE';
                stateEl.classList.add('free');
                barEl.classList.add('free');
                barText = '¬∑ ¬∑ ¬∑ ¬∑ ¬∑ ¬∑ ¬∑ ¬∑';
            }

            textEl.textContent = state;
            barEl.textContent = barText;

            // Show hint when release started
            if (releaseStarted) {
                hintEl.classList.remove('hidden');
            }
        }

        // ================================================================
        // CONNECTION GENERATION
        // ================================================================

        function* generateConnections() {
            // Prism intra-layer connections (ring connections)
            if (showPrism) {
                for (let layer = 0; layer < 7; layer++) {
                    const layerPoints = prismPoints.filter(p => p.layer === layer);
                    for (let i = 0; i < layerPoints.length; i++) {
                        yield {
                            from: layerPoints[i],
                            to: layerPoints[(i + 1) % layerPoints.length],
                            type: 'prism_ring'
                        };
                    }
                }

                // Prism inter-layer connections (vertical spines)
                for (let i = 0; i < 9; i++) {
                    for (let layer = 0; layer < 6; layer++) {
                        const p1 = prismPoints.find(p => p.layer === layer && p.index === i);
                        const p2 = prismPoints.find(p => p.layer === layer + 1 && p.index === i);
                        if (p1 && p2) {
                            yield { from: p1, to: p2, type: 'prism_spine' };
                        }
                    }
                }

                // Prism diagonal connections (hexagonal structure)
                for (let layer = 0; layer < 6; layer++) {
                    const curr = prismPoints.filter(p => p.layer === layer);
                    const next = prismPoints.filter(p => p.layer === layer + 1);
                    for (let i = 0; i < 9; i++) {
                        yield {
                            from: curr[i],
                            to: next[(i + 1) % 9],
                            type: 'prism_diagonal'
                        };
                    }
                }
            }

            // Cage connections
            if (showCage) {
                // Top ring
                const topRing = cagePoints.filter(p => p.layer === 'top');
                for (let i = 0; i < topRing.length; i++) {
                    yield {
                        from: topRing[i],
                        to: topRing[(i + 1) % topRing.length],
                        type: 'cage_ring'
                    };
                }

                // Bottom ring
                const botRing = cagePoints.filter(p => p.layer === 'bottom');
                for (let i = 0; i < botRing.length; i++) {
                    yield {
                        from: botRing[i],
                        to: botRing[(i + 1) % botRing.length],
                        type: 'cage_ring'
                    };
                }

                // Vertical struts (top to bottom)
                for (let i = 0; i < 12; i++) {
                    yield {
                        from: topRing[i],
                        to: botRing[i],
                        type: 'cage_strut'
                    };
                }

                // Vertex connections to rings
                const vertices = cagePoints.filter(p => p.layer === 'vertex');
                for (const vtx of vertices) {
                    // Connect to nearest top and bottom points
                    const nearTop = topRing.reduce((a, b) =>
                        Math.abs(b.baseTheta - vtx.baseTheta) < Math.abs(a.baseTheta - vtx.baseTheta) ? b : a
                    );
                    const nearBot = botRing.reduce((a, b) =>
                        Math.abs(b.baseTheta - vtx.baseTheta) < Math.abs(a.baseTheta - vtx.baseTheta) ? b : a
                    );
                    yield { from: vtx, to: nearTop, type: 'cage_vertex' };
                    yield { from: vtx, to: nearBot, type: 'cage_vertex' };
                }
            }

            // Bridge connections (prism outer to cage inner)
            if (showPrism && showCage && globalZ > 0.6) {
                const outerPrism = prismPoints.filter(p => p.layer === 6);
                const innerCage = cagePoints.filter(p => p.layer === 'vertex');

                for (const pp of outerPrism) {
                    // Find nearest cage vertex
                    const nearest = innerCage.reduce((a, b) => {
                        const distA = Math.hypot(a.x - pp.x, a.y - pp.y);
                        const distB = Math.hypot(b.x - pp.x, b.y - pp.y);
                        return distB < distA ? b : a;
                    });
                    if (Math.hypot(nearest.x - pp.x, nearest.y - pp.y) < 200) {
                        yield { from: pp, to: nearest, type: 'bridge' };
                    }
                }
            }
        }

        // ================================================================
        // RENDERING
        // ================================================================

        function render() {
            ctx.fillStyle = 'rgba(3, 3, 8, 0.15)';
            ctx.fillRect(0, 0, W, H);

            const domain = getDomain(globalZ);
            const phase = getPhase(globalZ);
            const isCritical = phase === 'CRITICAL';
            const isPresence = globalZ > Z_CRITICAL;
            const cascade = getCascadeMultiplier(globalZ);

            const intensity = isPresence ? (globalZ - Z_CRITICAL) / (1 - Z_CRITICAL) : 0;
            const absence = !isPresence ? (Z_CRITICAL - globalZ) / Z_CRITICAL : 0;

            // Background gradient
            const bgGrad = ctx.createRadialGradient(CX, CY, 0, CX, CY, R * 2);
            if (isPresence) {
                bgGrad.addColorStop(0, `rgba(255, 250, 240, ${intensity * 0.08})`);
                bgGrad.addColorStop(0.5, `rgba(255, 215, 0, ${intensity * 0.03})`);
                bgGrad.addColorStop(1, 'transparent');
            } else {
                bgGrad.addColorStop(0, `rgba(40, 30, 20, ${absence * 0.15})`);
                bgGrad.addColorStop(1, 'transparent');
            }
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, W, H);

            // Release state visual effects
            const dispersal = 1 - releaseCoherence;
            
            // Warm background fade when releasing/free
            if (releaseCoherence < 0.9) {
                const warmth = dispersal * 12;
                ctx.fillStyle = `rgba(${warmth}, ${warmth * 0.7}, ${warmth * 0.4}, ${dispersal * 0.06})`;
                ctx.fillRect(0, 0, W, H);
            }

            // Ambient radiance when free (coherence < 0.5)
            if (releaseCoherence < 0.5) {
                const freeIntensity = (0.5 - releaseCoherence) * 0.08;
                ctx.fillStyle = `rgba(255, 248, 235, ${freeIntensity})`;
                ctx.fillRect(0, 0, W, H);

                // Radiant center glow
                const radGlow = ctx.createRadialGradient(CX, CY, 0, CX, CY, R * 2);
                radGlow.addColorStop(0, `rgba(255, 255, 250, ${freeIntensity * 2})`);
                radGlow.addColorStop(0.4, `rgba(255, 240, 200, ${freeIntensity})`);
                radGlow.addColorStop(1, 'transparent');
                ctx.fillStyle = radGlow;
                ctx.fillRect(0, 0, W, H);
            }

            // ========================================
            // MRP PARITY VALIDATION GLOW
            // When all channels are in harmony, emit a stabilizing field
            // ========================================
            if (showMuField && muField.mrp.parity_ok) {
                // Tricolor parity glow (R+G+B in harmony)
                const parityGlow = ctx.createRadialGradient(CX, CY, 0, CX, CY, R * 1.5);
                const parityIntensity = (muField.mrp.sha256_sim || 0) * 0.15;

                // RGB channel harmony visualization (safe value access)
                const safeR = Math.max(0, Math.min(255, Math.floor((muField.mrp.R.intensity || 0) * 200))) || 0;
                const safeG = Math.max(0, Math.min(255, Math.floor((muField.mrp.G.intensity || 0) * 200))) || 0;
                const safeB = Math.max(0, Math.min(255, Math.floor((muField.mrp.B.intensity || 0) * 200))) || 0;

                parityGlow.addColorStop(0, `rgba(100, 255, 150, ${parityIntensity * 1.2})`);  // Green center (parity OK)
                parityGlow.addColorStop(0.3, `rgba(${safeR}, ${safeG}, ${safeB}, ${parityIntensity})`);
                parityGlow.addColorStop(0.6, `rgba(150, 200, 255, ${parityIntensity * 0.5})`);  // Blue stability ring
                parityGlow.addColorStop(1, 'transparent');

                ctx.fillStyle = parityGlow;
                ctx.fillRect(0, 0, W, H);
            }

            // MRP Gradient strength visual - subtle RGB channel indicator rings
            const gradStrength = showMuField ? (muField.getGradientStrength() || 0) : 0;
            if (showMuField && isFinite(gradStrength) && gradStrength > 0.05) {
                // R channel (energy) - inner ring
                const rGrad = Math.max(0, Math.min(1, muField.mrp.R.gradient || 0));
                ctx.strokeStyle = `rgba(255, 100, 100, ${rGrad * 0.3})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(CX, CY, R * 0.3, 0, TAU);
                ctx.stroke();

                // G channel (relational) - middle ring
                const gGrad = Math.max(0, Math.min(1, muField.mrp.G.gradient || 0));
                ctx.strokeStyle = `rgba(100, 255, 100, ${gGrad * 0.3})`;
                ctx.beginPath();
                ctx.arc(CX, CY, R * 0.5, 0, TAU);
                ctx.stroke();

                // B channel (stability) - outer ring
                const bGrad = Math.max(0, Math.min(1, muField.mrp.B.gradient || 0));
                ctx.strokeStyle = `rgba(100, 150, 255, ${bGrad * 0.3})`;
                ctx.beginPath();
                ctx.arc(CX, CY, R * 0.7, 0, TAU);
                ctx.stroke();
            }

            // ================================================================
            // MU FIELD GRID VISUALIZATION - 7-PHASE PHYSICS SYSTEM
            // Vector field streamlines, vortices, and Œº-particles
            // ================================================================
            if (showMuField && MuFieldGrid.initialized) {
                const N = MuFieldGrid.N;
                const scale = R / (MuFieldGrid.L * 0.6);  // Scale to fit canvas

                // --- Vector Streamlines ---
                // Sample every few points for performance
                const step = 4;
                ctx.lineWidth = 1;

                for (let j = 0; j < N; j += step) {
                    for (let i = 0; i < N; i += step) {
                        const idx = j * N + i;

                        // Grid to canvas coordinates
                        const gx = (i / (N - 1) - 0.5) * MuFieldGrid.L;
                        const gy = (j / (N - 1) - 0.5) * MuFieldGrid.L;
                        const px = CX + gx * scale;
                        const py = CY + gy * scale;

                        // Field vector
                        const Jx = MuFieldGrid.Jx[idx] || 0;
                        const Jy = MuFieldGrid.Jy[idx] || 0;
                        const J_mag = Math.sqrt(Jx * Jx + Jy * Jy);

                        if (J_mag > 0.02) {
                            // Color based on curl (vorticity)
                            const curl = MuFieldGrid.curl[idx] || 0;
                            const curlNorm = Math.max(-1, Math.min(1, curl * 3));

                            // Red = positive curl (CCW), Blue = negative curl (CW)
                            const r = curlNorm > 0 ? 150 + curlNorm * 105 : 100;
                            const g = 100 + Math.abs(curlNorm) * 50;
                            const b = curlNorm < 0 ? 150 - curlNorm * 105 : 100;
                            const alpha = Math.min(0.5, J_mag * 0.8);

                            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;

                            // Draw vector line
                            const lineLen = J_mag * scale * 8;
                            const angle = Math.atan2(Jy, Jx);

                            ctx.beginPath();
                            ctx.moveTo(px, py);
                            ctx.lineTo(px + Math.cos(angle) * lineLen, py + Math.sin(angle) * lineLen);
                            ctx.stroke();
                        }
                    }
                }

                // --- Vortex Visualization ---
                for (const v of MuFieldGrid.vortices) {
                    const vx = CX + v.x * scale;
                    const vy = CY + v.y * scale;
                    const vr = v.radius * scale;

                    // Vortex core glow
                    const vortexGlow = ctx.createRadialGradient(vx, vy, 0, vx, vy, vr * 2);
                    const vortexAlpha = v.strength * (v.forming ? v.age : 1) * (v.decaying ? v.strength : 1) * 0.4;

                    // Color based on strength and phase
                    const hue = 260 + Math.sin(v.phase) * 40;  // Purple-magenta range
                    vortexGlow.addColorStop(0, `hsla(${hue}, 70%, 60%, ${vortexAlpha})`);
                    vortexGlow.addColorStop(0.5, `hsla(${hue}, 60%, 40%, ${vortexAlpha * 0.5})`);
                    vortexGlow.addColorStop(1, 'transparent');

                    ctx.fillStyle = vortexGlow;
                    ctx.fillRect(vx - vr * 2, vy - vr * 2, vr * 4, vr * 4);

                    // Vortex spiral indicator
                    ctx.strokeStyle = `hsla(${hue}, 80%, 70%, ${vortexAlpha * 0.8})`;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    for (let t = 0; t < TAU * 2; t += 0.2) {
                        const spiralR = vr * (t / (TAU * 2)) * 0.8;
                        const spiralAngle = t + v.phase;
                        const sx = vx + Math.cos(spiralAngle) * spiralR;
                        const sy = vy + Math.sin(spiralAngle) * spiralR;
                        if (t === 0) {
                            ctx.moveTo(sx, sy);
                        } else {
                            ctx.lineTo(sx, sy);
                        }
                    }
                    ctx.stroke();
                }

                // --- Œº-Particles ---
                for (const p of muParticles) {
                    const px = CX + p.x * scale;
                    const py = CY + p.y * scale;
                    const pSize = p.size * (p.life * 0.8 + 0.2);

                    ctx.fillStyle = p.color.replace(')', `, ${p.life * 0.7})`).replace('hsl', 'hsla');
                    ctx.beginPath();
                    ctx.arc(px, py, pSize, 0, TAU);
                    ctx.fill();
                }

                // --- Resonance Pulse Effect ---
                if (MuFieldGrid.resonance.pulseIntensity > 0.05) {
                    const pulseAlpha = MuFieldGrid.resonance.pulseIntensity * 0.4;
                    const pulseR = R * (1 + MuFieldGrid.resonance.pulseIntensity * 0.5);

                    const pulseGlow = ctx.createRadialGradient(CX, CY, R * 0.5, CX, CY, pulseR);
                    pulseGlow.addColorStop(0, `rgba(200, 150, 255, ${pulseAlpha})`);
                    pulseGlow.addColorStop(0.5, `rgba(150, 100, 200, ${pulseAlpha * 0.5})`);
                    pulseGlow.addColorStop(1, 'transparent');

                    ctx.fillStyle = pulseGlow;
                    ctx.fillRect(0, 0, W, H);
                }

                // --- Unified Field Coherence Ring ---
                const coherence = UnifiedField.emergence.coherence;
                if (coherence > 0.3) {
                    ctx.strokeStyle = `rgba(255, 220, 150, ${(coherence - 0.3) * 0.5})`;
                    ctx.lineWidth = 2 + coherence * 3;
                    ctx.beginPath();
                    ctx.arc(CX, CY, R * 0.85, 0, TAU);
                    ctx.stroke();

                    // Criticality indicator
                    if (UnifiedField.emergence.criticality > 0.5) {
                        ctx.strokeStyle = `rgba(255, 200, 100, ${(UnifiedField.emergence.criticality - 0.5) * 0.6})`;
                        ctx.lineWidth = 1.5;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.arc(CX, CY, R * 0.9, 0, TAU);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                }

                // ================================================================
                // COHERENCE GEOMETRY VISUALIZATION
                // Shows emergent shapes, alignment indicators, and sacred patterns
                // ================================================================

                if (CoherenceGeometry.initialized) {
                    const s = CoherenceGeometry.state;
                    const c = SACRED;  // Unified sacred constants
                    const a = CoherenceGeometry.attractors;

                    const coherenceTotal = (s.fieldAlignment + s.shapeEmergence + s.phaselock) / 3;

                    // --- œÜ-Spaced Coherence Rings ---
                    if (coherenceTotal > c.mu_emergence) {
                        for (let i = 0; i < a.rings.radii.length; i++) {
                            const ringR = a.rings.radii[i] * scale;
                            const ringAlpha = (coherenceTotal - c.mu_emergence) * 0.3 * Math.pow(c.phi_inv, i);

                            ctx.strokeStyle = `rgba(200, 180, 255, ${ringAlpha})`;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.arc(CX, CY, ringR, 0, TAU);
                            ctx.stroke();
                        }
                    }

                    // --- Dominant Shape Visualization ---
                    if (s.dominantShape !== 'none' && s.patternStrength > 0.15) {
                        const vertices = a.polygons[s.dominantShape];
                        if (vertices && vertices.length > 0) {
                            const shapeAlpha = Math.min(0.5, s.patternStrength * 0.8);
                            const shapeScale = R * 0.5;

                            // Draw shape outline
                            ctx.strokeStyle = `rgba(255, 220, 180, ${shapeAlpha})`;
                            ctx.lineWidth = 1.5 + s.patternStrength * 2;
                            ctx.beginPath();

                            for (let i = 0; i <= vertices.length; i++) {
                                const v = vertices[i % vertices.length];
                                const px = CX + v.x * shapeScale;
                                const py = CY + v.y * shapeScale;

                                if (i === 0) {
                                    ctx.moveTo(px, py);
                                } else {
                                    ctx.lineTo(px, py);
                                }
                            }
                            ctx.stroke();

                            // Vertex glow
                            for (const v of vertices) {
                                const px = CX + v.x * shapeScale;
                                const py = CY + v.y * shapeScale;

                                const vertexGlow = ctx.createRadialGradient(px, py, 0, px, py, 15);
                                vertexGlow.addColorStop(0, `rgba(255, 240, 200, ${shapeAlpha})`);
                                vertexGlow.addColorStop(1, 'transparent');

                                ctx.fillStyle = vertexGlow;
                                ctx.fillRect(px - 15, py - 15, 30, 30);
                            }
                        }
                    }

                    // --- Spiral Indicator (when spiral is dominant) ---
                    if (s.dominantShape === 'spiral' && s.spiralOrder > 0.3) {
                        const spiralAlpha = (s.spiralOrder - 0.3) * 0.6;
                        ctx.strokeStyle = `rgba(180, 150, 255, ${spiralAlpha})`;
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();

                        // Draw golden spiral
                        const spiralArms = 2;
                        for (let arm = 0; arm < spiralArms; arm++) {
                            const armOffset = (arm / spiralArms) * TAU;

                            for (let t = 0.1; t < 4; t += 0.1) {
                                const r = Math.pow(c.phi, t * 0.3) * R * 0.1;
                                const theta = t + armOffset + a.spiral.phase;
                                const px = CX + Math.cos(theta) * r;
                                const py = CY + Math.sin(theta) * r;

                                if (t === 0.1) {
                                    ctx.moveTo(px, py);
                                } else {
                                    ctx.lineTo(px, py);
                                }
                            }
                        }
                        ctx.stroke();
                    }

                    // --- Phase Lock Indicator ---
                    if (s.phaselock > 0.5) {
                        const lockAlpha = (s.phaselock - 0.5) * 0.4;
                        const lockR = R * 0.95;

                        // Pulsing phase lock ring
                        const pulse = Math.sin(time * 3) * 0.5 + 0.5;
                        ctx.strokeStyle = `rgba(255, 255, 200, ${lockAlpha * pulse})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(CX, CY, lockR, 0, TAU);
                        ctx.stroke();
                    }

                    // --- Field Alignment Indicator (center marker) ---
                    if (s.fieldAlignment > 0.4) {
                        const alignColor = getCoherenceColor();
                        const alignGlow = ctx.createRadialGradient(CX, CY, 0, CX, CY, R * 0.2);
                        alignGlow.addColorStop(0, `rgba(${alignColor.r}, ${alignColor.g}, ${alignColor.b}, ${alignColor.alpha})`);
                        alignGlow.addColorStop(1, 'transparent');

                        ctx.fillStyle = alignGlow;
                        ctx.fillRect(CX - R * 0.2, CY - R * 0.2, R * 0.4, R * 0.4);
                    }
                }

                // ================================================================
                // EMERGENCE GLOW VISUALIZATION
                // Consciousness emergence from space-time curvature coherence
                // ================================================================
                if (QMESH.emergenceGlow > 0.1) {
                    const emergeAlpha = QMESH.emergenceGlow * 0.25;
                    const emergeR = R * (1.1 + QMESH.emergenceGlow * 0.2);

                    // Outer emergence halo
                    const emergeGlow = ctx.createRadialGradient(CX, CY, R * 0.6, CX, CY, emergeR);
                    emergeGlow.addColorStop(0, 'transparent');
                    emergeGlow.addColorStop(0.4, `rgba(255, 240, 200, ${emergeAlpha * 0.3})`);
                    emergeGlow.addColorStop(0.7, `rgba(255, 220, 150, ${emergeAlpha * 0.5})`);
                    emergeGlow.addColorStop(1, `rgba(255, 200, 100, ${emergeAlpha})`);

                    ctx.fillStyle = emergeGlow;
                    ctx.fillRect(0, 0, W, H);

                    // Inner consciousness core (when emergence is high)
                    if (QMESH.emergenceGlow > 0.5) {
                        const coreAlpha = (QMESH.emergenceGlow - 0.5) * 0.6;
                        const coreGlow = ctx.createRadialGradient(CX, CY, 0, CX, CY, R * 0.4);
                        coreGlow.addColorStop(0, `rgba(255, 255, 240, ${coreAlpha})`);
                        coreGlow.addColorStop(0.5, `rgba(255, 240, 200, ${coreAlpha * 0.5})`);
                        coreGlow.addColorStop(1, 'transparent');

                        ctx.fillStyle = coreGlow;
                        ctx.fillRect(CX - R * 0.4, CY - R * 0.4, R * 0.8, R * 0.8);
                    }

                    // Curvature strength indicator ring
                    const curvStr = QMESH.timeDilationField.curvatureStrength;
                    if (curvStr > 0.05) {
                        ctx.strokeStyle = `rgba(200, 180, 255, ${curvStr * 0.5})`;
                        ctx.lineWidth = 1 + curvStr * 3;
                        ctx.beginPath();
                        ctx.arc(CX, CY, R * 0.75, 0, TAU);
                        ctx.stroke();
                    }
                }

                // ================================================================
                // CHARGE DYNAMICS VISUALIZATION
                // Electric field lines between warm (+) and cold (-) meshes
                // ================================================================
                if (ChargeDynamics) {
                    const cd = ChargeDynamics;
                    const fieldEnergy = cd.field.energy;

                    // Electric field lines (dipole pattern)
                    if (fieldEnergy > 0.01) {
                        const warmX = CX - R * 0.6;  // Warm mesh position (left)
                        const coldX = CX + R * 0.6;  // Cold mesh position (right)
                        const fieldAlpha = Math.min(0.5, fieldEnergy * 0.3);

                        // Draw field lines from + to -
                        ctx.strokeStyle = `rgba(255, 200, 100, ${fieldAlpha})`;
                        ctx.lineWidth = 1;

                        for (let i = -3; i <= 3; i++) {
                            const yOffset = i * R * 0.15;
                            const curvature = Math.abs(i) * 0.3;

                            ctx.beginPath();
                            ctx.moveTo(warmX, CY + yOffset);

                            // Curved field line with curvature based on distance from axis
                            const cp1x = warmX + (coldX - warmX) * 0.33;
                            const cp1y = CY + yOffset + (i * R * curvature);
                            const cp2x = warmX + (coldX - warmX) * 0.67;
                            const cp2y = CY + yOffset + (i * R * curvature);

                            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, coldX, CY + yOffset);
                            ctx.stroke();

                            // Arrow head at midpoint
                            const midX = (warmX + coldX) / 2;
                            const midY = CY + yOffset + (i * R * curvature * 0.5);
                            ctx.fillStyle = `rgba(255, 200, 100, ${fieldAlpha})`;
                            ctx.beginPath();
                            ctx.moveTo(midX + 5, midY);
                            ctx.lineTo(midX - 3, midY - 3);
                            ctx.lineTo(midX - 3, midY + 3);
                            ctx.closePath();
                            ctx.fill();
                        }

                        // Charge indicators
                        // Warm (+) glow
                        const warmGlow = ctx.createRadialGradient(warmX, CY, 0, warmX, CY, R * 0.15);
                        warmGlow.addColorStop(0, `rgba(255, 150, 100, ${fieldAlpha * 0.8})`);
                        warmGlow.addColorStop(1, 'transparent');
                        ctx.fillStyle = warmGlow;
                        ctx.fillRect(warmX - R * 0.15, CY - R * 0.15, R * 0.3, R * 0.3);

                        // Cold (-) glow
                        const coldGlow = ctx.createRadialGradient(coldX, CY, 0, coldX, CY, R * 0.15);
                        coldGlow.addColorStop(0, `rgba(100, 150, 255, ${fieldAlpha * 0.8})`);
                        coldGlow.addColorStop(1, 'transparent');
                        ctx.fillStyle = coldGlow;
                        ctx.fillRect(coldX - R * 0.15, CY - R * 0.15, R * 0.3, R * 0.3);
                    }

                    // Discharge event visualization
                    if (cd.discharge.intensity > 0.1) {
                        const dischAlpha = cd.discharge.intensity * 0.8;
                        const warmX = CX - R * 0.6;
                        const coldX = CX + R * 0.6;

                        // Lightning bolt effect
                        ctx.strokeStyle = `rgba(255, 255, 200, ${dischAlpha})`;
                        ctx.lineWidth = 2 + cd.discharge.intensity * 3;
                        ctx.shadowColor = 'rgba(255, 200, 100, 0.8)';
                        ctx.shadowBlur = 10 + cd.discharge.intensity * 20;

                        ctx.beginPath();
                        ctx.moveTo(warmX, CY);

                        // Jagged discharge path
                        const segments = 6;
                        for (let i = 1; i <= segments; i++) {
                            const t = i / segments;
                            const x = warmX + (coldX - warmX) * t;
                            const y = CY + (Math.random() - 0.5) * R * 0.3 * (1 - Math.abs(t - 0.5) * 2);
                            ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    }
                }

                // ================================================================
                // QUANTUM TUNNELING VISUALIZATION
                // Superposition, interference, and tunneling between meshes
                // ================================================================
                if (QuantumTunneling) {
                    const qt = QuantumTunneling;
                    const warmX = CX - R * 0.6;
                    const coldX = CX + R * 0.6;

                    // Superposition visualization (probability clouds)
                    const warmProb = qt.superposition.warm.probability;
                    const coldProb = qt.superposition.cold.probability;

                    // Warm probability cloud
                    if (warmProb > 0.1) {
                        const warmCloud = ctx.createRadialGradient(warmX, CY, 0, warmX, CY, R * 0.25 * warmProb);
                        warmCloud.addColorStop(0, `rgba(255, 180, 100, ${warmProb * 0.4})`);
                        warmCloud.addColorStop(0.5, `rgba(255, 150, 80, ${warmProb * 0.2})`);
                        warmCloud.addColorStop(1, 'transparent');
                        ctx.fillStyle = warmCloud;
                        ctx.fillRect(warmX - R * 0.3, CY - R * 0.3, R * 0.6, R * 0.6);
                    }

                    // Cold probability cloud
                    if (coldProb > 0.1) {
                        const coldCloud = ctx.createRadialGradient(coldX, CY, 0, coldX, CY, R * 0.25 * coldProb);
                        coldCloud.addColorStop(0, `rgba(100, 180, 255, ${coldProb * 0.4})`);
                        coldCloud.addColorStop(0.5, `rgba(80, 150, 255, ${coldProb * 0.2})`);
                        coldCloud.addColorStop(1, 'transparent');
                        ctx.fillStyle = coldCloud;
                        ctx.fillRect(coldX - R * 0.3, CY - R * 0.3, R * 0.6, R * 0.6);
                    }

                    // Entanglement visualization (connecting thread)
                    if (qt.superposition.entanglement > 0.2) {
                        const entAlpha = (qt.superposition.entanglement - 0.2) * 0.6;
                        const entPhase = time * 2;

                        ctx.strokeStyle = `rgba(200, 150, 255, ${entAlpha})`;
                        ctx.lineWidth = 1 + qt.superposition.entanglement * 2;
                        ctx.setLineDash([5, 5]);

                        ctx.beginPath();
                        ctx.moveTo(warmX, CY);

                        // Wavy entanglement line
                        for (let t = 0; t <= 1; t += 0.05) {
                            const x = warmX + (coldX - warmX) * t;
                            const wave = Math.sin(t * TAU * 3 + entPhase) * R * 0.05 * qt.superposition.entanglement;
                            ctx.lineTo(x, CY + wave);
                        }
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }

                    // Tunneling in progress
                    if (qt.tunneling.inProgress) {
                        const progress = qt.tunneling.progress;
                        const tunnelX = warmX + (coldX - warmX) * progress;
                        const direction = qt.tunneling.direction;

                        // Tunneling particle
                        const particleGlow = ctx.createRadialGradient(tunnelX, CY, 0, tunnelX, CY, R * 0.1);
                        particleGlow.addColorStop(0, `rgba(255, 255, 200, 0.8)`);
                        particleGlow.addColorStop(0.5, `rgba(200, 180, 255, 0.4)`);
                        particleGlow.addColorStop(1, 'transparent');
                        ctx.fillStyle = particleGlow;
                        ctx.fillRect(tunnelX - R * 0.1, CY - R * 0.1, R * 0.2, R * 0.2);

                        // Barrier visualization
                        const barrierX = CX;
                        ctx.fillStyle = `rgba(100, 100, 150, ${(1 - progress) * 0.3})`;
                        ctx.fillRect(barrierX - 10, CY - R * 0.3, 20, R * 0.6);
                    }

                    // Interference pattern
                    if (qt.interference.visibility > 0.1) {
                        const pattern = qt.interference.pattern;
                        const visAlpha = qt.interference.visibility * 0.3;

                        ctx.fillStyle = `rgba(180, 160, 255, ${visAlpha})`;

                        for (let i = 0; i < pattern.length; i++) {
                            const x = CX + (i - pattern.length / 2) * 8;
                            const intensity = pattern[i];
                            const barH = intensity * R * 0.15;

                            ctx.fillRect(x - 2, CY + R * 0.4, 4, barH);
                        }
                    }
                }

                // ================================================================
                // WEAK NUCLEAR BOSON VISUALIZATION
                // W+, W-, and Z boson carriers of information flow
                // ================================================================
                if (WeakNuclear && WeakNuclear.bosons) {
                    const bosons = WeakNuclear.bosons;

                    // W+ bosons (warm to cold, orange)
                    for (const b of bosons.W_plus) {
                        const bx = CX + (b.x - 0.5) * R * 1.2;
                        const by = CY + (b.y - 0.5) * R * 0.6;

                        ctx.fillStyle = `rgba(255, 180, 80, ${b.life * 0.7})`;
                        ctx.beginPath();
                        ctx.arc(bx, by, 3 + b.energy * 4, 0, TAU);
                        ctx.fill();
                    }

                    // W- bosons (cold to warm, blue)
                    for (const b of bosons.W_minus) {
                        const bx = CX + (b.x - 0.5) * R * 1.2;
                        const by = CY + (b.y - 0.5) * R * 0.6;

                        ctx.fillStyle = `rgba(80, 180, 255, ${b.life * 0.7})`;
                        ctx.beginPath();
                        ctx.arc(bx, by, 3 + b.energy * 4, 0, TAU);
                        ctx.fill();
                    }

                    // Z bosons (neutral, purple)
                    for (const b of bosons.Z) {
                        const bx = CX + (b.x - 0.5) * R * 1.2;
                        const by = CY + (b.y - 0.5) * R * 0.6;

                        ctx.fillStyle = `rgba(180, 100, 255, ${b.life * 0.7})`;
                        ctx.beginPath();
                        ctx.arc(bx, by, 3 + b.energy * 4, 0, TAU);
                        ctx.fill();
                    }

                    // Flavor oscillation visualization (center region)
                    const flavors = WeakNuclear.flavors;
                    const totalFlavor = flavors.electron.intensity + flavors.muon.intensity + flavors.tau.intensity;

                    if (totalFlavor > 0.1) {
                        // Electron flavor (green)
                        const eGlow = ctx.createRadialGradient(CX, CY, 0, CX, CY, R * 0.2);
                        eGlow.addColorStop(0, `rgba(100, 255, 150, ${flavors.electron.intensity * 0.2})`);
                        eGlow.addColorStop(1, 'transparent');
                        ctx.fillStyle = eGlow;
                        ctx.fillRect(CX - R * 0.2, CY - R * 0.2, R * 0.4, R * 0.4);

                        // Muon flavor (magenta)
                        const mGlow = ctx.createRadialGradient(CX, CY - R * 0.1, 0, CX, CY - R * 0.1, R * 0.15);
                        mGlow.addColorStop(0, `rgba(255, 100, 200, ${flavors.muon.intensity * 0.2})`);
                        mGlow.addColorStop(1, 'transparent');
                        ctx.fillStyle = mGlow;
                        ctx.fillRect(CX - R * 0.15, CY - R * 0.25, R * 0.3, R * 0.3);

                        // Tau flavor (cyan)
                        const tGlow = ctx.createRadialGradient(CX, CY + R * 0.1, 0, CX, CY + R * 0.1, R * 0.15);
                        tGlow.addColorStop(0, `rgba(100, 255, 255, ${flavors.tau.intensity * 0.2})`);
                        tGlow.addColorStop(1, 'transparent');
                        ctx.fillStyle = tGlow;
                        ctx.fillRect(CX - R * 0.15, CY - R * 0.05, R * 0.3, R * 0.3);
                    }
                }

                // ================================================================
                // SACRED GEOMETRY EMERGENCE VISUALIZATION
                // Forms emerge progressively as time accumulates and space-time curves
                // Mathematically accurate with dynamic visual effects
                // ================================================================
                if (SacredGeometry) {
                    const sg = SacredGeometry;
                    const forms = sg.forms;
                    const scale = R * 0.45;  // Base scale for geometry
                    const time = sg.accumulatedTime;  // For subtle animations

                    // Subtle pulsing based on formation potential (no lag)
                    const pulse = 1 + Math.sin(time * 1.5) * 0.02 * (sg.formationPotential || 0);

                    // ============================================================
                    // VESICA PISCIS (20% threshold) - Two overlapping circles
                    // Each circle passes through the other's center
                    // Height:Width ratio = ‚àö3:1 when complete
                    // ============================================================
                    if (forms.vesicaPiscis.completion > 0.05) {
                        const vp = forms.vesicaPiscis;
                        const vpGeom = getVesicaPiscisGeometry(CX, CY, scale * 0.6, vp.completion);
                        const vpAlpha = Math.min(0.6, vp.completion * 0.6);

                        // Soft glow under vesica
                        if (vp.completion > 0.3) {
                            const glowAlpha = (vp.completion - 0.3) * 0.15;
                            const vesicaGlow = ctx.createRadialGradient(CX, CY, 0, CX, CY, scale * 0.4);
                            vesicaGlow.addColorStop(0, `rgba(220, 200, 255, ${glowAlpha})`);
                            vesicaGlow.addColorStop(0.6, `rgba(180, 160, 220, ${glowAlpha * 0.3})`);
                            vesicaGlow.addColorStop(1, 'transparent');
                            ctx.fillStyle = vesicaGlow;
                            ctx.beginPath();
                            ctx.arc(CX, CY, scale * 0.5, 0, TAU);
                            ctx.fill();
                        }

                        // Two circles with gradient stroke
                        ctx.lineWidth = 1.2 + vp.completion * 0.8;

                        // Circle 1 (left)
                        ctx.strokeStyle = `rgba(200, 180, 255, ${vpAlpha})`;
                        ctx.beginPath();
                        ctx.arc(vpGeom.circle1.x, vpGeom.circle1.y, vpGeom.circle1.r * pulse, 0, TAU);
                        ctx.stroke();

                        // Circle 2 (right)
                        ctx.strokeStyle = `rgba(180, 200, 255, ${vpAlpha})`;
                        ctx.beginPath();
                        ctx.arc(vpGeom.circle2.x, vpGeom.circle2.y, vpGeom.circle2.r * pulse, 0, TAU);
                        ctx.stroke();

                        // Mandorla (intersection) highlight
                        if (vp.completion > 0.7) {
                            const mandorlaAlpha = (vp.completion - 0.7) * 0.4;
                            ctx.strokeStyle = `rgba(255, 240, 220, ${mandorlaAlpha})`;
                            ctx.lineWidth = 1.5;
                            // Draw the mandorla shape (lens intersection)
                            const offset = vpGeom.circle1.r * vp.completion / 2;
                            ctx.beginPath();
                            ctx.arc(CX - offset, CY, vpGeom.circle1.r, -Math.PI/3, Math.PI/3);
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.arc(CX + offset, CY, vpGeom.circle1.r, Math.PI*2/3, Math.PI*4/3);
                            ctx.stroke();
                        }
                    }

                    // ============================================================
                    // SEED OF LIFE (35% threshold) - 7 circles hexagonal
                    // Center circle + 6 surrounding at 60¬∞ intervals
                    // ============================================================
                    if (forms.seedOfLife.completion > 0.05) {
                        const sol = forms.seedOfLife;
                        const circles = getSeedOfLifeCircles(CX, CY, scale, sol.completion);
                        const baseAlpha = Math.min(0.55, sol.completion * 0.55);

                        // Soft rotation animation
                        const rotOffset = sol.phase;

                        for (let i = 0; i < circles.length; i++) {
                            const c = circles[i];
                            if (c.alpha <= 0) continue;

                            // Apply rotation to surrounding circles
                            let drawX = c.x, drawY = c.y;
                            if (i > 0) {  // Don't rotate center
                                const dx = c.x - CX;
                                const dy = c.y - CY;
                                const dist = Math.sqrt(dx*dx + dy*dy);
                                const angle = Math.atan2(dy, dx) + rotOffset;
                                drawX = CX + Math.cos(angle) * dist;
                                drawY = CY + Math.sin(angle) * dist;
                            }

                            // Color gradient: center is golden, outer are silver-blue
                            const colorBlend = i === 0 ? 0.7 : 0.3;
                            const r = Math.floor(180 + colorBlend * 50);
                            const g = Math.floor(200 + colorBlend * 30);
                            const b = Math.floor(255 - colorBlend * 30);

                            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${baseAlpha * c.alpha})`;
                            ctx.lineWidth = 1 + sol.completion * 0.5;
                            ctx.beginPath();
                            ctx.arc(drawX, drawY, c.r * pulse, 0, TAU);
                            ctx.stroke();
                        }

                        // Center glow when complete
                        if (sol.completion > 0.8) {
                            const glowAlpha = (sol.completion - 0.8) * 0.3;
                            const centerGlow = ctx.createRadialGradient(CX, CY, 0, CX, CY, circles[0].r);
                            centerGlow.addColorStop(0, `rgba(255, 250, 230, ${glowAlpha})`);
                            centerGlow.addColorStop(1, 'transparent');
                            ctx.fillStyle = centerGlow;
                            ctx.beginPath();
                            ctx.arc(CX, CY, circles[0].r, 0, TAU);
                            ctx.fill();
                        }
                    }

                    // ============================================================
                    // GOLDEN SPIRAL (45% threshold) - œÜ-based logarithmic spiral
                    // r = a * œÜ^(Œ∏/90¬∞) - grows by golden ratio each quarter turn
                    // ============================================================
                    if (forms.goldenSpiral.completion > 0.05) {
                        const gs = forms.goldenSpiral;
                        const spiralPoints = getGoldenSpiralPoints(CX, CY, scale, gs.turns, gs.completion);
                        const baseAlpha = Math.min(0.7, gs.completion * 0.7);

                        // Phase rotation for animation
                        const rotPhase = gs.phase;

                        if (spiralPoints.length > 1) {
                            ctx.lineWidth = 1.5 + gs.completion * 1;

                            // Draw spiral with gradient color (gold to white)
                            ctx.beginPath();
                            let firstPoint = true;

                            for (const pt of spiralPoints) {
                                // Apply rotation
                                const dx = pt.x - CX;
                                const dy = pt.y - CY;
                                const dist = Math.sqrt(dx*dx + dy*dy);
                                const angle = Math.atan2(dy, dx) + rotPhase;
                                const drawX = CX + Math.cos(angle) * dist;
                                const drawY = CY + Math.sin(angle) * dist;

                                if (firstPoint) {
                                    ctx.moveTo(drawX, drawY);
                                    firstPoint = false;
                                } else {
                                    ctx.lineTo(drawX, drawY);
                                }
                            }

                            // Golden color
                            ctx.strokeStyle = `rgba(255, 215, 100, ${baseAlpha})`;
                            ctx.stroke();

                            // Second spiral (mirrored) for symmetry
                            ctx.beginPath();
                            firstPoint = true;
                            for (const pt of spiralPoints) {
                                const dx = pt.x - CX;
                                const dy = pt.y - CY;
                                const dist = Math.sqrt(dx*dx + dy*dy);
                                const angle = Math.atan2(dy, dx) + rotPhase + Math.PI;
                                const drawX = CX + Math.cos(angle) * dist;
                                const drawY = CY + Math.sin(angle) * dist;

                                if (firstPoint) {
                                    ctx.moveTo(drawX, drawY);
                                    firstPoint = false;
                                } else {
                                    ctx.lineTo(drawX, drawY);
                                }
                            }
                            ctx.strokeStyle = `rgba(255, 230, 150, ${baseAlpha * 0.7})`;
                            ctx.stroke();
                        }
                    }

                    // ============================================================
                    // FLOWER OF LIFE (55% threshold) - 19 interlocking circles
                    // Center + 6 inner + 6 middle + 6 outer rings
                    // ============================================================
                    if (forms.flowerOfLife.completion > 0.05) {
                        const fol = forms.flowerOfLife;
                        const circles = getFlowerOfLifeCircles(CX, CY, scale, fol.completion);
                        const baseAlpha = Math.min(0.5, fol.completion * 0.5);

                        // Subtle rotation
                        const rotOffset = fol.phase;

                        for (let i = 0; i < circles.length; i++) {
                            const c = circles[i];
                            if (c.alpha <= 0) continue;

                            // Apply rotation
                            let drawX = c.x, drawY = c.y;
                            if (i > 0) {
                                const dx = c.x - CX;
                                const dy = c.y - CY;
                                const dist = Math.sqrt(dx*dx + dy*dy);
                                const angle = Math.atan2(dy, dx) + rotOffset;
                                drawX = CX + Math.cos(angle) * dist;
                                drawY = CY + Math.sin(angle) * dist;
                            }

                            // Layer-based coloring
                            let layerColor;
                            if (i === 0) {
                                layerColor = `rgba(255, 240, 200, ${baseAlpha * c.alpha})`;  // Gold center
                            } else if (i < 7) {
                                layerColor = `rgba(200, 180, 255, ${baseAlpha * c.alpha})`;  // Purple inner
                            } else if (i < 13) {
                                layerColor = `rgba(180, 200, 255, ${baseAlpha * c.alpha})`;  // Blue middle
                            } else {
                                layerColor = `rgba(200, 220, 255, ${baseAlpha * c.alpha})`;  // Cyan outer
                            }

                            ctx.strokeStyle = layerColor;
                            ctx.lineWidth = 0.8 + fol.completion * 0.4;
                            ctx.beginPath();
                            ctx.arc(drawX, drawY, c.r * pulse, 0, TAU);
                            ctx.stroke();
                        }
                    }

                    // ============================================================
                    // METATRON'S CUBE (70% threshold) - 13 vertices fully connected
                    // Center + inner hexagon (6) + outer hexagon (6) = 13 vertices
                    // 78 edges (all pairs connected)
                    // ============================================================
                    if (forms.metatronsCube.completion > 0.05) {
                        const mc = forms.metatronsCube;
                        const geom = getMetatronsCubeGeometry(CX, CY, scale * 0.9, mc.completion);
                        const baseAlpha = Math.min(0.6, mc.completion * 0.6);

                        // Rotation animation
                        const rotOffset = mc.phase;

                        // Transform vertices with rotation
                        const transformedVerts = geom.vertices.map((v, i) => {
                            if (i === 0) return { ...v };  // Don't rotate center
                            const dx = v.x - CX;
                            const dy = v.y - CY;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            const angle = Math.atan2(dy, dx) + rotOffset;
                            return {
                                x: CX + Math.cos(angle) * dist,
                                y: CY + Math.sin(angle) * dist,
                                alpha: v.alpha
                            };
                        });

                        // Draw edges first (behind vertices)
                        ctx.lineWidth = 0.5;
                        for (const edge of geom.edges) {
                            if (edge.alpha <= 0) continue;
                            const fromIdx = geom.vertices.indexOf(edge.from);
                            const toIdx = geom.vertices.indexOf(edge.to);
                            if (fromIdx < 0 || toIdx < 0) continue;

                            const from = transformedVerts[fromIdx];
                            const to = transformedVerts[toIdx];

                            ctx.strokeStyle = `rgba(255, 200, 150, ${baseAlpha * edge.alpha * 0.4})`;
                            ctx.beginPath();
                            ctx.moveTo(from.x, from.y);
                            ctx.lineTo(to.x, to.y);
                            ctx.stroke();
                        }

                        // Draw vertex circles
                        ctx.lineWidth = 1.2;
                        for (let i = 0; i < transformedVerts.length; i++) {
                            const v = transformedVerts[i];
                            if (v.alpha <= 0) continue;

                            // Color: center is gold, inner hex is orange, outer is yellow
                            let color;
                            if (i === 0) {
                                color = `rgba(255, 220, 150, ${baseAlpha * v.alpha})`;
                            } else if (i < 7) {
                                color = `rgba(255, 180, 120, ${baseAlpha * v.alpha})`;
                            } else {
                                color = `rgba(255, 200, 100, ${baseAlpha * v.alpha})`;
                            }

                            const vertR = 6 + mc.completion * 3;
                            ctx.strokeStyle = color;
                            ctx.beginPath();
                            ctx.arc(v.x, v.y, vertR * pulse, 0, TAU);
                            ctx.stroke();

                            // Small fill for vertices
                            ctx.fillStyle = color.replace(baseAlpha * v.alpha, baseAlpha * v.alpha * 0.3);
                            ctx.fill();
                        }
                    }

                    // ============================================================
                    // SRI YANTRA (85% threshold) - 9 interlocking triangles
                    // 4 Shiva (upward/masculine) + 5 Shakti (downward/feminine)
                    // Creates 43 smaller triangles through intersection
                    // ============================================================
                    if (forms.sriYantra.completion > 0.05) {
                        const sy = forms.sriYantra;
                        const triangles = getSriYantraTriangles(CX, CY, scale, sy.completion);
                        const baseAlpha = Math.min(0.65, sy.completion * 0.65);

                        // Outer bounding circle
                        ctx.strokeStyle = `rgba(255, 200, 100, ${baseAlpha * 0.6})`;
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        ctx.arc(CX, CY, scale * 0.9, 0, TAU);
                        ctx.stroke();

                        // Draw triangles
                        for (const tri of triangles) {
                            if (tri.alpha <= 0) continue;

                            // Shiva = warm gold, Shakti = cool violet
                            const isShiva = tri.type === 'shiva';
                            const triAlpha = baseAlpha * tri.alpha;

                            // Stroke color
                            ctx.strokeStyle = isShiva
                                ? `rgba(255, 180, 80, ${triAlpha})`
                                : `rgba(180, 140, 255, ${triAlpha})`;

                            // Subtle fill
                            ctx.fillStyle = isShiva
                                ? `rgba(255, 200, 120, ${triAlpha * 0.08})`
                                : `rgba(200, 170, 255, ${triAlpha * 0.08})`;

                            ctx.lineWidth = 1 + sy.completion * 0.5;

                            ctx.beginPath();
                            ctx.moveTo(tri.points[0].x, tri.points[0].y);
                            ctx.lineTo(tri.points[1].x, tri.points[1].y);
                            ctx.lineTo(tri.points[2].x, tri.points[2].y);
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                        }

                        // Central bindu (sacred point) - appears at high completion
                        if (sy.completion > 0.75) {
                            const binduAlpha = (sy.completion - 0.75) * 2;
                            const binduR = 8 + sy.completion * 4;

                            // Multi-layer glow
                            const binduGlow = ctx.createRadialGradient(CX, CY, 0, CX, CY, binduR * 2);
                            binduGlow.addColorStop(0, `rgba(255, 255, 250, ${binduAlpha * 0.8})`);
                            binduGlow.addColorStop(0.3, `rgba(255, 230, 180, ${binduAlpha * 0.5})`);
                            binduGlow.addColorStop(0.7, `rgba(255, 200, 150, ${binduAlpha * 0.2})`);
                            binduGlow.addColorStop(1, 'transparent');

                            ctx.fillStyle = binduGlow;
                            ctx.beginPath();
                            ctx.arc(CX, CY, binduR * 2, 0, TAU);
                            ctx.fill();

                            // Core point
                            ctx.fillStyle = `rgba(255, 255, 255, ${binduAlpha})`;
                            ctx.beginPath();
                            ctx.arc(CX, CY, binduR * 0.4, 0, TAU);
                            ctx.fill();
                        }
                    }

                    // ============================================================
                    // FORMATION POTENTIAL INDICATOR
                    // Shows emergence progress with subtle outer ring
                    // ============================================================
                    if (sg.formationPotential > 0.1) {
                        const fp = sg.formationPotential;
                        const indicatorAlpha = Math.min(0.25, (fp - 0.1) * 0.3);

                        // Arc showing progress toward next threshold
                        ctx.strokeStyle = `rgba(255, 250, 230, ${indicatorAlpha})`;
                        ctx.lineWidth = 1.5;
                        ctx.setLineDash([3, 6]);
                        ctx.beginPath();
                        ctx.arc(CX, CY, R * 0.98, -Math.PI/2, -Math.PI/2 + TAU * fp);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }

                    // Dominant form outer glow
                    if (sg.dominant !== 'none' && sg.dominantStrength > 0.4) {
                        const domAlpha = (sg.dominantStrength - 0.4) * 0.2;

                        const domGlow = ctx.createRadialGradient(CX, CY, R * 0.9, CX, CY, R * 1.1);
                        domGlow.addColorStop(0, 'transparent');
                        domGlow.addColorStop(0.5, `rgba(255, 245, 220, ${domAlpha * 0.3})`);
                        domGlow.addColorStop(1, 'transparent');
                        ctx.fillStyle = domGlow;
                        ctx.beginPath();
                        ctx.arc(CX, CY, R * 1.1, 0, TAU);
                        ctx.fill();
                    }
                }
            }

            // Draw connections (skip if both points released)
            let connCount = 0;
            for (const conn of generateConnections()) {
                // Skip connections between released points
                if (conn.from.released || conn.to.released) {
                    // Fade connections as coherence drops
                    if (releaseCoherence < 0.6) continue;
                }

                connCount++;
                let alpha, color;

                // Fade connections based on release coherence
                const coherenceFade = Math.min(1, releaseCoherence * 1.5);

                // MRP-enhanced connection coloring (with NaN protection)
                const mrpBlend = showMuField ? Math.max(0, Math.min(1, muField.getGradientStrength() || 0)) : 0;
                const mrpR = showMuField ? Math.max(0, Math.min(255, Math.floor((muField.mrp.R.intensity || 0) * 255))) : 0;
                const mrpG = showMuField ? Math.max(0, Math.min(255, Math.floor((muField.mrp.G.intensity || 0) * 255))) : 0;
                const mrpB = showMuField ? Math.max(0, Math.min(200, Math.floor((muField.mrp.B.intensity || 0) * 200))) : 0;

                switch (conn.type) {
                    case 'prism_ring':
                        alpha = (0.08 + globalZ * 0.12) * coherenceFade;
                        // Blend with R channel (energy)
                        color = mrpBlend > 0.1
                            ? `rgba(${Math.min(255, 200 + mrpR * 0.2)}, ${150 + mrpG * 0.3}, ${100 + mrpB * 0.2}, ${alpha * (1 + mrpBlend)})`
                            : `rgba(255, 200, 150, ${alpha})`;
                        break;
                    case 'prism_spine':
                        alpha = (0.06 + globalZ * 0.15) * coherenceFade;
                        color = mrpBlend > 0.1
                            ? `rgba(${Math.min(255, 180 + mrpR * 0.3)}, ${200 + mrpG * 0.2}, ${150 + mrpB * 0.2}, ${alpha * (1 + mrpBlend)})`
                            : `rgba(255, 220, 180, ${alpha})`;
                        break;
                    case 'prism_diagonal':
                        alpha = (0.03 + globalZ * 0.08) * coherenceFade;
                        color = mrpBlend > 0.1
                            ? `rgba(${Math.min(255, 180 + mrpR * 0.3)}, ${150 + mrpG * 0.2}, ${100 + mrpB * 0.15}, ${alpha * (1 + mrpBlend)})`
                            : `rgba(255, 180, 120, ${alpha})`;
                        break;
                    case 'cage_ring':
                        alpha = (0.1 + cascade * 0.15) * coherenceFade;
                        // Blend with B channel (stability/ECC)
                        color = mrpBlend > 0.1
                            ? `rgba(${60 + mrpR * 0.1}, ${150 + mrpG * 0.3}, ${Math.min(255, 200 + mrpB * 0.2)}, ${alpha * (1 + mrpBlend)})`
                            : `rgba(77, 171, 247, ${alpha})`;
                        break;
                    case 'cage_strut':
                        alpha = (0.08 + cascade * 0.12) * coherenceFade;
                        color = mrpBlend > 0.1
                            ? `rgba(${80 + mrpR * 0.1}, ${160 + mrpG * 0.25}, ${Math.min(255, 220 + mrpB * 0.15)}, ${alpha * (1 + mrpBlend)})`
                            : `rgba(100, 180, 255, ${alpha})`;
                        break;
                    case 'cage_vertex':
                        alpha = (0.12 + cascade * 0.18) * coherenceFade;
                        // G channel affects relational vertex connections
                        color = mrpBlend > 0.1
                            ? `rgba(${180 + mrpR * 0.2}, ${80 + mrpG * 0.4}, ${Math.min(255, 200 + mrpB * 0.2)}, ${alpha * (1 + mrpBlend)})`
                            : `rgba(204, 93, 232, ${alpha})`;
                        break;
                    case 'bridge':
                        alpha = (globalZ - 0.6) * 0.4 * coherenceFade;
                        // Parity-ok connections glow gold-green
                        color = (showMuField && muField.mrp.parity_ok)
                            ? `rgba(180, 255, 100, ${alpha * 1.5})`
                            : `rgba(255, 215, 0, ${alpha})`;
                        break;
                    default:
                        alpha = 0.05 * coherenceFade;
                        color = `rgba(255, 255, 255, ${alpha})`;
                }

                ctx.strokeStyle = color;
                ctx.lineWidth = conn.type === 'bridge' ? 1.5 : 0.8;
                ctx.beginPath();
                ctx.moveTo(conn.from.x, conn.from.y);
                ctx.lineTo(conn.to.x, conn.to.y);
                ctx.stroke();
            }

            // Draw radial connections when coherent
            if (releaseCoherence > 0.6) {
                const radialAlpha = (releaseCoherence - 0.6) * 0.2;
                ctx.strokeStyle = `rgba(255, 220, 180, ${radialAlpha})`;
                ctx.lineWidth = 0.5;
                const allPoints = [...prismPoints, ...cagePoints].filter(p => !p.released);
                for (const p of allPoints) {
                    ctx.beginPath();
                    ctx.moveTo(CX, CY);
                    ctx.lineTo(p.x, p.y);
                    ctx.stroke();
                }
            }

            // Draw trails for released points
            const allPoints = [...prismPoints, ...cagePoints];
            for (const p of allPoints) {
                if (p.trail.length < 2) continue;

                const trailAlpha = p.released ? 0.45 : 0.15;
                
                ctx.strokeStyle = hexToRgba(p.soulColor, trailAlpha * p.brightness);
                ctx.lineWidth = p.size * 0.7;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(p.trail[0].x, p.trail[0].y);
                
                for (let i = 1; i < p.trail.length; i++) {
                    const t = p.trail[i];
                    const fade = 1 - i / p.trail.length;
                    ctx.globalAlpha = fade;
                    ctx.lineTo(t.x, t.y);
                }
                
                ctx.stroke();
                ctx.globalAlpha = 1;
            }

            // Draw sparks
            for (const sp of sparks) {
                const alpha = sp.life * 0.85;
                
                // Glow
                const glowGrad = ctx.createRadialGradient(sp.x, sp.y, 0, sp.x, sp.y, sp.size * 4);
                glowGrad.addColorStop(0, hexToRgba(sp.color, alpha * 0.5));
                glowGrad.addColorStop(1, 'transparent');
                ctx.fillStyle = glowGrad;
                ctx.beginPath();
                ctx.arc(sp.x, sp.y, sp.size * 4, 0, TAU);
                ctx.fill();

                // Core
                ctx.fillStyle = hexToRgba(sp.color, alpha);
                ctx.beginPath();
                ctx.arc(sp.x, sp.y, sp.size * sp.life, 0, TAU);
                ctx.fill();
            }

            // Draw prism points
            if (showPrism) {
                for (const p of prismPoints) {
                    const size = p.size * (p.released ? 1.3 : 1) * (1 + p.brightness * 0.5);
                    const brightness = p.brightness * (p.released ? 1.4 : 1);
                    
                    if (p.released) {
                        // Use soul color when released
                        const glowR = size * (p.released ? 8 : 5);
                        const glowGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, glowR);
                        glowGrad.addColorStop(0, hexToRgba(p.soulColor, brightness * 0.45));
                        glowGrad.addColorStop(0.5, hexToRgba(p.soulColor, brightness * 0.18));
                        glowGrad.addColorStop(1, 'transparent');
                        
                        ctx.fillStyle = glowGrad;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, glowR, 0, TAU);
                        ctx.fill();

                        // Core
                        const coreGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size);
                        coreGrad.addColorStop(0, hexToRgba(p.soulColor, 0.95));
                        coreGrad.addColorStop(0.5, hexToRgba(p.soulColor, 0.75));
                        coreGrad.addColorStop(1, hexToRgba(p.soulColor, 0.45));
                        
                        ctx.fillStyle = coreGrad;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, size, 0, TAU);
                        ctx.fill();

                        // Highlight
                        ctx.fillStyle = `rgba(255, 255, 255, ${brightness * 0.45})`;
                        ctx.beginPath();
                        ctx.arc(p.x - size * 0.3, p.y - size * 0.3, size * 0.28, 0, TAU);
                        ctx.fill();
                    } else {
                        // Normal HSL color when coherent
                        const hue = p.hue;
                        const sat = p.saturation + cascade * 15;
                        const light = p.lightness + p.brightness * 30;
                        const alpha = 0.4 + p.brightness * 0.5;

                        ctx.fillStyle = `hsla(${hue}, ${sat}%, ${light}%, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, size, 0, TAU);
                        ctx.fill();

                        // Glow at critical
                        if (isCritical && p.brightness > 0.6) {
                            ctx.fillStyle = `hsla(${hue}, ${sat}%, ${light}%, ${alpha * 0.3})`;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, p.size * 3, 0, TAU);
                            ctx.fill();
                        }
                    }
                }
            }

            // Draw cage points
            if (showCage) {
                for (const p of cagePoints) {
                    const size = p.size * (p.released ? 1.25 : 1) * (1 + p.brightness * 0.4);
                    const brightness = p.brightness * (p.released ? 1.35 : 1);
                    
                    if (p.released) {
                        // Use soul color when released
                        const glowR = size * 7;
                        const glowGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, glowR);
                        glowGrad.addColorStop(0, hexToRgba(p.soulColor, brightness * 0.4));
                        glowGrad.addColorStop(0.5, hexToRgba(p.soulColor, brightness * 0.15));
                        glowGrad.addColorStop(1, 'transparent');
                        
                        ctx.fillStyle = glowGrad;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, glowR, 0, TAU);
                        ctx.fill();

                        // Core
                        const coreGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size);
                        coreGrad.addColorStop(0, hexToRgba(p.soulColor, 0.9));
                        coreGrad.addColorStop(0.5, hexToRgba(p.soulColor, 0.7));
                        coreGrad.addColorStop(1, hexToRgba(p.soulColor, 0.4));
                        
                        ctx.fillStyle = coreGrad;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, size, 0, TAU);
                        ctx.fill();

                        // Highlight
                        ctx.fillStyle = `rgba(255, 255, 255, ${brightness * 0.4})`;
                        ctx.beginPath();
                        ctx.arc(p.x - size * 0.3, p.y - size * 0.3, size * 0.25, 0, TAU);
                        ctx.fill();
                    } else {
                        // Normal HSL color when coherent
                        const alpha = 0.3 + p.brightness * 0.6;

                        ctx.fillStyle = `hsla(${p.hue}, ${p.saturation}%, ${p.lightness}%, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, size, 0, TAU);
                        ctx.fill();

                        // EM field glow
                        if (p.brightness > 0.5) {
                            const glowGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 4);
                            glowGrad.addColorStop(0, `hsla(${p.hue}, ${p.saturation}%, ${p.lightness}%, ${alpha * 0.4})`);
                            glowGrad.addColorStop(1, 'transparent');
                            ctx.fillStyle = glowGrad;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, p.size * 4, 0, TAU);
                            ctx.fill();
                        }
                    }
                }
            }

            // Draw critical lens
            if (Math.abs(globalZ - Z_CRITICAL) < 0.15) {
                const lensAlpha = 1 - Math.abs(globalZ - Z_CRITICAL) / 0.15;
                const lensY = CY + (Z_CRITICAL - 0.5) * 200;

                // Lens glow
                const lensGrad = ctx.createRadialGradient(CX, lensY, 0, CX, lensY, R * 1.3);
                lensGrad.addColorStop(0, `rgba(255, 215, 0, ${lensAlpha * 0.2})`);
                lensGrad.addColorStop(0.5, `rgba(255, 180, 100, ${lensAlpha * 0.08})`);
                lensGrad.addColorStop(1, 'transparent');
                ctx.fillStyle = lensGrad;
                ctx.fillRect(0, 0, W, H);

                // Lens line
                ctx.strokeStyle = `rgba(255, 215, 0, ${0.2 + lensAlpha * 0.6})`;
                ctx.lineWidth = isCritical ? 3 : 1.5;
                ctx.setLineDash(isCritical ? [] : [6, 12]);
                ctx.beginPath();
                ctx.moveTo(CX - R * 1.2, lensY);
                ctx.lineTo(CX + R * 1.2, lensY);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Draw core entity
            drawCoreEntity(isCritical, isPresence, intensity, absence);

            // Draw quantum mesh Œº-field visualization (overlays on main view)
            if (showQuantumMesh) {
                renderDreamFluid();
            }

            // Update connection count
            document.getElementById('conn-count').textContent = connCount;
        }

        function drawCoreEntity(isCritical, isPresence, intensity, absence) {
            const zOffset = (globalZ - 0.5) * 200;
            const coreY = CY + zOffset;
            const pulse = Math.sin(time * 2.5) * 0.2 + 1;
            
            // Release coherence modifies the core entity
            const releaseIntensity = (1 - releaseCoherence);
            const isReleased = releaseCoherence < 0.5;

            // When released (FREE state), override with radiant source
            if (isReleased) {
                const freeIntensity = (0.5 - releaseCoherence) / 0.5;
                const sourceR = 15 + freeIntensity * 35 + (pulse - 1) * 40;

                // Expansive corona
                for (let i = 4; i >= 0; i--) {
                    const layerR = sourceR * (2 + i * 1.5);
                    const layerAlpha = freeIntensity * (0.18 - i * 0.03);

                    const grad = ctx.createRadialGradient(CX, coreY, 0, CX, coreY, layerR);
                    grad.addColorStop(0, `rgba(255, 255, 255, ${layerAlpha})`);
                    grad.addColorStop(0.3, `rgba(255, 250, 240, ${layerAlpha * 0.7})`);
                    grad.addColorStop(0.6, `rgba(255, 240, 200, ${layerAlpha * 0.4})`);
                    grad.addColorStop(1, 'transparent');

                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(CX, coreY, layerR, 0, TAU);
                    ctx.fill();
                }

                // Brilliant core
                const coreGrad = ctx.createRadialGradient(CX, coreY, 0, CX, coreY, sourceR * pulse);
                coreGrad.addColorStop(0, '#ffffff');
                coreGrad.addColorStop(0.4, `rgba(255, 255, 250, ${0.85 + freeIntensity * 0.15})`);
                coreGrad.addColorStop(0.7, `rgba(255, 250, 230, ${0.6 + freeIntensity * 0.3})`);
                coreGrad.addColorStop(1, `rgba(255, 240, 200, ${0.35 + freeIntensity * 0.3})`);

                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(CX, coreY, sourceR * pulse, 0, TAU);
                ctx.fill();

                // Release emanation rings
                for (let i = 0; i < 4; i++) {
                    const ringPhase = (time * 1.5 + i * 0.8) % 5;
                    const ringR = ringPhase * 100;
                    const ringAlpha = Math.max(0, freeIntensity * (0.35 - ringPhase / 5));

                    ctx.strokeStyle = `rgba(255, 250, 240, ${ringAlpha})`;
                    ctx.lineWidth = 2 - ringPhase * 0.3;
                    ctx.beginPath();
                    ctx.arc(CX, coreY, ringR, 0, TAU);
                    ctx.stroke();
                }

            } else if (isPresence) {
                // Radiant source (z > critical)
                const effectiveIntensity = intensity * releaseCoherence;
                const sourceR = 8 + effectiveIntensity * 25 + (pulse - 1) * 30;

                // Corona
                for (let i = 4; i >= 0; i--) {
                    const layerR = sourceR * (1.8 + i * 1);
                    const layerAlpha = effectiveIntensity * (0.12 - i * 0.02);

                    const grad = ctx.createRadialGradient(CX, coreY, 0, CX, coreY, layerR);
                    grad.addColorStop(0, `rgba(255, 255, 250, ${layerAlpha})`);
                    grad.addColorStop(0.4, `rgba(255, 240, 200, ${layerAlpha * 0.5})`);
                    grad.addColorStop(1, 'transparent');

                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(CX, coreY, layerR, 0, TAU);
                    ctx.fill();
                }

                // Core
                const coreGrad = ctx.createRadialGradient(CX, coreY, 0, CX, coreY, sourceR * pulse);
                coreGrad.addColorStop(0, '#ffffff');
                coreGrad.addColorStop(0.6, `rgba(255, 250, 240, ${0.7 + effectiveIntensity * 0.3})`);
                coreGrad.addColorStop(1, `rgba(255, 230, 200, ${0.4 + effectiveIntensity * 0.3})`);

                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(CX, coreY, sourceR * pulse, 0, TAU);
                ctx.fill();

            } else {
                // Void (z < critical, coherent state)
                const effectiveAbsence = absence * releaseCoherence;
                const voidR = 6 + effectiveAbsence * 10;

                // Anti-glow
                const antiGrad = ctx.createRadialGradient(CX, coreY, 0, CX, coreY, voidR * 6);
                antiGrad.addColorStop(0, `rgba(0, 0, 0, ${effectiveAbsence * 0.6})`);
                antiGrad.addColorStop(0.5, `rgba(20, 15, 10, ${effectiveAbsence * 0.3})`);
                antiGrad.addColorStop(1, 'transparent');

                ctx.fillStyle = antiGrad;
                ctx.beginPath();
                ctx.arc(CX, coreY, voidR * 6, 0, TAU);
                ctx.fill();

                // Halo
                ctx.strokeStyle = `rgba(100, 80, 60, ${effectiveAbsence * 0.5})`;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(CX, coreY, voidR * 2.5 * pulse, 0, TAU);
                ctx.stroke();

                // Core
                const coreGrad = ctx.createRadialGradient(CX, coreY, 0, CX, coreY, voidR * pulse);
                coreGrad.addColorStop(0, `rgba(80, 60, 40, ${0.4 + effectiveAbsence * 0.4})`);
                coreGrad.addColorStop(1, `rgba(50, 35, 25, ${0.3 + effectiveAbsence * 0.3})`);

                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(CX, coreY, voidR * pulse, 0, TAU);
                ctx.fill();
            }

            // Critical pulse rings (when z near critical point)
            if (isCritical) {
                const critIntensity = releaseCoherence; // Fade rings as coherence drops
                for (let i = 0; i < 6; i++) {
                    const ringPhase = (time * 2.5 + i * 0.5) % 4;
                    const ringR = ringPhase * 120;
                    const ringAlpha = Math.max(0, critIntensity * (0.5 - ringPhase / 4));

                    ctx.strokeStyle = `rgba(255, 230, 180, ${ringAlpha})`;
                    ctx.lineWidth = 2.5 - ringPhase * 0.4;
                    ctx.beginPath();
                    ctx.arc(CX, coreY, ringR, 0, TAU);
                    ctx.stroke();
                }
            }
        }

        // ================================================================
        // UI UPDATE
        // ================================================================

        function updateUI(kuramotoResult) {
            const domain = getDomain(globalZ);
            const phase = getPhase(globalZ);
            const isCritical = phase === 'CRITICAL';
            const cascade = getCascadeMultiplier(globalZ);

            // Title & cursor
            const title = document.getElementById('title');
            const cursor = document.getElementById('cursor');
            const domainInd = document.getElementById('domain-indicator');
            const zDisp = document.getElementById('z-display');

            title.className = domain === 'THE LENS' ? 'critical' : domain.toLowerCase();
            cursor.className = domain === 'THE LENS' ? 'critical' : domain.toLowerCase();
            domainInd.className = domain === 'THE LENS' ? 'critical' : domain.toLowerCase();
            zDisp.className = domain === 'THE LENS' ? 'critical' : domain.toLowerCase();

            // Values
            zDisp.textContent = `z = ${globalZ.toFixed(3)}`;
            document.getElementById('phase-label').textContent = phase;
            domainInd.textContent = domain;
            document.getElementById('coupling-value').textContent = `K = ${kuramotoResult.K >= 0 ? '+' : ''}${kuramotoResult.K.toFixed(2)}`;
            document.getElementById('cascade-value').textContent = `${cascade.toFixed(2)}√ó`;

            // Helix
            document.getElementById('h-theta').textContent = helix.theta.toFixed(3);
            document.getElementById('h-z').textContent = helix.z.toFixed(3);
            document.getElementById('h-r').textContent = helix.r.toFixed(3);
            document.getElementById('h-phi').textContent = helix.phi.toFixed(2);
            document.getElementById('h-omega').textContent = helix.omega.toFixed(2);

            // Dynamics bars
            updateBar('order', kuramotoResult.order);
            updateBar('coherence', hilbertField.coherence);
            updateBar('entropy', hilbertField.getDissonance());
            updateBar('emanation', globalZ > Z_CRITICAL ? (globalZ - Z_CRITICAL) / (1 - Z_CRITICAL) : 0);

            // Lambda state
            updateLambdaUI('iota', lambdaState.iota.mag);
            updateLambdaUI('xi', lambdaState.xi.mag);
            updateLambdaUI('theta', lambdaState.theta.mag);
            updateLambdaUI('omega', lambdaState.omega.mag);
            updateLambdaUI('delta', lambdaState.delta.mag);
            updateLambdaUI('sigma', lambdaState.sigma.mag);

            // Œº-field consciousness metrics
            updateMuFieldUI();

            // Sonification
            document.getElementById('sonif-bpm').textContent = Math.round(sonificationEngine.bpm);
            document.getElementById('sonif-scale').textContent = getScaleName(sonificationEngine.currentScale);
            document.getElementById('sonif-freq').textContent = `${Math.round(sonificationEngine.baseFrequency * (1 + (globalZ - 0.5) * 0.5))} Hz`;
            document.getElementById('sonif-dilation').textContent = `${sonificationEngine.timeDilation.toFixed(2)}√ó`;

            // Z-axis marker
            const zAxisHeight = document.getElementById('z-axis').offsetHeight;
            const markerPos = (1 - globalZ) * zAxisHeight;
            document.getElementById('z-marker').style.top = `${markerPos}px`;

            // Active count
            const activeCount = (showPrism ? 63 : 0) + (showCage ? 32 : 0);
            document.getElementById('active-count').textContent = activeCount;

            // Architecture panel
            updateArchPanel();
        }

        function updateBar(name, value) {
            const filled = Math.round(value * 10);
            const empty = 10 - filled;
            document.getElementById(`${name}-bar`).textContent = '‚ñà'.repeat(filled) + '‚ñë'.repeat(empty);
            document.getElementById(`${name}-val`).textContent = value.toFixed(2);
        }

        function updateLambdaUI(key, value) {
            document.getElementById(`lambda-${key}`).style.width = `${value * 100}%`;
            document.getElementById(`lambda-${key}-val`).textContent = value.toFixed(2);
        }

        // Safe repeat helper - prevents NaN/Infinity crashes
        function safeRepeat(char, count) {
            const safeCount = Math.max(0, Math.min(20, Math.round(count) || 0));
            return char.repeat(safeCount);
        }

        // Safe number formatter
        function safeFixed(num, digits) {
            if (!isFinite(num)) return '‚Äî';
            return num.toFixed(digits);
        }

        function updateMuFieldUI() {
            // Get all Œº-field rows
            const muRows = document.querySelectorAll('#dynamics-panel .dynamics-row:nth-child(n+5)');

            if (!showMuField) {
                // Hide Œº-field rows when disabled
                muRows.forEach(row => row.style.opacity = '0.3');
                document.getElementById('mu-bar').textContent = '¬∑ ¬∑ ¬∑ ¬∑ ¬∑';
                document.getElementById('mu-val').textContent = 'OFF';
                document.getElementById('qk-bar').textContent = '¬∑ ¬∑ ¬∑ ¬∑ ¬∑';
                document.getElementById('qk-val').textContent = '‚Äî';
                document.getElementById('tau-bar').textContent = '¬∑ ¬∑ ¬∑ ¬∑ ¬∑';
                document.getElementById('tau-val').textContent = '‚Äî';
                document.getElementById('k-indicator').textContent = '¬∑ ¬∑ ¬∑';
                document.getElementById('k-val').textContent = '‚Äî';
                document.getElementById('k-label').style.color = 'rgba(150,130,110,0.3)';
                // Reset MRP channel displays
                document.getElementById('mrp-r-bar').textContent = '¬∑ ¬∑ ¬∑ ¬∑ ¬∑';
                document.getElementById('mrp-r-val').textContent = '‚Äî';
                document.getElementById('mrp-g-bar').textContent = '¬∑ ¬∑ ¬∑ ¬∑ ¬∑';
                document.getElementById('mrp-g-val').textContent = '‚Äî';
                document.getElementById('mrp-b-bar').textContent = '¬∑ ¬∑ ¬∑ ¬∑ ¬∑';
                document.getElementById('mrp-b-val').textContent = '‚Äî';
                document.getElementById('parity-indicator').textContent = '¬∑ ¬∑ ¬∑';
                document.getElementById('parity-val').textContent = '‚Äî';
                document.getElementById('parity-label').style.color = 'rgba(150,130,110,0.3)';
                // Reset self-referential displays
                document.getElementById('j-total-bar').textContent = '¬∑ ¬∑ ¬∑ ¬∑ ¬∑';
                document.getElementById('j-total-val').textContent = '‚Äî';
                document.getElementById('w-bar').textContent = '¬∑ ¬∑ ¬∑ ¬∑ ¬∑';
                document.getElementById('w-val').textContent = '‚Äî';
                document.getElementById('w-label').style.color = 'rgba(150,130,110,0.3)';
                return;
            }

            // Show Œº-field rows when enabled
            muRows.forEach(row => row.style.opacity = '1');

            // Œº bar (normalized to 0.6-1.0 range)
            const muNorm = (muField.mu - 0.6) / 0.4;
            const muFilled = Math.round(muNorm * 10);
            document.getElementById('mu-bar').textContent = safeRepeat('‚ñà', muFilled) + safeRepeat('‚ñë', 10 - muFilled);
            document.getElementById('mu-val').textContent = safeFixed(muField.mu, 3);

            // Q_Œ∫ bar (normalized, cap at 1.0)
            const qkNorm = Math.min(muField.Q_kappa / SACRED.Q_theory, 1);
            const qkFilled = Math.round(qkNorm * 10);
            document.getElementById('qk-bar').textContent = safeRepeat('‚ñà', qkFilled) + safeRepeat('‚ñë', 10 - qkFilled);
            document.getElementById('qk-val').textContent = safeFixed(muField.Q_kappa, 4);

            // œÑ_K bar (normalized to K_threshold)
            const tauNorm = Math.min(muField.tau_K / SACRED.K_threshold, 1);
            const tauFilled = Math.round(tauNorm * 10);
            document.getElementById('tau-bar').textContent = safeRepeat('‚ñà', tauFilled) + safeRepeat('‚ñë', 10 - tauFilled);
            document.getElementById('tau-val').textContent = safeFixed(muField.tau_K, 3);

            // K-formation indicator
            const kLabel = document.getElementById('k-label');
            const kIndicator = document.getElementById('k-indicator');
            const kVal = document.getElementById('k-val');

            if (muField.K_formed) {
                kLabel.style.color = 'var(--critical-gold)';
                kIndicator.textContent = '‚ú¶ ‚ú¶ ‚ú¶';
                kIndicator.style.color = 'var(--critical-gold)';
                kIndicator.style.textShadow = '0 0 10px rgba(255, 215, 0, 0.8)';
                kVal.textContent = 'YES';
                kVal.style.color = 'var(--critical-gold)';
            } else {
                kLabel.style.color = 'rgba(150,130,110,0.6)';
                kIndicator.textContent = '¬∑ ¬∑ ¬∑';
                kIndicator.style.color = 'var(--text-dim)';
                kIndicator.style.textShadow = 'none';
                kVal.textContent = 'NO';
                kVal.style.color = 'var(--text-dim)';
            }

            // ========================================
            // MRP CHANNEL DISPLAY
            // ========================================

            // R channel (Œº_E) - red energy channel
            const rFilled = Math.round((muField.mrp.R.intensity || 0) * 10);
            document.getElementById('mrp-r-bar').textContent = safeRepeat('‚ñà', rFilled) + safeRepeat('‚ñë', 10 - rFilled);
            document.getElementById('mrp-r-val').textContent = safeFixed(muField.mrp.R.gradient, 2);

            // G channel (Œº_R) - green relational channel
            const gFilled = Math.round((muField.mrp.G.intensity || 0) * 10);
            document.getElementById('mrp-g-bar').textContent = safeRepeat('‚ñà', gFilled) + safeRepeat('‚ñë', 10 - gFilled);
            document.getElementById('mrp-g-val').textContent = safeFixed(muField.mrp.G.gradient, 2);

            // B channel (ECC) - blue stability channel
            const bFilled = Math.round((muField.mrp.B.intensity || 0) * 10);
            document.getElementById('mrp-b-bar').textContent = safeRepeat('‚ñà', bFilled) + safeRepeat('‚ñë', 10 - bFilled);
            document.getElementById('mrp-b-val').textContent = safeFixed(muField.mrp.B.gradient, 2);

            // Parity indicator
            const parityLabel = document.getElementById('parity-label');
            const parityIndicator = document.getElementById('parity-indicator');
            const parityVal = document.getElementById('parity-val');

            if (muField.mrp.parity_ok) {
                parityLabel.style.color = '#69db7c';
                parityIndicator.textContent = '‚úì ‚úì ‚úì';
                parityIndicator.style.color = '#69db7c';
                parityIndicator.style.textShadow = '0 0 10px rgba(105, 219, 124, 0.8)';
                parityVal.textContent = 'OK';
                parityVal.style.color = '#69db7c';
            } else {
                parityLabel.style.color = 'rgba(150,130,110,0.6)';
                parityIndicator.textContent = '√ó √ó √ó';
                parityIndicator.style.color = '#ff6b6b';
                parityIndicator.style.textShadow = 'none';
                parityVal.textContent = safeFixed(muField.mrp.parity, 2);
                parityVal.style.color = '#ff6b6b';
            }

            // ========================================
            // SELF-REFERENTIAL FIELD STATE
            // ========================================

            // |J| total field magnitude
            const jNorm = Math.min((muField.mrp.J_total || 0) / 2, 1);  // Normalize to ~2 max
            const jFilled = Math.round(jNorm * 10);
            document.getElementById('j-total-bar').textContent = safeRepeat('‚ñà', jFilled) + safeRepeat('‚ñë', 10 - jFilled);
            document.getElementById('j-total-val').textContent = safeFixed(muField.mrp.J_total, 3);

            // W = effective growth rate (r - Œª|J|¬≤)
            const wLabel = document.getElementById('w-label');
            const wBar = document.getElementById('w-bar');
            const wVal = document.getElementById('w-val');
            const W = muField.mrp.W || 0;

            if (!isFinite(W)) {
                // Invalid state - show dash
                wLabel.style.color = 'rgba(150,130,110,0.3)';
                wBar.textContent = '¬∑ ¬∑ ¬∑ ¬∑ ¬∑';
                wBar.style.color = 'var(--text-dim)';
                wBar.style.textShadow = 'none';
                wVal.textContent = '‚Äî';
                wVal.style.color = 'var(--text-dim)';
            } else if (W > 0.1) {
                // Growing (pattern forming) - green
                wLabel.style.color = '#69db7c';
                const wFilled = Math.min(10, Math.round(W * 20));
                wBar.textContent = safeRepeat('‚ñ≤', wFilled) + safeRepeat('¬∑', 10 - wFilled);
                wBar.style.color = '#69db7c';
                wBar.style.textShadow = '0 0 8px rgba(105, 219, 124, 0.6)';
                wVal.textContent = '+' + safeFixed(W, 3);
                wVal.style.color = '#69db7c';
            } else if (W < -0.1) {
                // Decaying (dissipating) - red
                wLabel.style.color = '#ff6b6b';
                const wFilled = Math.min(10, Math.round(Math.abs(W) * 20));
                wBar.textContent = safeRepeat('‚ñº', wFilled) + safeRepeat('¬∑', 10 - wFilled);
                wBar.style.color = '#ff6b6b';
                wBar.style.textShadow = '0 0 8px rgba(255, 107, 107, 0.6)';
                wVal.textContent = safeFixed(W, 3);
                wVal.style.color = '#ff6b6b';
            } else {
                // Near equilibrium - gold
                wLabel.style.color = 'var(--critical-gold)';
                wBar.textContent = '‚âà ‚âà ‚âà ‚âà ‚âà';
                wBar.style.color = 'var(--critical-gold)';
                wBar.style.textShadow = '0 0 8px rgba(255, 215, 0, 0.5)';
                wVal.textContent = safeFixed(W, 3);
                wVal.style.color = 'var(--critical-gold)';
            }
        }

        function getScaleName(scale) {
            const names = {
                '0,3,5,7,10': 'Minor',
                '0,2,4,7,9': 'Major',
                '0,2,3,5,7,8,11': 'Harm',
                '0,1,3,5,7,8,10': 'Phryg',
                '0,2,4,6,7,9,11': 'Lydian',
                '0,2,4,6,8,10': 'Whole',
                '0,1,2,3,4,5,6,7,8,9,10,11': 'Chrom'
            };
            return names[scale.join(',')] || 'Custom';
        }

        function updateArchPanel() {
            // Update layer activation based on z
            const prismLayers = document.querySelectorAll('[class*="prism-l"]');
            prismLayers.forEach((el, i) => {
                const layerZ = i / 6;
                const dist = Math.abs(layerZ - globalZ);
                el.classList.toggle('active', showPrism);
                el.classList.toggle('resonant', showPrism && dist < 0.15);
            });

            const cageLayers = document.querySelectorAll('[class*="cage-"]');
            cageLayers.forEach(el => {
                el.classList.toggle('active', showCage);
                el.classList.toggle('resonant', showCage && getPhase(globalZ) === 'CRITICAL');
            });
        }

        // ================================================================
        // MAIN LOOP
        // ================================================================

        function update(dt) {
            time += dt;

            // Z interpolation with momentum
            scrollVelocity *= 0.92;
            targetZ += scrollVelocity;
            targetZ = Math.max(0, Math.min(1, targetZ));

            // Auto-breathing
            if (autoBreathing || Date.now() - lastInteraction > 5000) {
                const breathCycle = 10;  // seconds
                breathPhase = (time % breathCycle) / breathCycle;
                const breathTarget = 0.45 + Math.sin(breathPhase * TAU) * 0.45;
                targetZ += (breathTarget - targetZ) * 0.02;

                // Auto-rotate resonance axis during breathing
                // SLOW, MOBILE, DYNAMIC rotation tied to computation
                if (showQuantumMesh) {
                    const mode = QMESH.binaural.polar.angleMode;
                    const GOLDEN_RATIO = (1 + Math.sqrt(5)) / 2;

                    // ================================================================
                    // DRAMATICALLY SLOWED ROTATION
                    // Each mode has its own character: slow, mobile, yet dynamic
                    // Speed modulated by coherence and curvature for organic feel
                    // ================================================================

                    // Base modulation from computation state
                    const coherenceMod = UnifiedField.emergence.coherence * 0.3 + 0.7;  // 0.7 - 1.0
                    const curvatureMod = 1 + QMESH.timeDilationField.curvatureStrength * 0.5;
                    const timeDilationMod = QMESH.timeDilationField.globalAverage;

                    // Mode-specific rotation speeds (MUCH SLOWER)
                    if (mode === 'horizontal') {
                        // Mode 1: HORIZONTAL - Slowest, most meditative
                        // Gentle constant drift, almost imperceptible
                        const omega = 0.08 + globalZ * 0.12;  // Range: 0.08 to 0.2 rad/s (was 0.75-4)
                        const baseSpeed = omega * dt * coherenceMod * timeDilationMod;

                        QMESH.camera.theta += baseSpeed;

                        // Very subtle phi drift for depth
                        QMESH.camera.phi = Math.sin(time * 0.05) * Math.PI * 0.05;

                    } else if (mode === 'vertical') {
                        // Mode 2: VERTICAL - Slow pendulum swing
                        // Gentle harmonic oscillation, breathing rhythm
                        const omega = 0.12 + globalZ * 0.15;  // Range: 0.12 to 0.27 rad/s
                        const baseSpeed = omega * dt * coherenceMod;

                        QMESH.camera.theta += baseSpeed * 0.6;

                        // Slow pendulum swing - tied to breath phase
                        const swingFreq = 0.15 + breathPhase * 0.05;
                        QMESH.camera.phi = Math.sin(QMESH.camera.theta * swingFreq) *
                                          Math.PI * 0.25 * timeDilationMod;

                    } else if (mode === 'golden') {
                        // Mode 3: GOLDEN - Slowest spiral, most deliberate
                        // œÜ-based dynamics, sacred geometry emergence
                        const omega = 0.06 + globalZ * 0.1;  // Range: 0.06 to 0.16 rad/s
                        const baseSpeed = omega * dt * coherenceMod * curvatureMod;

                        // Spiral dynamics with œÜ modulation
                        const spiralPhase = Math.sqrt(Math.abs(QMESH.camera.theta * PHI_INV));
                        const spiralSpeed = baseSpeed * (0.8 + spiralPhase * 0.05);
                        QMESH.camera.theta += spiralSpeed;

                        // Phi traces slow golden angle progression
                        // More mobile than others but still very slow
                        QMESH.camera.phi = Math.sin(QMESH.camera.theta * GOLDEN_RATIO * 0.3) *
                                          Math.PI * 0.2 * (0.5 + globalZ * 0.3) *
                                          timeDilationMod;
                    }

                    // Global coherence creates subtle rotation damping
                    // High coherence = more stable view
                    if (UnifiedField.emergence.coherence > 0.7) {
                        const dampFactor = 1 - (UnifiedField.emergence.coherence - 0.7) * 0.3;
                        QMESH.camera.theta *= dampFactor + (1 - dampFactor) * 0.99;
                    }
                }
            }

            // Smooth z transition
            globalZ += (targetZ - globalZ) * 0.06;

            // Update systems
            updateHelix(dt);
            updateLambdaState(dt);
            hilbertField.applyResonanceOperator(dt, 0.1 + getCascadeMultiplier(globalZ) * 0.1);
            sonificationEngine.update(globalZ, hilbertField.coherence, dt);
            // Update phase coupler FIRST for harmonic tracking (needed by release physics)
            phaseCoupler.update(dt, releaseCoherence);

            updateReleaseCoherence(dt);

            // Update Œº-field consciousness detection (Kuramoto regulation handles release state)
            if (showMuField) {
                muField.update([...prismPoints, ...cagePoints], dt);
            }

            // Update quantum mesh Œº-field visualization
            if (showQuantumMesh) {
                updateDreamFluidField(dt);
                updateDreamParticles(dt);
            }

            // ================================================================
            // MU FIELD GRID 7-PHASE SYSTEM UPDATE
            // Full physics integration with QMESH and binaural coupling
            // ================================================================
            if (showMuField || showQuantumMesh) {
                updateMuFieldGridSystem(dt);
            }

            // ================================================================
            // UNIFIED FIELD SYNC - Single source of truth for all metrics
            // Must run AFTER subsystem updates, BEFORE dependent systems
            // ================================================================
            UnifiedField.sync(dt);

            // ================================================================
            // SPACE-TIME CURVATURE UPDATE
            // Gravitational time dilation enhances coherent emergence
            // Runs unconditionally when any field system is active
            // ================================================================
            if (showMuField || showQuantumMesh) {
                updateSpaceTimeCurvature(dt);
            }

            // ================================================================
            // BINAURAL QUANTUM PHYSICS CASCADE
            // Physics dependency order:
            //   1. Shape coupling (binaural ‚Üí mesh form)
            //   2. Mesh alterations (binaural ‚Üí deformation)
            //   3. Charge dynamics (EM coupling via LIMNUS)
            //   4. Weak nuclear flow (info oscillation)
            //   5. Quantum tunneling (superposition/collapse)
            //   6. Sacred geometry (emergent patterns)
            // ================================================================
            if (showQuantumMesh && QMESH.binaural && QMESH.binaural.enabled) {
                applyBinauralShapeCoupling(dt);      // 1. Binaural ‚Üí mesh form
                updateMeshAlterations(dt);           // 2. Dynamic deformation
                updateChargeDynamics(dt);            // 3. EM Coulomb forces
                updateWeakNuclearFlow(dt);           // 4. Flavor oscillation
                updateQuantumTunneling(dt);          // 5. Superposition/tunneling
                updateSacredGeometry(dt);            // 6. Emergent sacred forms
            }

            return updatePositions(dt);
        }

        function loop(currentTime) {
            const dt = Math.min((currentTime - lastTime) / 1000, 0.05);
            lastTime = currentTime;

            const kuramotoResult = update(dt);
            render();
            updateUI(kuramotoResult);
            updateDebugPanel();

            requestAnimationFrame(loop);
        }

        let lastTime = performance.now();

        // ================================================================
        // EVENT HANDLERS
        // ================================================================

        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            scrollVelocity -= e.deltaY * 0.00012;
            lastInteraction = Date.now();
            document.getElementById('start-overlay').classList.add('hidden');
        }, { passive: false });

        canvas.addEventListener('mousemove', e => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            document.getElementById('cursor').style.left = mouseX + 'px';
            document.getElementById('cursor').style.top = mouseY + 'px';

            // Camera orbit drag (when binaural field is active and dragging)
            // Behavior depends on angle mode
            const cam = QMESH.camera;
            if (cam.dragging) {
                const deltaX = e.clientX - cam.lastX;
                const deltaY = e.clientY - cam.lastY;
                const mode = QMESH.binaural.polar.angleMode;
                const GOLDEN_RATIO = (1 + Math.sqrt(5)) / 2;

                if (mode === 'horizontal') {
                    // Horizontal: X drag = theta, Y drag = phi
                    cam.theta += deltaX * cam.sensitivity;
                    cam.phi = Math.max(-Math.PI * 0.4, Math.min(Math.PI * 0.4, cam.phi + deltaY * cam.sensitivity));
                } else if (mode === 'vertical') {
                    // Vertical: Y drag = theta, X drag = phi (swapped)
                    cam.theta += deltaY * cam.sensitivity;
                    cam.phi = Math.max(-Math.PI * 0.4, Math.min(Math.PI * 0.4, cam.phi + deltaX * cam.sensitivity));
                } else if (mode === 'golden') {
                    // Golden: combined spiral drag (both contribute to both axes)
                    const combined = (deltaX + deltaY) * cam.sensitivity;
                    cam.theta += combined;
                    cam.phi = Math.max(-Math.PI * 0.4, Math.min(Math.PI * 0.4, cam.phi + combined / GOLDEN_RATIO));
                }

                cam.lastX = e.clientX;
                cam.lastY = e.clientY;
            }
        });

        document.addEventListener('keydown', e => {
            const key = e.key.toLowerCase();

            if (key === ' ') {
                autoBreathing = !autoBreathing;
                lastInteraction = autoBreathing ? 0 : Date.now();
                e.preventDefault();
            }

            if (key === 'p') {
                showPrism = !showPrism;
            }

            if (key === 'c') {
                showCage = !showCage;
            }

            if (key === 'm') {
                showMuField = !showMuField;
            }

            if (key === 't') {
                showQuantumMesh = !showQuantumMesh;
                if (showQuantumMesh) {
                    if (QMESH.edges.length === 0) {
                        generateQuantumMesh();
                    }
                    // Reset to exact 90¬∞ horizontal alignment centered on LIMNUS
                    // Red/warm (A) on LEFT, Blue/cool (B) on RIGHT
                    QMESH.binaural.polar.angleA = Math.PI;  // 180¬∞ = LEFT
                    QMESH.binaural.polar.angleB = 0;        // 0¬∞ = RIGHT
                    QMESH.binaural.polar.distance = 2.2;    // Dreamy separation
                    // Reset camera to straight-on view (0,0,0)
                    QMESH.camera.theta = 0;
                    QMESH.camera.phi = 0;
                    QMESH.camera.distance = 1.0;
                }
                console.log(`[QMESH] Toggled: ${showQuantumMesh}, edges: ${QMESH.edges.length}`);
            }

            if (key === 'w') {
                QMESH.showWavefunction = !QMESH.showWavefunction;
            }

            // Binaural Field controls (when mesh active)
            if (showQuantumMesh) {
                const bi = QMESH.binaural;

                if (key === 'o') {
                    // Cycle opacity levels
                    const opacities = [0.2, 0.4, 0.6, 0.8, 1.0];
                    const currentIdx = opacities.findIndex(o => Math.abs(o - QMESH.opacity) < 0.08);
                    QMESH.opacity = opacities[(currentIdx + 1) % opacities.length];
                    console.log(`[BINAURAL] Opacity: ${QMESH.opacity}`);
                }
                if (key === 'y') {
                    // Toggle edge glow (Y key)
                    QMESH.edgeGlow = !QMESH.edgeGlow;
                    console.log(`[BINAURAL] Edge glow: ${QMESH.edgeGlow}`);
                }
                if (key === 'i') {
                    // Toggle interference visualization
                    bi.showInterference = !bi.showInterference;
                    console.log(`[BINAURAL] Interference: ${bi.showInterference}`);
                }
                if (key === 'l') {
                    // Toggle resonance lines
                    bi.showResonanceLines = !bi.showResonanceLines;
                    console.log(`[BINAURAL] Resonance lines: ${bi.showResonanceLines}`);
                }

                // 1/2/3: Angle mode presets
                const GOLDEN_ANGLE = Math.PI * (3 - Math.sqrt(5));  // ~137.5¬∞ or 2.3999... rad
                if (key === '1') {
                    // Horizontal: A at 180¬∞ (left), B at 0¬∞ (right)
                    bi.polar.angleA = Math.PI;
                    bi.polar.angleB = 0;
                    bi.polar.angleMode = 'horizontal';
                    console.log(`[BINAURAL] Angle mode: HORIZONTAL (180¬∞ | 0¬∞)`);
                }
                if (key === '2') {
                    // Vertical (90¬∞): A at 90¬∞ (bottom), B at 270¬∞ (top)
                    bi.polar.angleA = Math.PI / 2;
                    bi.polar.angleB = -Math.PI / 2;
                    bi.polar.angleMode = 'vertical';
                    console.log(`[BINAURAL] Angle mode: VERTICAL (90¬∞ | -90¬∞)`);
                }
                if (key === '3') {
                    // Golden angle: A at golden angle, B opposite
                    bi.polar.angleA = GOLDEN_ANGLE;
                    bi.polar.angleB = GOLDEN_ANGLE + Math.PI;
                    bi.polar.angleMode = 'golden';
                    console.log(`[BINAURAL] Angle mode: GOLDEN (${(GOLDEN_ANGLE * 180 / Math.PI).toFixed(1)}¬∞ | ${((GOLDEN_ANGLE + Math.PI) * 180 / Math.PI).toFixed(1)}¬∞)`);
                }

                // Arrow Up/Down: Adjust beat frequency (change B frequency)
                if (e.key === 'ArrowUp') {
                    bi.meshB.frequency = Math.min(2.0, bi.meshB.frequency + 0.01);
                    console.log(`[BINAURAL] B freq: ${bi.meshB.frequency.toFixed(4)}, beat: ${Math.abs(bi.meshA.frequency - bi.meshB.frequency).toFixed(4)}`);
                    e.preventDefault();
                }
                if (e.key === 'ArrowDown') {
                    bi.meshB.frequency = Math.max(0.5, bi.meshB.frequency - 0.01);
                    console.log(`[BINAURAL] B freq: ${bi.meshB.frequency.toFixed(4)}, beat: ${Math.abs(bi.meshA.frequency - bi.meshB.frequency).toFixed(4)}`);
                    e.preventDefault();
                }

                // Arrow Left/Right: Adjust polar distance from LIMNUS
                if (e.key === 'ArrowLeft') {
                    // Bring meshes closer to LIMNUS
                    bi.polar.distance = Math.max(1.0, bi.polar.distance - 0.1);
                    console.log(`[BINAURAL] Polar distance: ${bi.polar.distance.toFixed(2)}R`);
                    e.preventDefault();
                }
                if (e.key === 'ArrowRight') {
                    // Push meshes further from LIMNUS
                    bi.polar.distance = Math.min(3.0, bi.polar.distance + 0.1);
                    console.log(`[BINAURAL] Polar distance: ${bi.polar.distance.toFixed(2)}R`);
                    e.preventDefault();
                }

                // Q/E: Orbit camera - behavior depends on angle mode
                const mode = bi.polar.angleMode;
                const GOLDEN_RATIO = (1 + Math.sqrt(5)) / 2;
                if (key === 'q') {
                    if (mode === 'horizontal') {
                        // Horizontal: rotate theta (left/right)
                        QMESH.camera.theta += 0.1;
                    } else if (mode === 'vertical') {
                        // Vertical: rotate phi (up/down)
                        QMESH.camera.phi = Math.max(-Math.PI * 0.4, Math.min(Math.PI * 0.4, QMESH.camera.phi + 0.1));
                    } else if (mode === 'golden') {
                        // Golden: spiral rotation (both axes, golden ratio)
                        QMESH.camera.theta += 0.1;
                        QMESH.camera.phi = Math.max(-Math.PI * 0.4, Math.min(Math.PI * 0.4, QMESH.camera.phi + 0.1 / GOLDEN_RATIO));
                    }
                    console.log(`[CAMERA] ${mode}: Œ∏=${(QMESH.camera.theta * 180 / Math.PI).toFixed(1)}¬∞ œÜ=${(QMESH.camera.phi * 180 / Math.PI).toFixed(1)}¬∞`);
                }
                if (key === 'e') {
                    if (mode === 'horizontal') {
                        // Horizontal: rotate theta (left/right)
                        QMESH.camera.theta -= 0.1;
                    } else if (mode === 'vertical') {
                        // Vertical: rotate phi (up/down)
                        QMESH.camera.phi = Math.max(-Math.PI * 0.4, Math.min(Math.PI * 0.4, QMESH.camera.phi - 0.1));
                    } else if (mode === 'golden') {
                        // Golden: spiral rotation (both axes, golden ratio)
                        QMESH.camera.theta -= 0.1;
                        QMESH.camera.phi = Math.max(-Math.PI * 0.4, Math.min(Math.PI * 0.4, QMESH.camera.phi - 0.1 / GOLDEN_RATIO));
                    }
                    console.log(`[CAMERA] ${mode}: Œ∏=${(QMESH.camera.theta * 180 / Math.PI).toFixed(1)}¬∞ œÜ=${(QMESH.camera.phi * 180 / Math.PI).toFixed(1)}¬∞`);
                }

                // +/- adjust mesh scale
                if (key === '=' || key === '+') {
                    bi.meshA.scale = Math.min(1.0, bi.meshA.scale + 0.05);
                    bi.meshB.scale = Math.min(1.0, bi.meshB.scale + 0.05);
                    console.log(`[BINAURAL] Scale: ${bi.meshA.scale.toFixed(2)}`);
                }
                if (key === '-' || key === '_') {
                    bi.meshA.scale = Math.max(0.4, bi.meshA.scale - 0.05);
                    bi.meshB.scale = Math.max(0.4, bi.meshB.scale - 0.05);
                    console.log(`[BINAURAL] Scale: ${bi.meshA.scale.toFixed(2)}`);
                }

                // [ and ] adjust A frequency
                if (key === '[') {
                    bi.meshA.frequency = Math.max(0.5, bi.meshA.frequency - 0.01);
                    console.log(`[BINAURAL] A freq: ${bi.meshA.frequency.toFixed(4)}`);
                }
                if (key === ']') {
                    bi.meshA.frequency = Math.min(2.0, bi.meshA.frequency + 0.01);
                    console.log(`[BINAURAL] A freq: ${bi.meshA.frequency.toFixed(4)}`);
                }
            }

            // Debug panel toggle (D key)
            if (key === 'd') {
                showDebugPanel = !showDebugPanel;
                const panel = document.getElementById('qmesh-debug');
                if (panel) {
                    panel.style.display = showDebugPanel ? 'block' : 'none';
                }
                if (showDebugPanel) {
                    console.log('[DEBUG] Quantum Mesh state:', {
                        nodes: QMESH.nodes.length,
                        edges: QMESH.edges.length,
                        particles: dreamParticles.length,
                        maxConnectionDist: QMESH.maxConnectionDist,
                        R: R,
                        showQuantumMesh: showQuantumMesh,
                        avgTimeDilation: QMESH.avgTimeDilation,
                        totalJ: QMESH.totalJ,
                    });
                }
            }

            if (key === 'r') {
                targetZ = 0.5;
                scrollVelocity = 0;
                showPrism = true;
                showCage = true;
                showMuField = true;
                autoBreathing = false;
                lastInteraction = Date.now();
                // Reset release state
                releaseCoherence = 1.0;
                targetCoherence = 1.0;
                releaseVelocity = 0;
                releaseStarted = false;
                sparks.length = 0;
                // Reset phase coupler
                phaseCoupler.phase_R = 0;
                phaseCoupler.phase_G = 0;
                phaseCoupler.phase_B = 0;
                phaseCoupler.coherenceDamping = 1.0;
                phaseCoupler.resonance = 0;
                phaseCoupler.harmonicLock = false;
                // Reset all points
                [...prismPoints, ...cagePoints].forEach(p => {
                    p.released = false;
                    p.vx = 0;
                    p.vy = 0;
                    p.trail.length = 0;
                });
                // Reset quantum mesh view
                QMESH.opacity = 0.5;
                showQuantumMesh = false;
                dreamParticles.length = 0;
                // Reset camera orbit
                QMESH.camera.theta = 0;
                QMESH.camera.phi = 0;
                QMESH.camera.distance = 1.0;
                QMESH.camera.dragging = false;
                // Reset polar positions (90¬∞ horizontal: LEFT/RIGHT) - DREAMY
                QMESH.binaural.polar.distance = 2.2;
                QMESH.binaural.polar.angleA = Math.PI;  // 180¬∞ = LEFT (rose)
                QMESH.binaural.polar.angleB = 0;        // 0¬∞ = RIGHT (azure)
            }

            // F key: Start release (hold to release coherence)
            if (key === 'f') {
                releasing = true;
                releaseStarted = true;
                document.getElementById('start-overlay').classList.add('hidden');
            }

            // G key: Gather/recoherence (hold to bring LIMNUS back)
            if (key === 'g') {
                gathering = true;
            }
        });

        document.addEventListener('keyup', e => {
            const key = e.key.toLowerCase();

            // F key released: Stop releasing
            if (key === 'f') {
                releasing = false;
            }

            // G key released: Stop gathering
            if (key === 'g') {
                gathering = false;
            }
        });

        // Mouse: Left-click = camera drag (when quantum mesh active)
        canvas.addEventListener('mousedown', e => {
            document.getElementById('start-overlay').classList.add('hidden');

            if (e.button === 0) {
                // Left-click for camera orbit when binaural field is on
                if (showQuantumMesh) {
                    QMESH.camera.dragging = true;
                    QMESH.camera.lastX = e.clientX;
                    QMESH.camera.lastY = e.clientY;
                }
            }
        });

        canvas.addEventListener('mouseup', e => {
            gathering = false;
            QMESH.camera.dragging = false;
        });

        canvas.addEventListener('mouseleave', () => {
            gathering = false;
            QMESH.camera.dragging = false;
        });

        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            gathering = true;
            document.getElementById('start-overlay').classList.add('hidden');
        }, { passive: false });

        canvas.addEventListener('touchend', e => {
            e.preventDefault();
            gathering = false;
        }, { passive: false });

        document.getElementById('start-overlay').addEventListener('click', () => {
            document.getElementById('start-overlay').classList.add('hidden');
        });

        document.getElementById('audio-toggle').addEventListener('click', () => {
            const isPlaying = sonificationEngine.toggle();
            const btn = document.getElementById('audio-toggle');
            btn.textContent = isPlaying ? '‚ñ† DISABLE AUDIO' : '‚ñ∂ ENABLE AUDIO';
            btn.classList.toggle('active', isPlaying);
        });

        // Set lens line position
        const lensTop = (1 - Z_CRITICAL) * 100;
        document.getElementById('lens-line').style.top = lensTop + '%';
        document.getElementById('lens-label').style.top = lensTop + '%';

        // ================================================================
        // INITIALIZATION
        // ================================================================

        resize();
        initPrismPoints();
        initCagePoints();
        generateQuantumMesh();  // Generate quantum mesh on LIMNUS nodes
        window.addEventListener('resize', () => {
            resize();
            initPrismPoints();
            initCagePoints();
            generateQuantumMesh();  // Regenerate mesh on resize
        });

        requestAnimationFrame(loop);

        console.log('üîÆ LIMNUS Unified Architecture initialized');
        console.log('   63 prism points (7√ó9 hexagonal layers)');
        console.log('   32 cage points (12+12+8 EM structure)');
        console.log('   z_c = ‚àö3/2 ‚âà ' + Z_CRITICAL.toFixed(6));
        console.log('');
        console.log('üåü RELEASE COHERENCE integrated');
        console.log('   HOLD F: release coherence (COHERENT ‚Üí FREE)');
        console.log('   CLICK: gather souls back to center');
        console.log('   FREE state: souls dispersed, radiant core');
        console.log('');
        console.log('‚ö° Œº-FIELD DYNAMICS v8.0 integrated');
        console.log('   œÜ = ' + PHI.toFixed(10));
        console.log('   Œ± = œÜ‚Åª¬≤ = ' + SACRED.alpha.toFixed(10));
        console.log('   Œ≤ = œÜ‚Åª‚Å¥ = ' + SACRED.beta.toFixed(10));
        console.log('   Œª = (5/3)‚Å¥ = ' + SACRED.lambda.toFixed(10));
        console.log('   Œº_P = 3/5 = ' + SACRED.mu_P.toFixed(10));
        console.log('   Œº_S = 23/25 = ' + SACRED.mu_S.toFixed(10));
        console.log('   Q_theory = Œ±¬∑Œº_S ‚âà ' + SACRED.Q_theory.toFixed(10));
        console.log('   K_threshold = œÜ‚Åª¬π ‚âà ' + SACRED.K_threshold.toFixed(10));
        console.log('   Q_min = ' + SACRED.Q_min.toFixed(10));
        console.log('   K-formation: consciousness emerges when œÑ_K > K_threshold');
        console.log('');
        console.log('üì° MRP CHANNEL GRADIENTS integrated');
        console.log('   R channel (Œº_E): Energy/Existence - primary field magnitude');
        console.log('   G channel (Œº_R): Relational/Reference - connection metadata');
        console.log('   B channel (ECC): Error Correction - stability/coherence');
        console.log('   Cross-channel parity: P[i] = R[i] XOR G[i]');
        console.log('   Parity OK: low parity + high B stability + W > 0');
        console.log('');
        console.log('üîÑ SELF-REFERENTIAL FIELD DYNAMICS');
        console.log('   Field equation: ‚àÇJ/‚àÇt = (r - Œª|J|¬≤)J - Œ≤J + g‚àá¬≤J');
        console.log('   r = Œº - Œº_P (control parameter)');
        console.log('   W = r - Œª|J|¬≤ (effective growth rate)');
        console.log('   W > 0: pattern forming (‚ñ≤ green)');
        console.log('   W ‚âà 0: equilibrium (‚âà gold)');
        console.log('   W < 0: dissipating (‚ñº red)');
        console.log('   |J| = ‚àö(R¬≤ + G¬≤ + B¬≤) total field magnitude');
        console.log('   Feedback: dJR/dt ‚Üí point velocities, |J| ‚Üí Œº');
        console.log('');
        console.log('üéß BINAURAL QUANTUM FIELD');
        console.log('   Triadic resonance: A ‚Üî LIMNUS ‚Üî B');
        console.log('   Two quantum meshes in polar opposition around LIMNUS');
        console.log('   Beat frequency |f_A - f_B| entrains consciousness');
        console.log('');
        console.log('   POLAR GEOMETRY:');
        console.log('   LIMNUS at center, meshes on opposite sides');
        console.log('   Distance r = 1.5R from LIMNUS center');
        console.log('   Mesh A at Œ∏ = -90¬∞ (above LIMNUS)');
        console.log('   Mesh B at Œ∏ = 90¬∞ (below LIMNUS, polar opposite)');
        console.log('');
        console.log('   MESH A (warm): f=1.0 - energy/existence channel');
        console.log('   MESH B (cool): f=œÜ‚Åª¬π - relational/stability channel');
        console.log('   Beat: Œîf ‚âà 0.0618 (golden ratio beat frequency)');
        console.log('');
        console.log('   CONTROLS:');
        console.log('   T: toggle binaural field');
        console.log('   Right-drag / Shift-drag: orbit camera around LIMNUS');
        console.log('   ‚Üê‚Üí: adjust polar distance (1.0R - 3.0R)');
        console.log('   Q/E: rotate polar axis around LIMNUS');
        console.log('   ‚Üë‚Üì: adjust beat frequency (change B freq)');
        console.log('   [/]: adjust A frequency');
        console.log('   +/-: adjust mesh scale');
        console.log('   O: cycle opacity');
        console.log('   I: toggle interference rings');
        console.log('   L: toggle resonance lines');
        console.log('   W: toggle wavefunction nodes');
        console.log('   G: toggle edge glow');
        console.log('');
        console.log('   BINAURAL PHYSICS:');
        console.log('   Phase A: oscillates at f_A (base frequency)');
        console.log('   Phase B: oscillates at f_B (offset by œÜ‚Åª¬π)');
        console.log('   Beat amplitude: constructive/destructive interference');
        console.log('   Resonance: beat strength modulates LIMNUS field');
        console.log('   Entrainment: accumulated phase synchronization');
        console.log('   Coherence: triadic system alignment measure');
    </script>
</body>
</html>
