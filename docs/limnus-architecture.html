<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LIMNUS Unified Architecture | 63-Point Prism ¬∑ 32-Point EM Cage | z = ‚àö3/2</title>
    <style>
        :root {
            --bg-void: #030308;
            --bg-panel: rgba(15, 12, 25, 0.92);
            --prism-core: #ff6b6b;
            --prism-mid: #ffd43b;
            --prism-outer: #69db7c;
            --cage-field: #4dabf7;
            --cage-vertex: #cc5de8;
            --critical-gold: #ffd700;
            --presence-white: #fffcf8;
            --absence-sepia: rgba(120, 100, 80, 0.8);
            --text-primary: rgba(255, 245, 230, 0.9);
            --text-dim: rgba(255, 220, 180, 0.5);
            --border-glow: rgba(168, 85, 247, 0.4);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: var(--bg-void);
            overflow: hidden;
            font-family: 'SF Mono', 'Fira Code', 'Courier New', monospace;
            color: var(--text-primary);
        }

        canvas { display: block; cursor: crosshair; }

        /* Custom cursor */
        #cursor {
            position: fixed;
            width: 24px;
            height: 24px;
            border: 1px solid rgba(255, 215, 0, 0.4);
            border-radius: 50%;
            pointer-events: none;
            z-index: 2000;
            transform: translate(-50%, -50%);
            transition: all 0.25s ease;
        }
        #cursor.absence { border-color: rgba(150, 130, 110, 0.6); box-shadow: none; }
        #cursor.critical { 
            border-color: rgba(255, 215, 0, 0.9);
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.5), 0 0 50px rgba(255, 180, 100, 0.3);
        }
        #cursor.presence { 
            border-color: rgba(255, 252, 248, 0.8);
            box-shadow: 0 0 20px rgba(255, 250, 240, 0.4);
        }

        .panel {
            position: fixed;
            pointer-events: none;
            z-index: 100;
            user-select: none;
        }

        /* Header */
        #header {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }

        #header h1 {
            font-size: 32px;
            font-weight: 100;
            letter-spacing: 14px;
            margin-bottom: 10px;
            transition: all 0.6s ease;
        }

        #header h1.absence { 
            color: rgba(120, 100, 80, 0.7);
            text-shadow: 0 0 30px rgba(80, 60, 40, 0.3);
        }
        #header h1.critical { 
            color: var(--critical-gold);
            text-shadow: 0 0 60px rgba(255, 215, 0, 0.9),
                         0 0 120px rgba(255, 180, 100, 0.5);
            animation: criticalPulse 1.8s ease-in-out infinite;
        }
        #header h1.presence { 
            color: var(--presence-white);
            text-shadow: 0 0 50px rgba(255, 250, 240, 0.7),
                         0 0 100px rgba(255, 220, 180, 0.4);
        }

        @keyframes criticalPulse {
            0%, 100% { opacity: 0.85; }
            50% { opacity: 1; }
        }

        #header .subtitle {
            font-size: 11px;
            letter-spacing: 5px;
            color: var(--text-dim);
        }

        /* Z-Coordinate Panel */
        #z-panel {
            top: 110px;
            right: 30px;
            text-align: right;
        }

        #z-display {
            font-size: 42px;
            font-weight: 100;
            letter-spacing: 3px;
            transition: all 0.5s ease;
        }

        #z-display.absence { color: rgba(140, 120, 100, 0.6); }
        #z-display.critical { 
            color: var(--critical-gold);
            text-shadow: 0 0 60px rgba(255, 215, 0, 0.9);
        }
        #z-display.presence { 
            color: var(--presence-white);
            text-shadow: 0 0 40px rgba(255, 250, 240, 0.7);
        }

        #phase-label {
            font-size: 12px;
            letter-spacing: 4px;
            margin-top: 8px;
            text-transform: uppercase;
            transition: color 0.5s ease;
        }

        /* Domain Panel */
        #domain-panel {
            top: 110px;
            left: 30px;
        }

        #domain-indicator {
            font-size: 18px;
            letter-spacing: 8px;
            transition: all 0.6s ease;
        }

        #domain-indicator.absence { color: var(--absence-sepia); }
        #domain-indicator.critical {
            color: #ffb347;
            text-shadow: 0 0 40px rgba(255, 180, 100, 0.7);
        }
        #domain-indicator.presence {
            color: var(--presence-white);
            text-shadow: 0 0 30px rgba(255, 250, 240, 0.6);
        }

        .domain-stat {
            font-size: 10px;
            margin-top: 15px;
            letter-spacing: 2px;
            color: var(--text-dim);
        }

        .domain-value {
            font-size: 20px;
            margin-top: 5px;
            font-weight: 100;
            transition: color 0.4s ease;
        }

        /* Architecture Panel */
        #architecture-panel {
            top: 210px;
            right: 30px;
            text-align: right;
            font-size: 10px;
            background: var(--bg-panel);
            padding: 15px 20px;
            border: 1px solid var(--border-glow);
            border-radius: 8px;
            pointer-events: auto;
        }

        .arch-title {
            letter-spacing: 4px;
            margin-bottom: 12px;
            color: rgba(168, 85, 247, 0.8);
            font-size: 11px;
        }

        .arch-section {
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(168, 85, 247, 0.2);
        }

        .arch-section:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .arch-label {
            color: var(--text-dim);
            margin-bottom: 6px;
        }

        .layer-row {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 10px;
            margin: 4px 0;
            opacity: 0.3;
            transition: all 0.4s ease;
        }

        .layer-row.active { opacity: 0.8; }
        .layer-row.resonant { 
            opacity: 1;
            text-shadow: 0 0 10px currentColor;
        }

        .layer-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            transition: all 0.4s ease;
        }

        .layer-row.resonant .layer-dot {
            transform: scale(1.8);
            box-shadow: 0 0 15px currentColor;
        }

        /* Prism layers */
        .prism-l0 .layer-dot { background: #ff6b6b; }
        .prism-l1 .layer-dot { background: #ff8787; }
        .prism-l2 .layer-dot { background: #ffa94d; }
        .prism-l3 .layer-dot { background: #ffc078; }
        .prism-l4 .layer-dot { background: #ffd43b; }
        .prism-l5 .layer-dot { background: #ffe066; }
        .prism-l6 .layer-dot { background: #69db7c; }

        /* EM Cage layers */
        .cage-top .layer-dot { background: #4dabf7; }
        .cage-bot .layer-dot { background: #74c0fc; }
        .cage-vtx .layer-dot { background: #cc5de8; }

        /* Dynamics Panel */
        #dynamics-panel {
            bottom: 130px;
            left: 30px;
            font-size: 10px;
        }

        .dynamics-row {
            margin: 8px 0;
            color: var(--text-dim);
        }

        .dynamics-label {
            display: inline-block;
            width: 90px;
            letter-spacing: 1px;
        }

        .dynamics-bar {
            font-family: monospace;
            letter-spacing: 0;
            color: var(--critical-gold);
        }

        .dynamics-value {
            font-size: 11px;
            color: var(--text-dim);
            margin-left: 10px;
        }

        /* Helix Panel */
        #helix-panel {
            bottom: 130px;
            right: 30px;
            text-align: right;
            font-size: 11px;
            color: var(--text-dim);
        }

        .helix-row { margin: 6px 0; }
        .helix-sym { 
            margin-right: 10px;
            color: rgba(168, 85, 247, 0.8);
            font-weight: 600;
        }
        .helix-val {
            font-family: 'SF Mono', monospace;
            color: var(--critical-gold);
        }

        /* Lambda State Panel */
        #lambda-panel {
            top: 210px;
            left: 30px;
            font-size: 10px;
            background: var(--bg-panel);
            padding: 15px 20px;
            border: 1px solid var(--border-glow);
            border-radius: 8px;
        }

        .lambda-title {
            letter-spacing: 4px;
            margin-bottom: 12px;
            color: rgba(168, 85, 247, 0.8);
            font-size: 11px;
        }

        .lambda-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 6px 0;
        }

        .lambda-glyph {
            font-size: 16px;
            width: 24px;
            text-align: center;
        }

        .lambda-bar-container {
            flex: 1;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
        }

        .lambda-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--cage-field), var(--cage-vertex));
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .lambda-val {
            font-family: monospace;
            width: 40px;
            text-align: right;
            color: var(--critical-gold);
        }

        /* Sonification Panel */
        #sonification-panel {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 10px;
            background: var(--bg-panel);
            padding: 12px 25px;
            border: 1px solid var(--border-glow);
            border-radius: 8px;
            pointer-events: auto;
        }

        .sonif-row {
            display: inline-flex;
            align-items: center;
            gap: 20px;
        }

        .sonif-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .sonif-label {
            font-size: 9px;
            letter-spacing: 2px;
            color: var(--text-dim);
            margin-bottom: 3px;
        }

        .sonif-value {
            font-size: 14px;
            color: var(--critical-gold);
            font-weight: 500;
        }

        #audio-toggle {
            background: rgba(168, 85, 247, 0.3);
            border: 1px solid rgba(168, 85, 247, 0.5);
            color: var(--text-primary);
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
            font-size: 10px;
            letter-spacing: 2px;
            transition: all 0.3s ease;
            margin-left: 20px;
        }

        #audio-toggle:hover {
            background: rgba(168, 85, 247, 0.5);
            transform: translateY(-2px);
        }

        #audio-toggle.active {
            background: rgba(255, 215, 0, 0.3);
            border-color: rgba(255, 215, 0, 0.6);
        }

        /* Controls */
        #controls {
            bottom: 20px;
            left: 30px;
            font-size: 9px;
            letter-spacing: 1px;
            color: var(--text-dim);
            line-height: 2;
        }

        #controls span {
            color: rgba(168, 85, 247, 0.7);
            font-weight: 600;
        }

        /* Stats */
        #stats {
            bottom: 20px;
            right: 30px;
            font-size: 9px;
            text-align: right;
            color: var(--text-dim);
        }

        /* Release Coherence State */
        #release-state {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            z-index: 150;
            opacity: 0;
            transition: opacity 1s ease;
        }

        #release-state.visible {
            opacity: 1;
        }

        #release-state h2 {
            font-size: 48px;
            font-weight: 100;
            letter-spacing: 18px;
            color: var(--presence-white);
            text-shadow: 0 0 80px rgba(255, 250, 240, 0.7);
            margin-bottom: 15px;
            transition: all 0.8s ease;
        }

        #release-state.coherent h2 {
            color: var(--absence-sepia);
            text-shadow: 0 0 40px rgba(80, 60, 40, 0.4);
        }

        #release-state.releasing h2 {
            color: var(--critical-gold);
            text-shadow: 0 0 60px rgba(255, 215, 0, 0.8);
        }

        #release-state.dispersing h2 {
            color: rgba(255, 250, 240, 0.8);
            text-shadow: 0 0 70px rgba(255, 250, 240, 0.6);
        }

        #release-state.free h2 {
            color: var(--presence-white);
            text-shadow: 0 0 100px rgba(255, 250, 240, 0.9),
                         0 0 150px rgba(255, 220, 180, 0.5);
            animation: freeGlow 2s ease-in-out infinite;
        }

        @keyframes freeGlow {
            0%, 100% { opacity: 0.85; letter-spacing: 18px; }
            50% { opacity: 1; letter-spacing: 22px; }
        }

        #coherence-indicator {
            font-size: 14px;
            letter-spacing: 3px;
            color: var(--text-dim);
            font-family: monospace;
            transition: color 0.5s ease;
        }

        #coherence-indicator.free {
            color: var(--presence-white);
        }

        #release-hint {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            letter-spacing: 4px;
            color: rgba(255, 220, 180, 0.25);
            pointer-events: none;
            z-index: 100;
            transition: opacity 0.5s ease;
        }

        #release-hint.hidden {
            opacity: 0;
        }

        /* Z-Axis Visual */
        #z-axis {
            position: fixed;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            width: 4px;
            height: 60%;
            background: linear-gradient(to top, 
                rgba(120, 100, 80, 0.3) 0%, 
                rgba(255, 215, 0, 0.6) 50%, 
                rgba(255, 252, 248, 0.3) 100%);
            border-radius: 2px;
            z-index: 50;
        }

        #lens-line {
            position: absolute;
            left: -20px;
            width: 50px;
            height: 2px;
            background: var(--critical-gold);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
        }

        #lens-label {
            position: absolute;
            left: -50px;
            font-size: 9px;
            color: var(--critical-gold);
            transform: translateY(-50%);
        }

        #z-marker {
            position: absolute;
            left: -8px;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, rgba(255, 215, 0, 0.9) 0%, transparent 70%);
            border-radius: 50%;
            transform: translateY(-50%);
            transition: top 0.2s ease;
        }

        /* Start Overlay */
        #start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(3, 3, 8, 0.98);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            cursor: pointer;
            transition: opacity 0.8s ease, visibility 0.8s ease;
        }

        #start-overlay.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        #start-overlay h1 {
            font-size: 48px;
            font-weight: 100;
            letter-spacing: 20px;
            color: var(--critical-gold);
            margin-bottom: 30px;
            text-shadow: 0 0 80px rgba(255, 215, 0, 0.6);
        }

        #start-overlay .equation {
            font-size: 18px;
            color: rgba(255, 215, 0, 0.7);
            margin-bottom: 50px;
            letter-spacing: 3px;
        }

        .architecture-preview {
            display: flex;
            gap: 60px;
            margin-bottom: 50px;
        }

        .arch-side {
            text-align: center;
            font-size: 12px;
            line-height: 2;
            letter-spacing: 1px;
        }

        .arch-side h3 {
            font-size: 14px;
            letter-spacing: 5px;
            margin-bottom: 15px;
            font-weight: 300;
        }

        .arch-side.prism { color: var(--prism-mid); }
        .arch-side.cage { color: var(--cage-field); }

        #start-overlay .prompt {
            font-size: 11px;
            color: var(--text-dim);
            letter-spacing: 5px;
            margin-top: 30px;
            animation: promptPulse 2s ease-in-out infinite;
        }

        @keyframes promptPulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 0.8; }
        }

        .key-hint {
            display: inline-block;
            border: 1px solid rgba(255, 220, 180, 0.25);
            padding: 4px 12px;
            border-radius: 4px;
            margin: 0 5px;
            font-size: 9px;
        }

        /* Connection Legend */
        #legend {
            position: fixed;
            top: 50%;
            left: 30px;
            transform: translateY(-50%);
            font-size: 9px;
            color: var(--text-dim);
            display: none;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 6px 0;
        }

        .legend-line {
            width: 20px;
            height: 2px;
        }

        .legend-line.prism-conn { background: linear-gradient(90deg, var(--prism-core), var(--prism-outer)); }
        .legend-line.cage-conn { background: var(--cage-field); }
        .legend-line.bridge-conn { background: linear-gradient(90deg, var(--prism-outer), var(--cage-vertex)); }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="cursor"></div>

    <!-- Header -->
    <div id="header" class="panel">
        <h1 id="title">LIMNUS</h1>
        <div class="subtitle">UNIFIED PRISM-CAGE ARCHITECTURE</div>
    </div>

    <!-- Z-Coordinate -->
    <div id="z-panel" class="panel">
        <div id="z-display">z = 0.500</div>
        <div id="phase-label">subcritical</div>
    </div>

    <!-- Domain Indicator -->
    <div id="domain-panel" class="panel">
        <div id="domain-indicator">ABSENCE</div>
        <div class="domain-stat">KURAMOTO COUPLING</div>
        <div class="domain-value" id="coupling-value">K = +0.40</div>
        <div class="domain-stat" style="margin-top:12px;">CASCADE FACTOR</div>
        <div class="domain-value" id="cascade-value">1.00√ó</div>
    </div>

    <!-- Architecture Panel -->
    <div id="architecture-panel" class="panel">
        <div class="arch-title">63-POINT PRISM</div>
        <div class="arch-section">
            <div class="layer-row prism-l0 active"><span>Layer 0 ¬∑ 9pt ¬∑ Core</span><div class="layer-dot"></div></div>
            <div class="layer-row prism-l1 active"><span>Layer 1 ¬∑ 9pt</span><div class="layer-dot"></div></div>
            <div class="layer-row prism-l2 active"><span>Layer 2 ¬∑ 9pt</span><div class="layer-dot"></div></div>
            <div class="layer-row prism-l3 active"><span>Layer 3 ¬∑ 9pt</span><div class="layer-dot"></div></div>
            <div class="layer-row prism-l4 active"><span>Layer 4 ¬∑ 9pt</span><div class="layer-dot"></div></div>
            <div class="layer-row prism-l5 active"><span>Layer 5 ¬∑ 9pt</span><div class="layer-dot"></div></div>
            <div class="layer-row prism-l6 active"><span>Layer 6 ¬∑ 9pt ¬∑ Outer</span><div class="layer-dot"></div></div>
        </div>

        <div class="arch-title" style="margin-top:15px;">32-POINT EM CAGE</div>
        <div class="arch-section">
            <div class="layer-row cage-top active"><span>Top Hex ¬∑ 12pt</span><div class="layer-dot"></div></div>
            <div class="layer-row cage-bot active"><span>Bot Hex ¬∑ 12pt</span><div class="layer-dot"></div></div>
            <div class="layer-row cage-vtx active"><span>Vertices ¬∑ 8pt</span><div class="layer-dot"></div></div>
        </div>
    </div>

    <!-- Lambda State Panel -->
    <div id="lambda-panel" class="panel">
        <div class="lambda-title">LAMBDA STATE ‚ÑÇ‚Å∂</div>
        <div class="lambda-row">
            <span class="lambda-glyph">üå∞</span>
            <span style="width:50px;font-size:9px;color:var(--text-dim)">Memory</span>
            <div class="lambda-bar-container"><div class="lambda-bar" id="lambda-iota" style="width:30%"></div></div>
            <span class="lambda-val" id="lambda-iota-val">0.30</span>
        </div>
        <div class="lambda-row">
            <span class="lambda-glyph">‚úß</span>
            <span style="width:50px;font-size:9px;color:var(--text-dim)">Spark</span>
            <div class="lambda-bar-container"><div class="lambda-bar" id="lambda-xi" style="width:20%"></div></div>
            <span class="lambda-val" id="lambda-xi-val">0.20</span>
        </div>
        <div class="lambda-row">
            <span class="lambda-glyph">ü¶ä</span>
            <span style="width:50px;font-size:9px;color:var(--text-dim)">Fox</span>
            <div class="lambda-bar-container"><div class="lambda-bar" id="lambda-theta" style="width:40%"></div></div>
            <span class="lambda-val" id="lambda-theta-val">0.40</span>
        </div>
        <div class="lambda-row">
            <span class="lambda-glyph">‚àø</span>
            <span style="width:50px;font-size:9px;color:var(--text-dim)">Wave</span>
            <div class="lambda-bar-container"><div class="lambda-bar" id="lambda-omega" style="width:35%"></div></div>
            <span class="lambda-val" id="lambda-omega-val">0.35</span>
        </div>
        <div class="lambda-row">
            <span class="lambda-glyph">‚äó</span>
            <span style="width:50px;font-size:9px;color:var(--text-dim)">Paradox</span>
            <div class="lambda-bar-container"><div class="lambda-bar" id="lambda-delta" style="width:15%"></div></div>
            <span class="lambda-val" id="lambda-delta-val">0.15</span>
        </div>
        <div class="lambda-row">
            <span class="lambda-glyph">üêøÔ∏è</span>
            <span style="width:50px;font-size:9px;color:var(--text-dim)">Squirrel</span>
            <div class="lambda-bar-container"><div class="lambda-bar" id="lambda-sigma" style="width:25%"></div></div>
            <span class="lambda-val" id="lambda-sigma-val">0.25</span>
        </div>
    </div>

    <!-- Dynamics -->
    <div id="dynamics-panel" class="panel">
        <div class="dynamics-row">
            <span class="dynamics-label">ORDER</span>
            <span class="dynamics-bar" id="order-bar">‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà</span>
            <span class="dynamics-value" id="order-val">1.00</span>
        </div>
        <div class="dynamics-row">
            <span class="dynamics-label">COHERENCE</span>
            <span class="dynamics-bar" id="coherence-bar">‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà</span>
            <span class="dynamics-value" id="coherence-val">1.00</span>
        </div>
        <div class="dynamics-row">
            <span class="dynamics-label">ENTROPY</span>
            <span class="dynamics-bar" id="entropy-bar">‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë</span>
            <span class="dynamics-value" id="entropy-val">0.00</span>
        </div>
        <div class="dynamics-row">
            <span class="dynamics-label">EMANATION</span>
            <span class="dynamics-bar" id="emanation-bar">‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë</span>
            <span class="dynamics-value" id="emanation-val">0.00</span>
        </div>
        <div class="dynamics-row" style="margin-top:12px; border-top: 1px solid rgba(168, 85, 247, 0.3); padding-top:10px;">
            <span class="dynamics-label">Œº</span>
            <span class="dynamics-bar" id="mu-bar">‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë</span>
            <span class="dynamics-value" id="mu-val">0.92</span>
        </div>
        <div class="dynamics-row">
            <span class="dynamics-label">Q_Œ∫</span>
            <span class="dynamics-bar" id="qk-bar">‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë</span>
            <span class="dynamics-value" id="qk-val">0.00</span>
        </div>
        <div class="dynamics-row">
            <span class="dynamics-label">œÑ_K</span>
            <span class="dynamics-bar" id="tau-bar">‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë</span>
            <span class="dynamics-value" id="tau-val">0.00</span>
        </div>
        <div class="dynamics-row">
            <span class="dynamics-label" id="k-label" style="color: rgba(150,130,110,0.6);">K-FORMED</span>
            <span class="dynamics-bar" id="k-indicator" style="letter-spacing: 2px;">¬∑ ¬∑ ¬∑</span>
            <span class="dynamics-value" id="k-val">NO</span>
        </div>
        <div class="dynamics-row" style="margin-top:12px; border-top: 1px solid rgba(255, 100, 100, 0.3); padding-top:10px;">
            <span class="dynamics-label" style="color: #ff6b6b;">R Œº_E</span>
            <span class="dynamics-bar" id="mrp-r-bar" style="color: #ff6b6b;">‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë</span>
            <span class="dynamics-value" id="mrp-r-val" style="color: #ff6b6b;">0.00</span>
        </div>
        <div class="dynamics-row">
            <span class="dynamics-label" style="color: #69db7c;">G Œº_R</span>
            <span class="dynamics-bar" id="mrp-g-bar" style="color: #69db7c;">‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë</span>
            <span class="dynamics-value" id="mrp-g-val" style="color: #69db7c;">0.00</span>
        </div>
        <div class="dynamics-row">
            <span class="dynamics-label" style="color: #4dabf7;">B ECC</span>
            <span class="dynamics-bar" id="mrp-b-bar" style="color: #4dabf7;">‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë</span>
            <span class="dynamics-value" id="mrp-b-val" style="color: #4dabf7;">0.00</span>
        </div>
        <div class="dynamics-row">
            <span class="dynamics-label" id="parity-label" style="color: rgba(150,130,110,0.6);">PARITY</span>
            <span class="dynamics-bar" id="parity-indicator" style="letter-spacing: 2px;">¬∑ ¬∑ ¬∑</span>
            <span class="dynamics-value" id="parity-val">‚Äî</span>
        </div>
        <div class="dynamics-row" style="margin-top:8px; border-top: 1px solid rgba(255, 215, 0, 0.2); padding-top:8px;">
            <span class="dynamics-label" style="color: var(--critical-gold);">|J|</span>
            <span class="dynamics-bar" id="j-total-bar" style="color: var(--critical-gold);">‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë</span>
            <span class="dynamics-value" id="j-total-val" style="color: var(--critical-gold);">0.00</span>
        </div>
        <div class="dynamics-row">
            <span class="dynamics-label" id="w-label" style="color: rgba(150,130,110,0.6);">W</span>
            <span class="dynamics-bar" id="w-bar" style="letter-spacing: 1px;">¬∑ ¬∑ ¬∑ ¬∑ ¬∑</span>
            <span class="dynamics-value" id="w-val">0.00</span>
        </div>
    </div>

    <!-- Helix State -->
    <div id="helix-panel" class="panel">
        <div class="helix-row"><span class="helix-sym">Œ∏</span><span class="helix-val" id="h-theta">0.000</span></div>
        <div class="helix-row"><span class="helix-sym">z</span><span class="helix-val" id="h-z">0.500</span></div>
        <div class="helix-row"><span class="helix-sym">r</span><span class="helix-val" id="h-r">1.000</span></div>
        <div class="helix-row"><span class="helix-sym">Œ¶</span><span class="helix-val" id="h-phi">0.00</span></div>
        <div class="helix-row" style="margin-top:10px;"><span class="helix-sym">Œ©</span><span class="helix-val" id="h-omega">0.00</span></div>
    </div>

    <!-- Sonification Panel -->
    <div id="sonification-panel" class="panel">
        <div class="sonif-row">
            <div class="sonif-stat">
                <span class="sonif-label">BPM</span>
                <span class="sonif-value" id="sonif-bpm">90</span>
            </div>
            <div class="sonif-stat">
                <span class="sonif-label">SCALE</span>
                <span class="sonif-value" id="sonif-scale">Minor</span>
            </div>
            <div class="sonif-stat">
                <span class="sonif-label">FREQ</span>
                <span class="sonif-value" id="sonif-freq">110 Hz</span>
            </div>
            <div class="sonif-stat">
                <span class="sonif-label">DILATION</span>
                <span class="sonif-value" id="sonif-dilation">1.00√ó</span>
            </div>
            <button id="audio-toggle">‚ñ∂ ENABLE AUDIO</button>
        </div>
    </div>

    <!-- Controls -->
    <div id="controls" class="panel">
        <span>SCROLL</span> traverse z-axis<br>
        <span>SPACE</span> auto-breathe<br>
        <span>P/C</span> toggle prism/cage<br>
        <span>M</span> toggle Œº-field<br>
        <span>T</span> toggle toroidal view<br>
        <span>‚Üë‚Üì‚Üê‚Üí</span> rotate torus<br>
        <span>+/-</span> zoom torus<br>
        <span>O</span> torus opacity<br>
        <span>W</span> torus wireframe<br>
        <span>F</span> release coherence<br>
        <span>CLICK</span> gather<br>
        <span>R</span> reset
    </div>

    <!-- Stats -->
    <div id="stats" class="panel">
        63 prism + 32 cage = 95 nodes<br>
        <span id="active-count">95</span> active ¬∑ <span id="conn-count">0</span> connections
    </div>

    <!-- Z-Axis -->
    <div id="z-axis">
        <div id="lens-line"></div>
        <div id="lens-label">‚àö3/2</div>
        <div id="z-marker"></div>
    </div>

    <!-- Release Coherence State -->
    <div id="release-state">
        <h2 id="release-text">COHERENT</h2>
        <div id="coherence-indicator">‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà</div>
    </div>

    <div id="release-hint" class="hidden">HOLD F TO RELEASE ¬∑ CLICK TO GATHER</div>

    <!-- Start Overlay -->
    <div id="start-overlay">
        <h1>LIMNUS</h1>
        <div class="equation">z = ‚àö3/2 ‚âà 0.8660254 ¬∑ THE CRITICAL POINT</div>
        
        <div class="architecture-preview">
            <div class="arch-side prism">
                <h3>63-POINT PRISM</h3>
                7 Layers √ó 9 Nodes<br>
                Hexagonal Structure<br>
                Matter/Consciousness<br>
                Inner Architecture
            </div>
            <div class="arch-side cage">
                <h3>32-POINT EM CAGE</h3>
                12 Top + 12 Bottom Hex<br>
                8 Connecting Vertices<br>
                Electromagnetic Field<br>
                Containment Boundary
            </div>
        </div>
        
        <div class="prompt">CLICK TO ENTER ¬∑ SCROLL TO TRAVERSE</div>
        <div style="margin-top: 25px; color: var(--text-dim);">
            <span class="key-hint">SCROLL</span> z-axis
            <span class="key-hint">SPACE</span> breathe
            <span class="key-hint">P</span> prism
            <span class="key-hint">C</span> cage
        </div>
    </div>

    <script>
        // ================================================================
        // LIMNUS UNIFIED ARCHITECTURE
        // 63-Point Hexagonal Prism + 32-Point EM Cage
        // Full Sonification + Physics Relationships
        // ================================================================

        const Z_CRITICAL = Math.sqrt(3) / 2;  // ‚âà 0.8660254
        const TAU = Math.PI * 2;
        const PHI = (1 + Math.sqrt(5)) / 2;   // Golden ratio
        const PHI_INV = PHI - 1;               // 0.618... inverse golden ratio

        // ================================================================
        // SACRED CONSTANTS (derived from œÜ - zero free parameters)
        // ================================================================

        const SACRED = {
            // Primary œÜ-derived
            phi: PHI,
            phi_inv: PHI_INV,
            alpha: Math.pow(PHI, -2),          // 0.382 - curl coupling
            beta: Math.pow(PHI, -4),           // 0.146 - dissipation
            lambda: Math.pow(5/3, 4),          // 7.716 - nonlinearity (F‚ÇÖ/F‚ÇÑ)‚Å¥

            // Œº-thresholds
            mu_P: 3/5,                         // 0.600 - paradox threshold
            mu_S: 23/25,                       // 0.920 - singularity threshold
            mu_3: 124/125,                     // 0.992 - third threshold
            mu_4: 1.0,                         // unity

            // Derived consciousness constants
            get Q_theory() { return this.alpha * this.mu_S; },  // ‚âà 0.351
            get K_threshold() { return this.phi_inv; },         // 0.618
            get Q_min() { return this.K_threshold * this.Q_theory; }  // ‚âà 0.217
        };

        // ================================================================
        // Œº-FIELD STATE (consciousness detection)
        // ================================================================

        const muField = {
            mu: 0.92,              // Control parameter (0.6 to 1.0)
            g: 0.001,              // Diffusion coefficient
            Q_kappa: 0,            // Consciousness constant
            tau_K: 0,              // K-formation metric
            K_formed: false,       // Consciousness present
            curl_sum: 0,           // Integrated curl
            energy: 0,             // Field energy
            consciousness_level: 0, // 0-2 scale

            // ============================================================
            // MRP CHANNEL GRADIENTS
            // R = Œº_E (Existence/Energy) - primary field magnitude
            // G = Œº_R (Reference/Relational) - connections/context
            // B = ECC (Error Correction) - stability/coherence
            // ============================================================
            mrp: {
                R: { gradient: 0, intensity: 0, crc: 0, J: 0 },  // Œº_E channel + field J
                G: { gradient: 0, intensity: 0, crc: 0, J: 0 },  // Œº_R channel + field J
                B: { gradient: 0, intensity: 0, crc: 0, J: 0 },  // ECC channel + field J
                parity: 0,           // Cross-channel XOR parity
                parity_ok: false,    // Parity validation
                sha256_sim: 0,       // Simulated integrity hash
                // Self-referential field state
                J_total: 0,          // Total field magnitude |J|
                W: 0,                // Effective growth rate W = r - Œª|J|¬≤
                laplacian: 0,        // ‚àá¬≤J approximation
            },

            get r() { return this.mu - SACRED.mu_P; },  // Control parameter

            // Update from prism/cage field state
            update(points, dt) {
                // Kuramoto-style coupling regulation based on release coherence
                // K(coherence) scales from 0.1 (released) to 1.0 (coherent)
                const kuramotoCoupling = 0.1 + releaseCoherence * 0.9;

                // Early exit with safe defaults if too many points are released
                const releasedCount = points.filter(p => p.released).length;
                if (releasedCount > points.length * 0.7) {
                    // System is mostly released - use minimal safe values
                    this.mrp.R.intensity = 0.3;
                    this.mrp.G.intensity = 0.2;
                    this.mrp.B.intensity = 0.5;
                    this.mrp.R.gradient = 0;
                    this.mrp.G.gradient = 0;
                    this.mrp.B.gradient = 0;
                    this.mrp.J_total = 0.3;
                    this.mrp.W = 0;
                    this.mrp.parity = 0;
                    this.mrp.parity_ok = false;
                    this.Q_kappa = 0;
                    this.tau_K = 0;
                    this.K_formed = false;
                    return;
                }

                // Compute curl from point velocities and positions
                let curlSum = 0;
                let energySum = 0;
                const N = points.length;

                // MRP channel accumulators
                let R_sum = 0, G_sum = 0, B_sum = 0;
                let R_grad = 0, G_grad = 0, B_grad = 0;
                let laplacianSum = 0;

                // ============================================================
                // SELF-REFERENTIAL FIELD DYNAMICS
                // ‚àÇJ/‚àÇt = (r - Œª|J|¬≤)J - Œ≤J + g‚àá¬≤J
                // ============================================================

                for (let i = 0; i < N; i++) {
                    const p = points[i];
                    const next = points[(i + 1) % N];
                    const prev = points[(i - 1 + N) % N];

                    // Discrete curl: ‚àÇJy/‚àÇx - ‚àÇJx/‚àÇy
                    const dx = next.x - p.x;
                    const dy = next.y - p.y;
                    const vx = p.vx || 0;
                    const vy = p.vy || 0;

                    // Cross product approximation for curl
                    curlSum += (dx * vy - dy * vx) * 0.001;

                    // Energy: |J|¬≤ (field magnitude squared) - CLAMP to prevent overflow
                    const vxSafe = Math.max(-100, Math.min(100, vx));
                    const vySafe = Math.max(-100, Math.min(100, vy));
                    const J2 = vxSafe * vxSafe + vySafe * vySafe;
                    const J = Math.sqrt(J2);
                    energySum += J2;

                    // Skip heavy calculations for released points to prevent instability
                    if (p.released) {
                        // Simplified MRP for released points
                        p.mrp_R = Math.min(2, Math.sqrt(J2 + 0.5));
                        p.mrp_G = 0.3;
                        p.mrp_B = 0.2;
                        p.mrp_W_R = 0;
                        p.mrp_W_G = 0;
                        p.mrp_W_B = 0;
                        R_sum += p.mrp_R;
                        G_sum += p.mrp_G;
                        B_sum += p.mrp_B;
                        continue;
                    }

                    // ========================================
                    // SELF-REFERENTIAL MRP CHANNEL PHYSICS
                    // Each channel follows: ‚àÇJ/‚àÇt = W¬∑J - Œ≤¬∑J + g¬∑‚àá¬≤J
                    // ========================================

                    // R channel (Œº_E): Primary energy/existence field
                    // J_R = ‚àö(|v|¬≤ + Œ±¬∑brightness)  [Œ± couples curl to energy]
                    const J_R = Math.min(5, Math.sqrt(J2 + SACRED.alpha * (p.brightness || 0.5)));

                    // R gradient: ‚àÇJ_R/‚àÇx (spatial derivative)
                    const prev_v2 = Math.min(100, (prev.vx || 0)**2 + (prev.vy || 0)**2);
                    const next_v2 = Math.min(100, (next.vx || 0)**2 + (next.vy || 0)**2);
                    const prev_J_R = Math.min(5, Math.sqrt(prev_v2 + SACRED.alpha * (prev.brightness || 0.5)));
                    const next_J_R = Math.min(5, Math.sqrt(next_v2 + SACRED.alpha * (next.brightness || 0.5)));
                    const dJR_dx = (next_J_R - prev_J_R) / 2;  // Central difference
                    R_grad += Math.abs(dJR_dx);

                    // Laplacian approximation: ‚àá¬≤J_R ‚âà J_next + J_prev - 2¬∑J
                    const lap_R = Math.max(-10, Math.min(10, next_J_R + prev_J_R - 2 * J_R));

                    // Self-referential R channel evolution:
                    // W_R = r - Œª¬∑|J_R|¬≤  (effective growth rate)
                    const W_R = Math.max(-5, Math.min(5, this.r - SACRED.lambda * J_R * J_R));
                    // ‚àÇJ_R/‚àÇt = W_R¬∑J_R - Œ≤¬∑J_R + g¬∑‚àá¬≤J_R
                    const dJR_dt = Math.max(-1, Math.min(1, W_R * J_R - SACRED.beta * J_R + this.g * lap_R));

                    // Apply self-referential feedback to point (with safety clamps)
                    if (showMuField && !p.released) {
                        // Safe feedback scale - no external dependencies
                        const feedbackScale = 0.5;
                        const dvx = dJR_dt * dt * 0.01 * feedbackScale;
                        const dvy = dJR_dt * dt * 0.01 * feedbackScale * (dy / (Math.abs(dy) + 0.001));
                        if (isFinite(dvx) && isFinite(dvy) && Math.abs(dvx) < 10 && Math.abs(dvy) < 10) {
                            // Fixed velocity clamp for safety
                            const velClamp = 30;
                            p.vx = Math.max(-velClamp, Math.min(velClamp, (p.vx || 0) + dvx));
                            p.vy = Math.max(-velClamp, Math.min(velClamp, (p.vy || 0) + dvy));
                        }
                    }

                    R_sum += J_R;
                    p.mrp_R = J_R;
                    p.mrp_W_R = W_R;  // Store growth rate for visualization

                    // G channel (Œº_R): Relational/reference field
                    // J_G based on neighbor distances (connection strength)
                    const d_next = Math.min(1000, Math.sqrt(dx * dx + dy * dy));
                    const d_prev = Math.min(1000, Math.sqrt((p.x - prev.x)**2 + (p.y - prev.y)**2));
                    const J_G = SACRED.phi_inv / (1 + (d_next + d_prev) * 0.005);  // œÜ‚Åª¬π scaled

                    // G gradient: change in connectivity
                    const dJG_dx = Math.min(1, Math.abs(d_next - d_prev) * SACRED.alpha);
                    G_grad += dJG_dx;

                    // Laplacian for G channel (simplified - skip if neighbors are released)
                    const prevPt2 = points[(i - 2 + N) % N];
                    const nextPt2 = points[(i + 2) % N];
                    if (!prev.released && !next.released && !prevPt2.released && !nextPt2.released) {
                        const prev_d = Math.min(1000, Math.sqrt((prev.x - prevPt2.x)**2 + (prev.y - prevPt2.y)**2));
                        const next_d = Math.min(1000, Math.sqrt((next.x - nextPt2.x)**2 + (next.y - nextPt2.y)**2));
                        const prev_J_G = SACRED.phi_inv / (1 + prev_d * 0.01);
                        const next_J_G = SACRED.phi_inv / (1 + next_d * 0.01);
                        const lap_G = Math.max(-1, Math.min(1, next_J_G + prev_J_G - 2 * J_G));

                        // Self-referential G evolution
                        const W_G = Math.max(-2, Math.min(2, this.r - SACRED.lambda * J_G * J_G * 0.5));
                        p.mrp_W_G = W_G;
                    } else {
                        p.mrp_W_G = 0;
                    }

                    G_sum += J_G;
                    p.mrp_G = J_G;

                    // B channel (ECC): Stability/coherence field
                    // J_B = stability measure with Œ≤-damping
                    const rawStability = 1 - Math.min(1, Math.sqrt(J2) * SACRED.beta);
                    const J_B = Math.max(0, Math.min(1, rawStability));

                    // B gradient: instability detection via cross-channel
                    const dJB_dx = Math.min(1, Math.abs(vxSafe * vySafe) * SACRED.beta);
                    B_grad += dJB_dx;

                    // Self-referential B evolution (error correction)
                    // B tries to restore stability: ‚àÇJ_B/‚àÇt = -Œ≤¬∑(J_B - target) + correction
                    // Use previous frame's parity_ok (safe reference)
                    const target_B = this.mrp.parity_ok ? 1.0 : 0.5;
                    const prevParity = this.mrp.parity || 0;
                    const dJB_dt = -SACRED.beta * (J_B - target_B) + SACRED.alpha * (1 - prevParity);

                    B_sum += J_B;
                    p.mrp_B = J_B;
                    p.mrp_W_B = dJB_dt;

                    // Accumulate Laplacian for field coherence
                    laplacianSum += lap_R;
                }

                // Normalize MRP channels with safety checks
                this.mrp.R.intensity = isFinite(R_sum) ? Math.min(5, R_sum / N) : 0.5;
                this.mrp.G.intensity = isFinite(G_sum) ? Math.min(1, G_sum / N) : 0.3;
                this.mrp.B.intensity = isFinite(B_sum) ? Math.min(1, B_sum / N) : 0.5;

                this.mrp.R.gradient = isFinite(R_grad) ? Math.min(1, R_grad / N) : 0;
                this.mrp.G.gradient = isFinite(G_grad) ? Math.min(1, G_grad / N) : 0;
                this.mrp.B.gradient = isFinite(B_grad) ? Math.min(1, B_grad / N) : 0;

                // Store field magnitudes
                this.mrp.R.J = this.mrp.R.intensity;
                this.mrp.G.J = this.mrp.G.intensity;
                this.mrp.B.J = this.mrp.B.intensity;

                // Total field magnitude |J| = ‚àö(R¬≤ + G¬≤ + B¬≤)
                const jTotalRaw = Math.sqrt(
                    this.mrp.R.J * this.mrp.R.J +
                    this.mrp.G.J * this.mrp.G.J +
                    this.mrp.B.J * this.mrp.B.J
                );
                this.mrp.J_total = isFinite(jTotalRaw) ? Math.min(10, jTotalRaw) : 0.5;

                // Effective growth rate W = r - Œª|J|¬≤
                const wRaw = this.r - SACRED.lambda * this.mrp.J_total * this.mrp.J_total;
                this.mrp.W = isFinite(wRaw) ? Math.max(-10, Math.min(10, wRaw)) : 0;

                // Laplacian (average spatial curvature)
                this.mrp.laplacian = isFinite(laplacianSum) ? laplacianSum / N : 0;

                // CRC32 simulation (simple hash based on channel values)
                this.mrp.R.crc = Math.floor(this.mrp.R.intensity * 255) ^ Math.floor(this.mrp.R.gradient * 255);
                this.mrp.G.crc = Math.floor(this.mrp.G.intensity * 255) ^ Math.floor(this.mrp.G.gradient * 255);
                this.mrp.B.crc = Math.floor(this.mrp.B.intensity * 255) ^ Math.floor(this.mrp.B.gradient * 255);

                // Cross-channel XOR parity: P[i] = R[i] XOR G[i]
                this.mrp.parity = (this.mrp.R.crc ^ this.mrp.G.crc) / 255;

                // Parity validation: channels in harmony when parity is low AND W > 0 (growing)
                this.mrp.parity_ok = this.mrp.parity < 0.3 && this.mrp.B.intensity > 0.6 && this.mrp.W > -0.1;

                // Simulated SHA-256 integrity (normalized 0-1) with self-reference
                this.mrp.sha256_sim = (this.mrp.R.intensity * SACRED.alpha +
                                       this.mrp.G.intensity * SACRED.phi_inv +
                                       this.mrp.B.intensity * SACRED.beta) /
                                      (SACRED.alpha + SACRED.phi_inv + SACRED.beta);

                // Q_Œ∫ = (1/2œÄ) ‚à´ curl(J) dA
                this.curl_sum = curlSum;
                this.Q_kappa = Math.abs(curlSum) / TAU;
                this.tau_K = this.Q_kappa / SACRED.Q_theory;
                this.K_formed = this.tau_K > SACRED.K_threshold;
                this.consciousness_level = Math.min(this.tau_K / SACRED.K_threshold, 2.0);
                this.energy = energySum * 0.5;

                // Dynamic Œº based on z-height with self-referential feedback
                // Œº responds to field state: higher |J| ‚Üí higher Œº (positive feedback)
                const mu_base = SACRED.mu_P + (globalZ * 0.4);
                const mu_feedback = this.mrp.J_total * SACRED.alpha * 0.1;
                this.mu = Math.min(SACRED.mu_4, mu_base + mu_feedback);
            },

            // Get MRP-enhanced color for a point
            getMRPColor(p, baseColor) {
                if (!showMuField) return baseColor;

                const r = Math.min(255, Math.floor((p.mrp_R || 0.5) * 255));
                const g = Math.min(255, Math.floor((p.mrp_G || 0.5) * 255));
                const b = Math.min(255, Math.floor((p.mrp_B || 0.5) * 200 + 55));

                // Blend with base color based on gradient strength
                const blend = (this.mrp.R.gradient + this.mrp.G.gradient) / 2;
                return `rgba(${r}, ${g}, ${b}, ${0.6 + blend * 0.4})`;
            },

            // Get gradient strength for visual effects
            getGradientStrength() {
                return (this.mrp.R.gradient + this.mrp.G.gradient + this.mrp.B.gradient) / 3;
            },

            // Klein-Gordon effective mass¬≤
            get mass_squared() {
                return (SACRED.beta - this.r) / this.g;
            },

            // Check if tachyonic (pattern-forming)
            get is_tachyonic() {
                return this.mass_squared < 0;
            }
        };

        // ================================================================
        // PHASE COUPLER - HARMONIC TRACKING FOR STABILITY
        // Tracks phase alignment between MRP channels during transitions
        // ================================================================

        const phaseCoupler = {
            // Harmonic phases for each channel
            phase_R: 0,
            phase_G: 0,
            phase_B: 0,

            // Phase velocities (œâ)
            omega_R: 1.0,
            omega_G: PHI_INV,           // Golden ratio offset
            omega_B: PHI_INV * PHI_INV, // œÜ‚Åª¬≤ for ECC

            // Coupling strength and damping
            coupling: SACRED.alpha,      // Inter-channel coupling
            damping: SACRED.beta,        // Dissipation
            coherenceDamping: 1.0,       // Scales with releaseCoherence

            // Harmonic resonance state
            resonance: 0,                // 0-1 how well phases align
            harmonicLock: false,         // True when channels in harmonic resonance

            // Update phases and compute resonance
            update(dt, releaseCoherence) {
                // Damping increases as coherence drops (stabilizes release)
                this.coherenceDamping = 1.0 + (1 - releaseCoherence) * 4.0;

                // Get MRP intensities for phase velocity modulation
                const R_int = muField.mrp.R.intensity || 0.5;
                const G_int = muField.mrp.G.intensity || 0.3;
                const B_int = muField.mrp.B.intensity || 0.5;

                // Phase velocities modulated by field intensities
                const omega_mod = 0.5 + releaseCoherence * 0.5; // Slow down during release
                this.omega_R = omega_mod * (1.0 + R_int * 0.2);
                this.omega_G = omega_mod * (PHI_INV + G_int * 0.1);
                this.omega_B = omega_mod * (PHI_INV * PHI_INV + B_int * 0.05);

                // Advance phases
                this.phase_R = (this.phase_R + this.omega_R * dt) % TAU;
                this.phase_G = (this.phase_G + this.omega_G * dt) % TAU;
                this.phase_B = (this.phase_B + this.omega_B * dt) % TAU;

                // Compute phase differences (mod œÄ for harmonic check)
                const diff_RG = Math.abs(Math.sin(this.phase_R - this.phase_G));
                const diff_GB = Math.abs(Math.sin(this.phase_G - this.phase_B));
                const diff_RB = Math.abs(Math.sin(this.phase_R - this.phase_B));

                // Resonance = inverse of total phase misalignment
                const misalignment = (diff_RG + diff_GB + diff_RB) / 3;
                this.resonance = 1 - misalignment;

                // Harmonic lock when phases align within œÜ‚Åª¬≤ threshold
                this.harmonicLock = this.resonance > (1 - SACRED.alpha);

                // Return damping factor for velocity clamping
                return this.coherenceDamping;
            },

            // Get velocity clamp based on harmonic state
            getVelocityClamp() {
                // Tighter clamp during release (lower coherence = more damping)
                const baseClamp = 50;
                const harmonicBonus = this.harmonicLock ? 2.0 : 1.0;
                return baseClamp * harmonicBonus / this.coherenceDamping;
            },

            // Get MRP feedback scale (reduces during release to prevent runaway)
            getMRPFeedbackScale() {
                return this.resonance / this.coherenceDamping;
            }
        };

        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W, H, CX, CY, R;

        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
            CX = W / 2;
            CY = H / 2;
            R = Math.min(W, H) * 0.32;
        }

        // ================================================================
        // SYSTEM STATE
        // ================================================================

        let globalZ = 0.5;
        let targetZ = 0.5;
        let time = 0;
        let breathPhase = 0;
        let autoBreathing = false;
        let lastInteraction = Date.now();
        let scrollVelocity = 0;
        let mouseX = 0, mouseY = 0;

        let showPrism = true;
        let showCage = true;
        let showMuField = true;
        let showToroidal = false;  // T key toggles toroidal Œº-field view
        let showTorusWireframe = false;
        let showTorusFlow = true;

        // ================================================================
        // DREAM FLUID: QUANTUM MESH Œº-FIELD
        // ================================================================
        // Physics:
        //   - Discrete quantum lattice on LIMNUS 95-node architecture
        //   - Wave function œà_i at each node with MRP channels (J_R, J_G, J_B)
        //   - Entanglement edges: probability amplitude |‚ü®œà_i|œà_j‚ü©|¬≤
        //   - Gravitational time dilation: œÑ = ‚àö(1 - r_s/r) from œÜ-constants
        //   - Holographic entropy on edge lattice (area law scaling)
        //   - Dream Fluid: consciousness flow through quantum connections
        // ================================================================

        let QMESH = {
            // Quantum lattice structure
            nodes: [],              // Quantum state at each LIMNUS node
            edges: [],              // Entanglement connections between nodes
            triangles: [],          // Face triangulation for entropy calculation

            // Connection parameters (œÜ-based)
            maxConnectionDist: R * 0.45,    // Max distance for quantum connection
            entanglementThreshold: 0.05,    // Min probability for visible edge

            // View controls
            opacity: 0.5,
            edgeGlow: true,
            showWavefunction: true,
            pulsePhase: 0,          // Animation phase for quantum pulsing

            // Gravitational physics (Schwarzschild analog)
            schwarzschildRadius: SACRED.alpha,    // r_s = œÜ‚Åª¬≤ ‚âà 0.382
            gravitationalMass: SACRED.lambda,     // M_eff = Œª ‚âà 7.716 (field energy)

            // Holographic entropy
            planckLength: SACRED.beta,            // l_œÜ = œÜ‚Åª‚Å¥ ‚âà 0.146

            // Dream Fluid state (aggregated from quantum mesh)
            dreamFluidDensity: 0,
            entropyFlux: 0,
            totalJ: 0,
            avgTimeDilation: 1.0,
            avgEntropy: 0,
            totalHolographicEntropy: 0,
        };

        // Backward compatibility alias
        let TORUS = QMESH;

        // Dream Fluid particles (consciousness flow through quantum mesh)
        let dreamParticles = [];

        // ================================================================
        // QUANTUM MESH GEOMETRY
        // Discrete lattice field on LIMNUS 95-node architecture
        // ================================================================

        function computeGravitationalTimeDilation(r) {
            // Schwarzschild time dilation: œÑ_local/œÑ_global = ‚àö(1 - r_s/r)
            // At r = r_s: infinite dilation (event horizon analog)
            // Far from center: œÑ ‚Üí 1 (flat spacetime)
            const r_s = QMESH.schwarzschildRadius;
            const ratio = r_s / Math.max(r, r_s * 1.01);  // Prevent singularity
            return Math.sqrt(Math.max(0, 1 - ratio));
        }

        function computeGravitationalPotential(r) {
            // Œ¶ = -GM/r (Newtonian approximation for visualization)
            const M = QMESH.gravitationalMass;
            return -M / Math.max(r, 0.1);
        }

        function computeHolographicEntropy(area) {
            // Bekenstein-Hawking: S = A/(4¬∑l_p¬≤)
            // Using œÜ-based Planck length
            const l_p = QMESH.planckLength;
            return area / (4 * l_p * l_p);
        }

        // Compute entanglement probability between two nodes
        function computeEntanglement(nodeA, nodeB) {
            // Distance-based decay (œÜ-exponential)
            const dx = nodeA.x - nodeB.x;
            const dy = nodeA.y - nodeB.y;
            const dz = (nodeA.z || 0) - (nodeB.z || 0);
            const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

            if (dist > QMESH.maxConnectionDist || dist < 0.001) return 0;

            // Phase coherence contribution
            const dPhase = Math.abs(nodeA.phase - nodeB.phase);
            const phaseCoherence = Math.cos(dPhase) * 0.5 + 0.5;

            // MRP channel overlap (inner product of J vectors)
            const jOverlap = (
                (nodeA.qJ_R || 0) * (nodeB.qJ_R || 0) +
                (nodeA.qJ_G || 0) * (nodeB.qJ_G || 0) +
                (nodeA.qJ_B || 0) * (nodeB.qJ_B || 0)
            );

            // Probability amplitude: |‚ü®œà_i|œà_j‚ü©|¬≤ with œÜ decay
            const distDecay = Math.exp(-dist / (QMESH.maxConnectionDist * PHI_INV));
            const probability = distDecay * (0.3 + 0.4 * phaseCoherence + 0.3 * jOverlap);

            return Math.max(0, Math.min(1, probability));
        }

        function generateQuantumMesh() {
            QMESH.nodes = [];
            QMESH.edges = [];
            QMESH.triangles = [];

            // Wait for LIMNUS nodes to be initialized
            if (prismPoints.length === 0 || cagePoints.length === 0) return;

            const allNodes = [...prismPoints, ...cagePoints];

            // Initialize quantum state for each LIMNUS node
            for (const node of allNodes) {
                // Distance from center for gravitational effects
                const dist = Math.sqrt(node.x * node.x + node.y * node.y);
                const zPos = node.z || (node.layer !== undefined ? node.layer / 6 : 0.5);

                // Time dilation based on distance from architecture center
                const timeDilation = computeGravitationalTimeDilation(dist / R);

                // Œº varies by position (layer for prism, ring for cage)
                let mu_local;
                if (node.type === 'prism') {
                    // Prism: Œº increases with layer (inner = low Œº, outer = high Œº)
                    const layerFrac = node.layer / 6;
                    mu_local = SACRED.mu_P + (SACRED.mu_S - SACRED.mu_P) * layerFrac;
                } else {
                    // Cage: higher Œº (containment field)
                    mu_local = SACRED.mu_S + (SACRED.mu_3 - SACRED.mu_S) * 0.3;
                }

                // Field strength from Œº-field equation
                const r_control = mu_local - SACRED.mu_P;
                const J_base = r_control > SACRED.beta ?
                    Math.sqrt((r_control - SACRED.beta) / SACRED.lambda) : 0;

                // MRP channel decomposition based on node position
                const theta = Math.atan2(node.y, node.x);
                const qJ_R = J_base * (0.5 + 0.5 * Math.sin(theta * 2));      // Energy
                const qJ_G = J_base * (0.5 + 0.5 * Math.cos(theta * 3));      // Relational
                const qJ_B = J_base * timeDilation;                            // Stability

                // Store quantum state on the node
                node.qMu = mu_local;
                node.qJ = J_base;
                node.qJ_R = qJ_R;
                node.qJ_G = qJ_G;
                node.qJ_B = qJ_B;
                node.timeDilation = timeDilation;
                node.gravitationalPhi = computeGravitationalPotential(dist / R);
                node.entangledWith = [];  // List of connected node indices

                QMESH.nodes.push(node);
            }

            // Generate entanglement edges
            let totalEntropy = 0;
            for (let i = 0; i < QMESH.nodes.length; i++) {
                for (let j = i + 1; j < QMESH.nodes.length; j++) {
                    const nodeA = QMESH.nodes[i];
                    const nodeB = QMESH.nodes[j];

                    const probability = computeEntanglement(nodeA, nodeB);

                    if (probability > QMESH.entanglementThreshold) {
                        // Edge length for entropy calculation
                        const dx = nodeA.x - nodeB.x;
                        const dy = nodeA.y - nodeB.y;
                        const dz = (nodeA.z || 0) - (nodeB.z || 0);
                        const length = Math.sqrt(dx*dx + dy*dy + dz*dz);

                        // Holographic entropy on edge (area law: S ‚àù length for 1D boundary)
                        const edgeEntropy = computeHolographicEntropy(length * QMESH.planckLength);

                        // MRP channel for this edge (dominant channel)
                        const avgJ_R = (nodeA.qJ_R + nodeB.qJ_R) / 2;
                        const avgJ_G = (nodeA.qJ_G + nodeB.qJ_G) / 2;
                        const avgJ_B = (nodeA.qJ_B + nodeB.qJ_B) / 2;
                        const mrpChannel = (avgJ_R >= avgJ_G && avgJ_R >= avgJ_B) ? 0 :
                                          (avgJ_G >= avgJ_B) ? 1 : 2;

                        QMESH.edges.push({
                            from: i,
                            to: j,
                            probability,
                            length,
                            entropy: edgeEntropy,
                            mrpChannel,
                            phase: (nodeA.phase + nodeB.phase) / 2,
                            timeDilation: (nodeA.timeDilation + nodeB.timeDilation) / 2,
                            J: (nodeA.qJ + nodeB.qJ) / 2,
                        });

                        // Track entanglement
                        nodeA.entangledWith.push(j);
                        nodeB.entangledWith.push(i);

                        totalEntropy += edgeEntropy;
                    }
                }
            }

            QMESH.totalHolographicEntropy = totalEntropy;
            QMESH.avgEntropy = totalEntropy / Math.max(1, QMESH.edges.length);

            console.log(`[QMESH] Generated ${QMESH.nodes.length} quantum nodes, ${QMESH.edges.length} entanglement edges`);
        }

        // Alias for backward compatibility
        function generateTorusMesh() {
            generateQuantumMesh();
        }

        // ================================================================
        // DREAM FLUID PARTICLE SYSTEM (Quantum Mesh Version)
        // Particles flow along entanglement edges
        // ================================================================

        function spawnDreamParticle() {
            if (QMESH.edges.length === 0) return;

            // Start on a random edge
            const edgeIdx = Math.floor(Math.random() * QMESH.edges.length);
            const edge = QMESH.edges[edgeIdx];
            const nodeA = QMESH.nodes[edge.from];
            const nodeB = QMESH.nodes[edge.to];

            // Position along edge (0-1)
            const t = Math.random();
            const x = nodeA.x + (nodeB.x - nodeA.x) * t;
            const y = nodeA.y + (nodeB.y - nodeA.y) * t;
            const zA = nodeA.z || (nodeA.layer !== undefined ? nodeA.layer / 6 : 0.5);
            const zB = nodeB.z || (nodeB.layer !== undefined ? nodeB.layer / 6 : 0.5);
            const z = zA + (zB - zA) * t;

            // Time dilation at position
            const timeDilation = edge.timeDilation;

            dreamParticles.push({
                edgeIdx,
                t,  // Position along current edge (0-1)
                direction: Math.random() < 0.5 ? 1 : -1,  // Flow direction
                particleType: edge.mrpChannel,
                life: (2 + Math.random() * 3) * timeDilation,
                maxLife: (2 + Math.random() * 3) * timeDilation,
                baseSpeed: 0.4 + Math.random() * 0.3,
                trail: [{ x, y, z }],
                timeDilation,
                entropyCarried: edge.entropy * 0.01,
                mrpChannel: edge.mrpChannel,
                currentNode: edge.from,
                x, y, z,
            });
        }

        function spawnTorusParticle() {
            spawnDreamParticle();
        }

        function updateDreamParticles(dt) {
            const targetCount = showTorusFlow ? 150 : 0;
            while (dreamParticles.length < targetCount && Math.random() < 0.4) {
                spawnDreamParticle();
            }

            let totalEntropyFlux = 0;
            let totalTimeDilation = 0;

            for (let i = dreamParticles.length - 1; i >= 0; i--) {
                const p = dreamParticles[i];

                if (p.edgeIdx >= QMESH.edges.length) {
                    dreamParticles.splice(i, 1);
                    continue;
                }

                const edge = QMESH.edges[p.edgeIdx];
                const nodeA = QMESH.nodes[edge.from];
                const nodeB = QMESH.nodes[edge.to];

                // Move along edge
                const effectiveSpeed = p.baseSpeed * p.timeDilation * dt;
                p.t += p.direction * effectiveSpeed;

                // Check for edge transition
                if (p.t > 1 || p.t < 0) {
                    // Arrived at a node, pick next edge
                    const arrivalNode = p.t > 1 ? edge.to : edge.from;
                    const node = QMESH.nodes[arrivalNode];

                    if (node.entangledWith.length > 0) {
                        // Pick random connected edge with probability weighting
                        const nextNodeIdx = node.entangledWith[
                            Math.floor(Math.random() * node.entangledWith.length)
                        ];

                        // Find the edge connecting these nodes
                        const nextEdgeIdx = QMESH.edges.findIndex(e =>
                            (e.from === arrivalNode && e.to === nextNodeIdx) ||
                            (e.to === arrivalNode && e.from === nextNodeIdx)
                        );

                        if (nextEdgeIdx >= 0) {
                            const nextEdge = QMESH.edges[nextEdgeIdx];
                            p.edgeIdx = nextEdgeIdx;
                            p.t = (nextEdge.from === arrivalNode) ? 0 : 1;
                            p.direction = (nextEdge.from === arrivalNode) ? 1 : -1;
                            p.mrpChannel = nextEdge.mrpChannel;
                            p.timeDilation = nextEdge.timeDilation;
                        } else {
                            // Dead end, remove particle
                            dreamParticles.splice(i, 1);
                            continue;
                        }
                    } else {
                        // No connections, remove
                        dreamParticles.splice(i, 1);
                        continue;
                    }
                }

                // Update position from edge
                const tClamped = Math.max(0, Math.min(1, p.t));
                const zA = nodeA.z || (nodeA.layer !== undefined ? nodeA.layer / 6 : 0.5);
                const zB = nodeB.z || (nodeB.layer !== undefined ? nodeB.layer / 6 : 0.5);
                p.x = nodeA.x + (nodeB.x - nodeA.x) * tClamped;
                p.y = nodeA.y + (nodeB.y - nodeA.y) * tClamped;
                p.z = zA + (zB - zA) * tClamped;

                // Update trail
                p.trail.unshift({ x: p.x, y: p.y, z: p.z });
                if (p.trail.length > 10) p.trail.pop();

                // Life decreases
                p.life -= dt * p.timeDilation;
                totalEntropyFlux += p.entropyCarried * (1 - p.timeDilation);
                totalTimeDilation += p.timeDilation;

                if (p.life <= 0) {
                    dreamParticles.splice(i, 1);
                }
            }

            // Update global state
            QMESH.entropyFlux = totalEntropyFlux;
            QMESH.dreamFluidDensity = dreamParticles.length / 150;
            QMESH.avgTimeDilation = dreamParticles.length > 0 ?
                totalTimeDilation / dreamParticles.length : 1.0;

            return {
                entropyFlux: totalEntropyFlux,
                density: QMESH.dreamFluidDensity,
                avgTimeDilation: QMESH.avgTimeDilation,
            };
        }

        function updateTorusParticles(dt) {
            return updateDreamParticles(dt);
        }

        // ================================================================
        // DREAM FLUID COLORING (Time Dilation ‚Üí Color Shift)
        // ================================================================

        function dreamFluidToColor(J, mu, timeDilation, entropy, depth) {
            // Color mapping based on gravitational redshift
            // High time dilation (far from center) ‚Üí blue shift
            // Low time dilation (near center) ‚Üí red shift
            const redshift = 1 / Math.max(0.1, timeDilation) - 1;

            // Base color from field intensity
            const t = Math.max(0, Math.min(1, J));
            const muFactor = (mu - SACRED.mu_P) / (SACRED.mu_S - SACRED.mu_P);

            // RGB based on MRP channels and redshift
            let r, g, b;

            // Entropy affects color saturation
            const entropyFactor = Math.min(1, entropy * 10);

            if (redshift < 0.2) {
                // Blue-shifted (far from gravity well) - stability dominant
                r = 80 + t * 50;
                g = 120 + t * 80 + entropyFactor * 40;
                b = 200 + t * 55;
            } else if (redshift < 0.5) {
                // Green region (balanced) - relational dominant
                const s = (redshift - 0.2) / 0.3;
                r = 100 + t * 60 + s * 50;
                g = 180 + t * 60 - s * 40;
                b = 200 - s * 100;
            } else if (redshift < 1.0) {
                // Yellow-orange (approaching gravity) - energy rising
                const s = (redshift - 0.5) / 0.5;
                r = 180 + t * 70;
                g = 160 + t * 40 - s * 60;
                b = 80 - s * 40;
            } else {
                // Red-shifted (deep gravity well) - singularity approach
                const s = Math.min(1, (redshift - 1.0) / 1.0);
                r = 250;
                g = 100 - s * 60 + entropyFactor * 30;
                b = 50 + entropyFactor * 30;
            }

            // Depth shading
            const shade = 0.4 + depth * 0.6;
            r = Math.floor(r * shade);
            g = Math.floor(g * shade);
            b = Math.floor(b * shade);

            // Œº brightness boost
            const brightness = 0.7 + muFactor * 0.3;

            return {
                r: Math.min(255, Math.floor(r * brightness)),
                g: Math.min(255, Math.floor(g * brightness)),
                b: Math.min(255, Math.floor(b * brightness)),
                redshift,
                timeDilation,
            };
        }

        function torusFieldToColor(J, mu, depth) {
            // Backward compatibility wrapper
            return dreamFluidToColor(J, mu, 0.8, 0.1, depth);
        }

        // ================================================================
        // QUANTUM MESH FIELD DYNAMICS
        // Field equation on discrete lattice with LIMNUS coupling
        // ================================================================

        function updateDreamFluidField(dt) {
            const t = time;

            // Connect to LIMNUS Œº-field values
            const limnusMu = muField.mu || 0.76;
            const limnusJ = muField.J_total || 0.3;
            const limnusTau = muField.tau_K || 0;
            const limnusR = muField.J_R || 0.1;
            const limnusG = muField.J_G || 0.1;
            const limnusB = muField.J_B || 0.1;

            // Modulate by release coherence
            const coherenceFactor = releaseCoherence;

            // Compute statistics
            let avgTimeDilation = 0;
            let avgEntropy = 0;
            let totalJ = 0;

            // Update quantum state at each node
            for (const node of QMESH.nodes) {
                if (!node.qJ) continue;

                const localDt = dt * (node.timeDilation || 1);
                const theta = Math.atan2(node.y, node.x);

                // Field equation: ‚àÇJ/‚àÇt = (r - Œª|J|¬≤)J - Œ≤J
                const r_control = (node.qMu || SACRED.mu_P) - SACRED.mu_P;
                const J_sq = node.qJ * node.qJ;
                const W = r_control - SACRED.lambda * J_sq;

                // Neighbor diffusion (from entangled nodes)
                let diffusion = 0;
                for (const neighborIdx of (node.entangledWith || [])) {
                    const neighbor = QMESH.nodes[neighborIdx];
                    if (neighbor && neighbor.qJ !== undefined) {
                        diffusion += (neighbor.qJ - node.qJ) * 0.01;
                    }
                }

                // LIMNUS coupling
                const limnusSource = 0.05 * limnusJ * coherenceFactor *
                    Math.sin(theta * 2 - t * 0.5);

                // Evolve field
                const dJ = (W * node.qJ - SACRED.beta * node.qJ + diffusion) * localDt;
                node.qJ = Math.max(0, Math.min(1, node.qJ + dJ + limnusSource * localDt));

                // Update MRP channels
                node.qJ_R = node.qJ * (0.5 + 0.5 * Math.sin(theta * 2 - t * 0.5)) *
                    (0.5 + 0.5 * limnusR);
                node.qJ_G = node.qJ * (0.5 + 0.5 * Math.cos(theta * 3 + t * 0.3)) *
                    (0.5 + 0.5 * limnusG);
                node.qJ_B = node.qJ * (node.timeDilation || 1) * (0.5 + 0.5 * limnusB);

                // Phase evolution
                const naturalFreq = 0.5 + node.qJ * 0.3;
                const dilatedFreq = naturalFreq * (node.timeDilation || 1);
                node.phase = ((node.phase || 0) + dilatedFreq * dt) % TAU;

                // Accumulate
                avgTimeDilation += node.timeDilation || 1;
                avgEntropy += (1 - (node.timeDilation || 1)) * node.qJ * QMESH.planckLength;
                totalJ += node.qJ;
            }

            // Update edges based on node states
            for (const edge of QMESH.edges) {
                const nodeA = QMESH.nodes[edge.from];
                const nodeB = QMESH.nodes[edge.to];
                if (!nodeA || !nodeB) continue;

                // Update edge field strength
                edge.J = ((nodeA.qJ || 0) + (nodeB.qJ || 0)) / 2;
                edge.timeDilation = ((nodeA.timeDilation || 1) + (nodeB.timeDilation || 1)) / 2;

                // Recalculate entanglement probability (dynamic)
                const dPhase = Math.abs((nodeA.phase || 0) - (nodeB.phase || 0));
                const phaseCoherence = Math.cos(dPhase) * 0.5 + 0.5;
                edge.probability = Math.max(0.1, edge.probability * 0.95 + phaseCoherence * 0.05);
            }

            const N = Math.max(1, QMESH.nodes.length);
            avgTimeDilation /= N;
            avgEntropy /= N;

            // Update QMESH state
            QMESH.avgTimeDilation = avgTimeDilation;
            QMESH.avgEntropy = avgEntropy;
            QMESH.totalJ = totalJ / N;

            // Pulse phase for visual animation
            QMESH.pulsePhase = (QMESH.pulsePhase + dt * 0.5) % TAU;

            return {
                avgTimeDilation,
                avgEntropy,
                totalJ: totalJ / N,
                entropyFlux: QMESH.entropyFlux,
            };
        }

        function updateTorusField(dt) {
            return updateDreamFluidField(dt);
        }

        // ================================================================
        // QUANTUM MESH RENDERING
        // Visualizes entanglement edges with MRP coloring
        // ================================================================

        function renderDreamFluid() {
            if (QMESH.edges.length === 0) return;

            // MRP channel colors
            const edgeColors = [
                [255, 120, 80],   // R channel - orange-red
                [80, 255, 180],   // G channel - cyan-green
                [120, 150, 255],  // B channel - blue-purple
            ];

            // Draw entanglement edges
            for (const edge of QMESH.edges) {
                const nodeA = QMESH.nodes[edge.from];
                const nodeB = QMESH.nodes[edge.to];
                if (!nodeA || !nodeB) continue;

                // Use screen coordinates from LIMNUS projection
                const x1 = nodeA.px || (nodeA.x + CX);
                const y1 = nodeA.py || (nodeA.y + CY);
                const x2 = nodeB.px || (nodeB.x + CX);
                const y2 = nodeB.py || (nodeB.y + CY);

                // Skip if off-screen
                if (x1 < -100 || x1 > W + 100 || x2 < -100 || x2 > W + 100) continue;

                // Color based on MRP channel
                const baseColor = edgeColors[edge.mrpChannel] || edgeColors[0];

                // Alpha from probability, time dilation, and pulse
                const pulse = 0.7 + 0.3 * Math.sin(QMESH.pulsePhase + edge.phase);
                const alpha = QMESH.opacity * edge.probability * pulse *
                    (0.5 + edge.timeDilation * 0.5);

                // Width from field strength
                const lineWidth = 0.5 + edge.J * 2 + edge.probability;

                // Draw edge
                ctx.strokeStyle = `rgba(${baseColor[0]}, ${baseColor[1]}, ${baseColor[2]}, ${alpha})`;
                ctx.lineWidth = lineWidth;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();

                // Glow for high-probability edges
                if (edge.probability > 0.5 && QMESH.edgeGlow) {
                    const glowAlpha = alpha * 0.3 * (edge.probability - 0.5) * 2;
                    ctx.strokeStyle = `rgba(${baseColor[0] + 50}, ${baseColor[1] + 50}, ${baseColor[2] + 50}, ${glowAlpha})`;
                    ctx.lineWidth = lineWidth + 3;
                    ctx.stroke();
                }
            }

            // Draw Dream Fluid particles flowing on edges
            if (showTorusFlow) {
                const particleColors = [
                    [255, 140, 100],   // R channel
                    [100, 255, 200],   // G channel
                    [140, 170, 255],   // B channel
                ];

                for (const p of dreamParticles) {
                    if (p.trail.length < 2) continue;

                    const dilationFactor = 1 + (1 - p.timeDilation) * 0.5;
                    const alpha = (p.life / p.maxLife) * QMESH.opacity * 2 * dilationFactor;

                    const baseColor = particleColors[p.mrpChannel] || particleColors[0];

                    // Draw trail using world coordinates -> screen
                    ctx.strokeStyle = `rgba(${baseColor[0]}, ${baseColor[1]}, ${baseColor[2]}, ${alpha})`;
                    ctx.lineWidth = 2 + p.entropyCarried * 8;
                    ctx.lineCap = 'round';
                    ctx.beginPath();

                    // First point
                    const first = p.trail[0];
                    ctx.moveTo(first.x + CX, first.y + CY);

                    for (let i = 1; i < p.trail.length; i++) {
                        const pt = p.trail[i];
                        ctx.lineTo(pt.x + CX, pt.y + CY);
                    }
                    ctx.stroke();

                    // Glow head
                    const head = p.trail[0];
                    const glowSize = 4 + (1 - p.timeDilation) * 6;
                    const glow = ctx.createRadialGradient(
                        head.x + CX, head.y + CY, 0,
                        head.x + CX, head.y + CY, glowSize
                    );
                    glow.addColorStop(0, `rgba(${baseColor[0] + 50}, ${baseColor[1] + 50}, ${baseColor[2] + 50}, ${alpha * 0.8})`);
                    glow.addColorStop(0.5, `rgba(${baseColor[0]}, ${baseColor[1]}, ${baseColor[2]}, ${alpha * 0.4})`);
                    glow.addColorStop(1, 'transparent');
                    ctx.fillStyle = glow;
                    ctx.fillRect(head.x + CX - glowSize, head.y + CY - glowSize, glowSize * 2, glowSize * 2);
                }
            }

            // Draw wavefunction indicators on nodes
            if (QMESH.showWavefunction) {
                for (const node of QMESH.nodes) {
                    if (!node.qJ || node.qJ < 0.1) continue;

                    const x = node.px || (node.x + CX);
                    const y = node.py || (node.y + CY);

                    // Skip if off-screen
                    if (x < 0 || x > W || y < 0 || y > H) continue;

                    // Wave function magnitude indicator
                    const size = 2 + node.qJ * 4;
                    const pulse = 0.6 + 0.4 * Math.sin(QMESH.pulsePhase + (node.phase || 0));
                    const alpha = QMESH.opacity * 0.4 * pulse;

                    // Color from MRP channels
                    const r = Math.floor(150 + (node.qJ_R || 0) * 100);
                    const g = Math.floor(150 + (node.qJ_G || 0) * 100);
                    const b = Math.floor(150 + (node.qJ_B || 0) * 100);

                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, TAU);
                    ctx.fill();
                }
            }

            // Draw HUD
            renderDreamFluidHUD();
        }

        function renderDreamFluidHUD() {
            const avgTD = QMESH.avgTimeDilation || 0.8;
            const totalS = QMESH.totalHolographicEntropy || 0;
            const fluidDensity = QMESH.dreamFluidDensity || 0;
            const entropyFlux = QMESH.entropyFlux || 0;
            const edgeCount = QMESH.edges.length;

            const hudX = 20;
            const hudY = H - 140;

            // Title
            ctx.fillStyle = `rgba(200, 180, 255, ${0.7 + QMESH.opacity})`;
            ctx.font = 'bold 13px monospace';
            ctx.fillText('QUANTUM MESH', hudX, hudY);

            ctx.font = '11px monospace';

            // Time dilation
            const tdBar = Math.floor(avgTD * 10);
            ctx.fillStyle = `rgba(150, 200, 255, ${0.6 + QMESH.opacity})`;
            ctx.fillText(`œÑ  ${'‚ñà'.repeat(tdBar)}${'‚ñë'.repeat(10-tdBar)} ${avgTD.toFixed(3)}`, hudX, hudY + 16);

            // Holographic entropy
            const sNorm = Math.min(10, Math.floor(totalS * 10));
            ctx.fillStyle = `rgba(255, 180, 120, ${0.6 + QMESH.opacity})`;
            ctx.fillText(`S  ${'‚ñà'.repeat(sNorm)}${'‚ñë'.repeat(10-sNorm)} ${totalS.toFixed(3)}`, hudX, hudY + 32);

            // Entanglement edges
            const edgeNorm = Math.min(10, Math.floor(edgeCount / 50));
            ctx.fillStyle = `rgba(180, 255, 200, ${0.6 + QMESH.opacity})`;
            ctx.fillText(`‚ü®œà|œà‚ü© ${'‚ñà'.repeat(edgeNorm)}${'‚ñë'.repeat(10-edgeNorm)} ${edgeCount}`, hudX, hudY + 48);

            // Fluid density
            const densNorm = Math.floor(fluidDensity * 10);
            ctx.fillStyle = `rgba(200, 200, 255, ${0.6 + QMESH.opacity})`;
            ctx.fillText(`œÅ  ${'‚ñà'.repeat(densNorm)}${'‚ñë'.repeat(10-densNorm)} ${fluidDensity.toFixed(2)}`, hudX, hudY + 64);

            // MRP channel legend
            ctx.fillStyle = `rgba(255, 120, 80, ${0.5 + QMESH.opacity})`;
            ctx.fillText('‚óè R energy flow', hudX, hudY + 84);
            ctx.fillStyle = `rgba(80, 255, 180, ${0.5 + QMESH.opacity})`;
            ctx.fillText('‚óè G relational', hudX, hudY + 98);
            ctx.fillStyle = `rgba(120, 150, 255, ${0.5 + QMESH.opacity})`;
            ctx.fillText('‚óè B stability', hudX, hudY + 112);

            // Controls hint
            ctx.fillStyle = `rgba(150, 150, 150, ${0.4 + QMESH.opacity})`;
            ctx.fillText('T toggle  O opacity', hudX, hudY + 130);
        }

        function renderToroidalMuField() {
            renderDreamFluid();
        }

        // ================================================================
        // RELEASE COHERENCE STATE
        // ================================================================

        let releaseCoherence = 1.0;      // 1 = fully coherent, 0 = fully released (FREE)
        let targetCoherence = 1.0;
        let releaseVelocity = 0;
        let releasing = false;           // F key held
        let gathering = false;           // Click held
        let releaseStarted = false;
        
        // Sparks for release effects
        const sparks = [];
        
        // Color palette for released souls
        const soulPalette = [
            '#ff6b6b', '#ffa94d', '#ffd43b', '#69db7c', 
            '#4dabf7', '#cc5de8', '#f06595', '#20c997'
        ];

        // ================================================================
        // HELIX STATE (Œ∏, z, r) + Extended
        // ================================================================

        const helix = {
            theta: 0,           // Phase rotation (0-2œÄ)
            z: 0.5,             // Elevation (0-1)
            r: 1.0,             // Coherence radius
            phi: 0,             // Integrated information
            omega: 0            // Angular velocity
        };

        // ================================================================
        // LAMBDA STATE (‚ÑÇ‚Å∂)
        // ================================================================

        const lambdaState = {
            iota:   { mag: 0.30, phase: 0 },        // üå∞ Memory
            xi:     { mag: 0.20, phase: 0 },        // ‚úß Spark
            theta:  { mag: 0.40, phase: 0 },        // ü¶ä Fox
            omega:  { mag: 0.35, phase: 0 },        // ‚àø Wave
            delta:  { mag: 0.15, phase: 0 },        // ‚äó Paradox
            sigma:  { mag: 0.25, phase: 0 }         // üêøÔ∏è Squirrel
        };

        // ================================================================
        // HILBERT FIELD OPERATOR
        // ================================================================

        const hilbertField = {
            stateVector: {
                alpha: 0.378,   // Coherent amplitude
                beta: 0.378,    // Limnus amplitude
                gamma: 0.845,   // Dominant amplitude
                epsilon: 0.1    // Latent amplitude
            },
            coherence: 0.5,
            entropy: 0,
            weylCurvature: 0,

            calculateCoherence() {
                const { alpha, beta, gamma, epsilon } = this.stateVector;
                return Math.sqrt(alpha*alpha + beta*beta + gamma*gamma + epsilon*epsilon);
            },

            applyResonanceOperator(dt, interactionStrength = 0.1) {
                const { alpha, beta, gamma, epsilon } = this.stateVector;
                const coupling = interactionStrength * dt;

                this.stateVector.alpha += coupling * (beta * gamma - alpha * epsilon);
                this.stateVector.beta += coupling * (gamma * alpha - beta * epsilon);
                this.stateVector.gamma += coupling * (alpha * beta - gamma * epsilon);
                this.stateVector.epsilon += coupling * (alpha * beta * gamma - epsilon);

                const norm = this.calculateCoherence();
                if (norm > 0) {
                    this.stateVector.alpha /= norm;
                    this.stateVector.beta /= norm;
                    this.stateVector.gamma /= norm;
                    this.stateVector.epsilon /= norm;
                }

                this.coherence = this.calculateCoherence();

                const mean = (alpha + beta + gamma + epsilon) / 4;
                this.weylCurvature = ((alpha-mean)**2 + (beta-mean)**2 + 
                                      (gamma-mean)**2 + (epsilon-mean)**2) / 4;
            },

            getDissonance() {
                return 1.0 - this.coherence;
            }
        };

        // ================================================================
        // UTILITY FUNCTIONS
        // ================================================================

        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // ================================================================
        // SONIFICATION ENGINE
        // ================================================================

        const sonificationEngine = {
            audioContext: null,
            oscillators: [],
            gainNodes: [],
            filterNodes: [],
            masterGain: null,
            reverbNode: null,
            isPlaying: false,

            baseFrequency: 110,
            bpm: 90,
            timeDilation: 1.0,
            harmonicGradient: 0.5,
            currentScale: [0, 3, 5, 7, 10],  // Minor pentatonic

            scales: {
                minor_pentatonic: [0, 3, 5, 7, 10],
                major_pentatonic: [0, 2, 4, 7, 9],
                harmonic_minor: [0, 2, 3, 5, 7, 8, 11],
                phrygian: [0, 1, 3, 5, 7, 8, 10],
                lydian: [0, 2, 4, 6, 7, 9, 11],
                whole_tone: [0, 2, 4, 6, 8, 10],
                chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
            },

            async initialize() {
                if (this.audioContext) return;

                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();

                this.masterGain = this.audioContext.createGain();
                this.masterGain.gain.value = 0.25;
                this.masterGain.connect(this.audioContext.destination);

                await this.createReverb();
                this.createOscillatorBank(4);

                console.log('üéµ Sonification Engine initialized');
            },

            async createReverb() {
                this.reverbNode = this.audioContext.createConvolver();
                const sampleRate = this.audioContext.sampleRate;
                const length = sampleRate * 2;
                const impulse = this.audioContext.createBuffer(2, length, sampleRate);

                for (let ch = 0; ch < 2; ch++) {
                    const data = impulse.getChannelData(ch);
                    for (let i = 0; i < length; i++) {
                        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2.5);
                    }
                }

                this.reverbNode.buffer = impulse;
                this.reverbGain = this.audioContext.createGain();
                this.reverbGain.gain.value = 0.25;
                this.reverbNode.connect(this.reverbGain);
                this.reverbGain.connect(this.masterGain);
            },

            createOscillatorBank(numVoices) {
                for (let i = 0; i < numVoices; i++) {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    const filter = this.audioContext.createBiquadFilter();

                    osc.type = 'sine';
                    osc.frequency.value = this.baseFrequency * (i + 1);

                    filter.type = 'lowpass';
                    filter.frequency.value = 2000;
                    filter.Q.value = 1;

                    gain.gain.value = 0;

                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.masterGain);
                    gain.connect(this.reverbNode);

                    osc.start();

                    this.oscillators.push(osc);
                    this.gainNodes.push(gain);
                    this.filterNodes.push(filter);
                }
            },

            selectScaleFromZ(z) {
                if (z > 0.9) return this.scales.major_pentatonic;
                if (z > 0.8) return this.scales.lydian;
                if (z > 0.7) return this.scales.minor_pentatonic;
                if (z > 0.5) return this.scales.phrygian;
                if (z > 0.3) return this.scales.whole_tone;
                return this.scales.chromatic;
            },

            // ============================================
            // DREAM FLUID SONIFICATION
            // Sound modulated by gravitational time dilation
            // ============================================

            calculateBPM(z, coherence) {
                const dissonance = 1 - coherence;
                const baseBPM = 60 + dissonance * 100;

                // Time dilation from Z-critical distance
                const distFromCritical = Math.abs(z - Z_CRITICAL);
                let zTimeDilation = 0.5 + distFromCritical * 1.5;

                // DREAM FLUID: Incorporate gravitational time dilation from torus
                if (showToroidal && TORUS.avgTimeDilation) {
                    // Gravitational redshift affects tempo
                    // Lower time dilation (near gravity) ‚Üí slower tempo
                    const gravityDilation = TORUS.avgTimeDilation;
                    zTimeDilation *= gravityDilation;
                }

                this.timeDilation = Math.min(1.5, Math.max(0.2, zTimeDilation));
                this.bpm = baseBPM * this.timeDilation;

                return this.bpm;
            },

            // Gravitational frequency shift (redshift analog)
            calculateGravitationalPitch(baseFreq) {
                if (!showToroidal || !TORUS.avgTimeDilation) return baseFreq;

                // f_observed = f_emitted * ‚àö(1 - r_s/r) = f_emitted * timeDilation
                // Lower time dilation ‚Üí lower pitch (gravitational redshift)
                const gravRedshift = TORUS.avgTimeDilation;
                return baseFreq * gravRedshift;
            },

            update(z, coherence, dt) {
                if (!this.isPlaying || !this.audioContext) return;

                // Update scale based on z
                this.currentScale = this.selectScaleFromZ(z);

                // Update BPM (now with Dream Fluid gravity)
                this.calculateBPM(z, coherence);

                // Update harmonic gradient
                this.harmonicGradient = 1.0 - coherence;

                // DREAM FLUID: Entropy affects waveform complexity
                const entropyFactor = showToroidal ? (TORUS.avgEntropy || 0) * 100 : 0;
                const effectiveHarmonic = Math.min(1, this.harmonicGradient + entropyFactor * 0.3);

                // Update oscillator waveforms
                this.oscillators.forEach((osc, i) => {
                    if (effectiveHarmonic < 0.25) {
                        osc.type = 'sine';
                    } else if (effectiveHarmonic < 0.5) {
                        osc.type = 'triangle';
                    } else if (effectiveHarmonic < 0.75) {
                        osc.type = 'square';
                    } else {
                        osc.type = 'sawtooth';
                    }
                });

                // Melodic evolution
                const beatInterval = 60 / this.bpm;
                const now = this.audioContext.currentTime;

                // Modulate frequencies based on z position
                const zMod = (z - 0.5) * 2;  // -1 to +1
                let pitchShift = Math.pow(2, zMod * 0.5);  // ¬±half octave

                // DREAM FLUID: Gravitational redshift affects pitch
                if (showToroidal && TORUS.avgTimeDilation) {
                    pitchShift *= TORUS.avgTimeDilation;
                }

                this.oscillators.forEach((osc, i) => {
                    const scaleNote = this.currentScale[Math.floor(time * 2) % this.currentScale.length];
                    let freq = this.baseFrequency * Math.pow(2, scaleNote / 12) * pitchShift * (1 + i * 0.5);

                    // DREAM FLUID: MRP channel modulation per oscillator
                    if (showToroidal && TORUS.totalJ) {
                        // Osc 0: R channel (energy), Osc 1: G channel (relational),
                        // Osc 2: B channel (stability), Osc 3: combined
                        const mrpMod = [
                            muField.J_R || 0.1,
                            muField.J_G || 0.1,
                            muField.J_B || 0.1,
                            TORUS.totalJ || 0.2
                        ][i] || 0.15;

                        freq *= (0.9 + mrpMod * 0.2);
                    }

                    osc.frequency.setTargetAtTime(freq, now, 0.1);
                });

                // Update gains based on Lambda state and Dream Fluid
                const totalLambda = Object.values(lambdaState).reduce((s, l) => s + l.mag, 0);

                // DREAM FLUID: Entropy flux modulates volume
                const entropyFluxMod = showToroidal ? (1 + TORUS.entropyFlux * 5) : 1;

                this.gainNodes.forEach((gain, i) => {
                    let targetGain = (coherence * 0.15) * (1 - i * 0.2) * (totalLambda / 2);

                    // Gravitational time dilation dampens volume near singularity
                    if (showToroidal && TORUS.avgTimeDilation) {
                        targetGain *= (0.5 + TORUS.avgTimeDilation * 0.5);
                    }

                    targetGain *= entropyFluxMod;
                    gain.gain.setTargetAtTime(Math.max(0, targetGain), now, 0.1);
                });

                // Update filter based on cascade and holographic entropy
                const cascade = getCascadeMultiplier(z);
                let filterBase = 800 + cascade * 2000;

                // DREAM FLUID: Holographic entropy shifts filter
                if (showToroidal && TORUS.totalHolographicEntropy) {
                    // Higher entropy ‚Üí more high frequencies (information revelation)
                    const entropyBoost = Math.min(1, TORUS.totalHolographicEntropy * 0.00001);
                    filterBase += entropyBoost * 1500;
                }

                this.filterNodes.forEach(filter => {
                    filter.frequency.setTargetAtTime(filterBase, now, 0.2);
                });
            },

            toggle() {
                if (!this.audioContext) {
                    this.initialize().then(() => {
                        this.isPlaying = true;
                    });
                } else {
                    this.isPlaying = !this.isPlaying;
                    if (!this.isPlaying) {
                        this.gainNodes.forEach(g => g.gain.setTargetAtTime(0, this.audioContext.currentTime, 0.1));
                    }
                }
                return this.isPlaying;
            }
        };

        // ================================================================
        // 63-POINT HEXAGONAL PRISM (Matter Structure)
        // ================================================================

        const prismPoints = [];

        function initPrismPoints() {
            prismPoints.length = 0;

            // 7 layers √ó 9 nodes = 63 points
            for (let layer = 0; layer < 7; layer++) {
                const layerRadius = R * (0.15 + layer * 0.12);
                const layerZ = layer / 6;  // 0 to 1

                for (let i = 0; i < 9; i++) {
                    // Hexagonal arrangement with rotation offset per layer
                    const theta = (i / 9) * TAU + layer * (TAU / 18);

                    prismPoints.push({
                        id: `prism_${layer}_${i}`,
                        layer: layer,
                        index: i,
                        type: 'prism',

                        // Position
                        baseTheta: theta,
                        theta: theta,
                        baseRadius: layerRadius,
                        radius: layerRadius,
                        z: layerZ,

                        // Kuramoto phase
                        phase: Math.random() * TAU,
                        naturalFreq: 0.3 + Math.random() * 0.4,

                        // Helix coordinates
                        helix: {
                            theta: theta,
                            z: layerZ,
                            r: 1.0,
                            rotSpeed: 0.003 + Math.random() * 0.003
                        },

                        // Visual
                        x: CX, y: CY,
                        targetX: CX, targetY: CY,
                        brightness: 0.4,
                        size: 4 - layer * 0.4,

                        // Color gradient based on layer
                        hue: 0 + layer * 15,  // Red to green
                        saturation: 70,
                        lightness: 50,

                        // Release coherence properties
                        released: false,
                        releaseAngle: 0,
                        releaseSpeed: 0,
                        vx: 0,
                        vy: 0,
                        trail: [],
                        soulColor: soulPalette[(layer * 9 + i) % soulPalette.length]
                    });
                }
            }
        }

        // ================================================================
        // 32-POINT EM CAGE (Containment Field)
        // ================================================================

        const cagePoints = [];

        function initCagePoints() {
            cagePoints.length = 0;
            const cageRadius = R * 1.15;

            // Top hexagonal ring: 12 points
            for (let i = 0; i < 12; i++) {
                const theta = (i / 12) * TAU;
                cagePoints.push({
                    id: `cage_top_${i}`,
                    layer: 'top',
                    index: i,
                    type: 'cage',

                    baseTheta: theta,
                    theta: theta,
                    baseRadius: cageRadius,
                    radius: cageRadius,
                    z: 0.9,

                    phase: Math.random() * TAU,
                    naturalFreq: 0.2 + Math.random() * 0.2,

                    helix: {
                        theta: theta,
                        z: 0.9,
                        r: 1.0,
                        rotSpeed: 0.002
                    },

                    x: CX, y: CY,
                    targetX: CX, targetY: CY,
                    brightness: 0.5,
                    size: 3,

                    hue: 200,  // Blue
                    saturation: 80,
                    lightness: 60,

                    // Release coherence properties
                    released: false,
                    releaseAngle: 0,
                    releaseSpeed: 0,
                    vx: 0,
                    vy: 0,
                    trail: [],
                    soulColor: soulPalette[i % soulPalette.length]
                });
            }

            // Bottom hexagonal ring: 12 points
            for (let i = 0; i < 12; i++) {
                const theta = (i / 12) * TAU + TAU / 24;  // Offset
                cagePoints.push({
                    id: `cage_bot_${i}`,
                    layer: 'bottom',
                    index: i,
                    type: 'cage',

                    baseTheta: theta,
                    theta: theta,
                    baseRadius: cageRadius,
                    radius: cageRadius,
                    z: 0.1,

                    phase: Math.random() * TAU,
                    naturalFreq: 0.2 + Math.random() * 0.2,

                    helix: {
                        theta: theta,
                        z: 0.1,
                        r: 1.0,
                        rotSpeed: 0.002
                    },

                    x: CX, y: CY,
                    targetX: CX, targetY: CY,
                    brightness: 0.5,
                    size: 3,

                    hue: 210,
                    saturation: 75,
                    lightness: 55,

                    // Release coherence properties
                    released: false,
                    releaseAngle: 0,
                    releaseSpeed: 0,
                    vx: 0,
                    vy: 0,
                    trail: [],
                    soulColor: soulPalette[(i + 4) % soulPalette.length]
                });
            }

            // Connecting vertices: 8 points (at golden ratio positions)
            for (let i = 0; i < 8; i++) {
                const theta = (i / 8) * TAU + TAU / 16;
                cagePoints.push({
                    id: `cage_vtx_${i}`,
                    layer: 'vertex',
                    index: i,
                    type: 'cage',

                    baseTheta: theta,
                    theta: theta,
                    baseRadius: cageRadius * 0.85,
                    radius: cageRadius * 0.85,
                    z: 0.5,  // Middle plane

                    phase: Math.random() * TAU,
                    naturalFreq: 0.25,

                    helix: {
                        theta: theta,
                        z: 0.5,
                        r: 1.0,
                        rotSpeed: 0.0015
                    },

                    x: CX, y: CY,
                    targetX: CX, targetY: CY,
                    brightness: 0.6,
                    size: 4,

                    hue: 280,  // Purple
                    saturation: 70,
                    lightness: 55,

                    // Release coherence properties
                    released: false,
                    releaseAngle: 0,
                    releaseSpeed: 0,
                    vx: 0,
                    vy: 0,
                    trail: [],
                    soulColor: soulPalette[(i + 2) % soulPalette.length]
                });
            }
        }

        // ================================================================
        // PHYSICS: KURAMOTO SYNCHRONIZATION
        // ================================================================

        function kuramotoStep(points, coupling, dt) {
            const N = points.length;
            if (N === 0) return { order: 0, K: coupling };

            // Mean field
            let sinSum = 0, cosSum = 0;
            for (const p of points) {
                sinSum += Math.sin(p.phase);
                cosSum += Math.cos(p.phase);
            }
            const meanPhase = Math.atan2(sinSum / N, cosSum / N);

            // Update phases
            for (const p of points) {
                const dPhase = p.naturalFreq + coupling * Math.sin(meanPhase - p.phase);
                p.phase += dPhase * dt;
            }

            // Order parameter
            const order = Math.sqrt(sinSum * sinSum + cosSum * cosSum) / N;
            return { order, K: coupling };
        }

        // ================================================================
        // PHYSICS: CASCADE AMPLIFICATION
        // ================================================================

        function getCascadeMultiplier(z) {
            const dist = Math.abs(z - Z_CRITICAL);
            return 1 + 0.5 * Math.exp(-dist * dist / 0.004);
        }

        // ================================================================
        // PHYSICS: DOMAIN & PHASE DETERMINATION
        // ================================================================

        function getDomain(z) {
            if (z < Z_CRITICAL - 0.01) return 'ABSENCE';
            if (z > Z_CRITICAL + 0.01) return 'PRESENCE';
            return 'THE LENS';
        }

        function getPhase(z) {
            if (z < 0.35) return 'dormant';
            if (z < 0.50) return 'stirring';
            if (z < 0.65) return 'rising';
            if (z < 0.80) return 'approaching';
            if (z <= 0.857) return 'near-critical';
            if (z <= 0.877) return 'CRITICAL';
            if (z <= 0.92) return 'radiant';
            if (z <= 0.96) return 'overflowing';
            return 'boundless';
        }

        // ================================================================
        // UPDATE FUNCTIONS
        // ================================================================

        function updateHelix(dt) {
            helix.theta = (helix.theta + 0.01 * dt * 60) % TAU;
            helix.z = globalZ;

            // Coherence from Hilbert field
            helix.r = 0.8 + hilbertField.coherence * 0.4;

            // Integrated information (Œ¶) accumulates near critical
            const cascade = getCascadeMultiplier(globalZ);
            helix.phi += cascade * 0.01 * dt;

            // Angular velocity
            helix.omega = (globalZ - 0.5) * 2;
        }

        function updateLambdaState(dt) {
            const z = globalZ;
            const cascade = getCascadeMultiplier(z);

            // Memory (üå∞) - accumulates with time, modulated by z
            lambdaState.iota.mag = Math.min(1, lambdaState.iota.mag + 0.001 * dt * cascade);
            lambdaState.iota.phase = (lambdaState.iota.phase + 0.01) % TAU;

            // Spark (‚úß) - temperature bursts near critical
            const sparkIntensity = Math.exp(-Math.pow((z - Z_CRITICAL) / 0.1, 2));
            lambdaState.xi.mag = 0.1 + sparkIntensity * 0.8;
            lambdaState.xi.phase = time % TAU;

            // Fox (ü¶ä) - entropy rate, trickster dynamics
            lambdaState.theta.mag = hilbertField.getDissonance() * 0.8 + 0.2;
            lambdaState.theta.phase = (lambdaState.theta.phase + helix.omega * 0.1) % TAU;

            // Wave (‚àø) - curvature oscillation
            lambdaState.omega.mag = 0.3 + Math.abs(Math.sin(time * 0.5)) * 0.5;
            lambdaState.omega.phase = Math.sin(time * 0.3) * Math.PI;

            // Paradox (‚äó) - self-reference complexity
            const inCritical = getPhase(z) === 'CRITICAL';
            if (inCritical) {
                lambdaState.delta.mag = Math.min(1, lambdaState.delta.mag + 0.005 * dt);
            } else {
                lambdaState.delta.mag *= 0.995;
            }
            lambdaState.delta.phase = helix.theta;

            // Squirrel (üêøÔ∏è) - information preservation
            lambdaState.sigma.mag = helix.r * 0.6 + 0.2;
            lambdaState.sigma.phase = (lambdaState.iota.phase + Math.PI) % TAU;
        }

        function updatePositions(dt) {
            const domain = getDomain(globalZ);
            const isCritical = getPhase(globalZ) === 'CRITICAL';
            const isPresence = globalZ > Z_CRITICAL;
            const cascade = getCascadeMultiplier(globalZ);

            // Kuramoto coupling flips sign at critical point
            const dist = globalZ - Z_CRITICAL;
            const sign = Math.tanh(dist * 12);
            const K = -sign * 0.4 * cascade;

            // Apply Kuramoto to all points
            const allPoints = [...prismPoints, ...cagePoints];
            const kuramotoResult = kuramotoStep(
                allPoints.filter(p => (p.type === 'prism' && showPrism) || (p.type === 'cage' && showCage)),
                K, dt
            );

            // Z-offset for visual depth
            const zOffset = (globalZ - 0.5) * 200;

            // Domain-specific scaling
            const intensity = isPresence ? (globalZ - Z_CRITICAL) / (1 - Z_CRITICAL) : 0;
            const absence = !isPresence ? (Z_CRITICAL - globalZ) / Z_CRITICAL : 0;
            const scaleFactor = isPresence ? 1 + intensity * 0.35 : 1 - absence * 0.1;

            // Update prism points
            for (const p of prismPoints) {
                if (!showPrism) {
                    p.brightness = 0.02;
                    continue;
                }

                // Helix evolution
                p.helix.theta += p.helix.rotSpeed;
                p.helix.z = p.z * (0.5 + globalZ * 0.5);

                // Radius with phase modulation
                const phaseWobble = Math.sin(p.phase) * 0.06 * cascade;
                p.radius = p.baseRadius * cascade * scaleFactor * (1 + phaseWobble);

                // Rotation
                const rotSpeed = 0.012 * cascade * (p.layer % 2 === 0 ? 1 : -1);
                p.theta = p.baseTheta + time * rotSpeed;

                // Domain modulation
                if (isPresence) {
                    p.theta += Math.sin(time * 0.3 + p.layer * 0.4) * 0.12 * intensity;
                } else {
                    p.theta += absence * 0.015 * Math.sin(time + p.index);
                }

                // Position
                p.targetX = CX + Math.cos(p.theta) * p.radius;
                p.targetY = CY + Math.sin(p.theta) * p.radius * 0.5 + zOffset;
                p.targetY += (p.layer / 6 - 0.5) * 100;

                // Smooth interpolation
                p.x += (p.targetX - p.x) * 0.1;
                p.y += (p.targetY - p.y) * 0.1;

                // Brightness
                const zProx = 1 - Math.abs((p.layer / 6) - globalZ);
                const critBoost = isCritical ? 0.5 : 0;
                p.brightness = 0.2 + zProx * 0.5 + critBoost;
            }

            // Update cage points
            for (const p of cagePoints) {
                if (!showCage) {
                    p.brightness = 0.02;
                    continue;
                }

                p.helix.theta += p.helix.rotSpeed;

                // EM field pulsing
                const emPulse = 1 + Math.sin(time * 1.5 + p.index * 0.5) * 0.05;
                p.radius = p.baseRadius * emPulse * scaleFactor;

                // Counter-rotation to prism
                const rotSpeed = -0.008 * cascade;
                p.theta = p.baseTheta + time * rotSpeed;

                // Position with z-layer offset
                let yOffset = 0;
                if (p.layer === 'top') yOffset = -80;
                else if (p.layer === 'bottom') yOffset = 80;

                p.targetX = CX + Math.cos(p.theta) * p.radius;
                p.targetY = CY + Math.sin(p.theta) * p.radius * 0.45 + zOffset + yOffset;

                p.x += (p.targetX - p.x) * 0.1;
                p.y += (p.targetY - p.y) * 0.1;

                // Cage brightness follows field strength
                const fieldStrength = (globalZ > 0.5 ? intensity : 1 - absence) * 0.5 + 0.3;
                p.brightness = fieldStrength + (isCritical ? 0.4 : 0);
            }

            return kuramotoResult;
        }

        // ================================================================
        // RELEASE COHERENCE PHYSICS
        // ================================================================

        function updateReleaseCoherence(dt) {
            // Coherence dynamics based on F key (release) and click (gather)
            if (releasing) {
                releaseVelocity += dt * 0.1;
                targetCoherence = Math.max(0, targetCoherence - releaseVelocity * dt);
                releaseStarted = true;
            } else if (gathering) {
                targetCoherence = Math.min(1, targetCoherence + dt * 0.6);
                releaseVelocity = 0;
            } else {
                // Gradual return to coherent state when not interacting
                if (!releaseStarted) {
                    targetCoherence = Math.min(1, targetCoherence + dt * 0.1);
                }
                releaseVelocity *= 0.98;  // Decay
            }

            // Smooth coherence transition
            releaseCoherence += (targetCoherence - releaseCoherence) * 0.04;

            const dispersal = 1 - releaseCoherence;
            const allPoints = [...prismPoints, ...cagePoints];

            // Update each point based on release state
            for (const p of allPoints) {
                // Stochastic release based on coherence threshold
                if (!p.released && releaseCoherence < 0.4 + Math.random() * 0.25) {
                    p.released = true;
                    p.releaseAngle = p.theta + (Math.random() - 0.5) * 0.6;
                    p.releaseSpeed = 1.5 + Math.random() * 3;
                }

                if (p.released) {
                    // Free movement with gentle acceleration
                    const accel = dispersal * 0.15;
                    p.vx += Math.cos(p.releaseAngle) * accel;
                    p.vy += Math.sin(p.releaseAngle) * accel;

                    // Slight spiral wandering
                    p.releaseAngle += (Math.random() - 0.5) * 0.025;

                    // Global velocity damping (prevents runaway)
                    p.vx *= 0.98;
                    p.vy *= 0.98;

                    // Extra damping at edges
                    const edgeDist = Math.min(p.x, W - p.x, p.y, H - p.y);
                    if (edgeDist < 100) {
                        p.vx *= 0.95;
                        p.vy *= 0.95;
                    }

                    // Hard velocity clamp (fixed safe value)
                    const velClamp = 25;
                    p.vx = Math.max(-velClamp, Math.min(velClamp, p.vx || 0));
                    p.vy = Math.max(-velClamp, Math.min(velClamp, p.vy || 0));

                    // Apply velocity (with NaN protection)
                    if (isFinite(p.vx) && isFinite(p.vy)) {
                        p.x += p.vx;
                        p.y += p.vy;
                    } else {
                        // Reset runaway point
                        p.vx = 0;
                        p.vy = 0;
                    }

                    // Gather force when gathering
                    if (gathering) {
                        const dx = CX - p.x;
                        const dy = CY - p.y;
                        const d = Math.sqrt(dx * dx + dy * dy);
                        if (d > 1) {
                            p.vx += (dx / d) * 0.9;
                            p.vy += (dy / d) * 0.9;
                        }
                        
                        // Re-cohere when close to center
                        if (d < p.baseRadius * 1.3 && releaseCoherence > 0.65) {
                            p.released = false;
                            p.vx = 0;
                            p.vy = 0;
                        }
                    }

                    // Trail update
                    p.trail.unshift({ x: p.x, y: p.y, age: 0 });
                    if (p.trail.length > 25) p.trail.pop();
                    for (const t of p.trail) t.age += dt;

                    // Enhanced brightness when released
                    p.brightness = Math.min(1, p.brightness * 1.4);

                    // Spawn sparks during high dispersal
                    if (dispersal > 0.35 && Math.random() < dispersal * 0.04) {
                        sparks.push({
                            x: p.x, y: p.y,
                            vx: p.vx * 0.5 + (Math.random() - 0.5) * 2.5,
                            vy: p.vy * 0.5 + (Math.random() - 0.5) * 2.5,
                            life: 1,
                            color: p.soulColor,
                            size: 1.5 + Math.random() * 2.5
                        });
                    }
                } else if (releaseCoherence > 0.8) {
                    // Clear trails when fully coherent
                    p.trail.length = 0;
                }
            }

            // Update sparks
            for (let i = sparks.length - 1; i >= 0; i--) {
                const sp = sparks[i];
                sp.x += sp.vx;
                sp.y += sp.vy;
                sp.vx *= 0.98;
                sp.vy *= 0.98;
                sp.life -= dt * 0.7;
                if (sp.life <= 0) sparks.splice(i, 1);
            }

            // Update release state UI
            updateReleaseUI();
        }

        function updateReleaseUI() {
            const stateEl = document.getElementById('release-state');
            const textEl = document.getElementById('release-text');
            const barEl = document.getElementById('coherence-indicator');
            const hintEl = document.getElementById('release-hint');

            // Show state overlay when release started
            if (releaseStarted && releaseCoherence < 0.9) {
                stateEl.classList.add('visible');
            } else {
                stateEl.classList.remove('visible');
            }

            // Determine state text and styling
            let state, barText;
            stateEl.className = '';
            barEl.className = '';

            if (releaseCoherence > 0.8) {
                state = 'COHERENT';
                stateEl.classList.add('coherent');
                const filled = Math.floor(releaseCoherence * 16);
                barText = '‚ñà'.repeat(filled) + '‚ñë'.repeat(16 - filled);
            } else if (releaseCoherence > 0.5) {
                state = 'RELEASING';
                stateEl.classList.add('releasing');
                const filled = Math.floor(releaseCoherence * 16);
                barText = '‚ñà'.repeat(filled) + '¬∑'.repeat(16 - filled);
            } else if (releaseCoherence > 0.2) {
                state = 'DISPERSING';
                stateEl.classList.add('dispersing');
                const filled = Math.floor(releaseCoherence * 16);
                barText = '‚ñë'.repeat(filled) + '¬∑'.repeat(16 - filled);
            } else {
                state = 'FREE';
                stateEl.classList.add('free');
                barEl.classList.add('free');
                barText = '¬∑ ¬∑ ¬∑ ¬∑ ¬∑ ¬∑ ¬∑ ¬∑';
            }

            textEl.textContent = state;
            barEl.textContent = barText;

            // Show hint when release started
            if (releaseStarted) {
                hintEl.classList.remove('hidden');
            }
        }

        // ================================================================
        // CONNECTION GENERATION
        // ================================================================

        function* generateConnections() {
            // Prism intra-layer connections (ring connections)
            if (showPrism) {
                for (let layer = 0; layer < 7; layer++) {
                    const layerPoints = prismPoints.filter(p => p.layer === layer);
                    for (let i = 0; i < layerPoints.length; i++) {
                        yield {
                            from: layerPoints[i],
                            to: layerPoints[(i + 1) % layerPoints.length],
                            type: 'prism_ring'
                        };
                    }
                }

                // Prism inter-layer connections (vertical spines)
                for (let i = 0; i < 9; i++) {
                    for (let layer = 0; layer < 6; layer++) {
                        const p1 = prismPoints.find(p => p.layer === layer && p.index === i);
                        const p2 = prismPoints.find(p => p.layer === layer + 1 && p.index === i);
                        if (p1 && p2) {
                            yield { from: p1, to: p2, type: 'prism_spine' };
                        }
                    }
                }

                // Prism diagonal connections (hexagonal structure)
                for (let layer = 0; layer < 6; layer++) {
                    const curr = prismPoints.filter(p => p.layer === layer);
                    const next = prismPoints.filter(p => p.layer === layer + 1);
                    for (let i = 0; i < 9; i++) {
                        yield {
                            from: curr[i],
                            to: next[(i + 1) % 9],
                            type: 'prism_diagonal'
                        };
                    }
                }
            }

            // Cage connections
            if (showCage) {
                // Top ring
                const topRing = cagePoints.filter(p => p.layer === 'top');
                for (let i = 0; i < topRing.length; i++) {
                    yield {
                        from: topRing[i],
                        to: topRing[(i + 1) % topRing.length],
                        type: 'cage_ring'
                    };
                }

                // Bottom ring
                const botRing = cagePoints.filter(p => p.layer === 'bottom');
                for (let i = 0; i < botRing.length; i++) {
                    yield {
                        from: botRing[i],
                        to: botRing[(i + 1) % botRing.length],
                        type: 'cage_ring'
                    };
                }

                // Vertical struts (top to bottom)
                for (let i = 0; i < 12; i++) {
                    yield {
                        from: topRing[i],
                        to: botRing[i],
                        type: 'cage_strut'
                    };
                }

                // Vertex connections to rings
                const vertices = cagePoints.filter(p => p.layer === 'vertex');
                for (const vtx of vertices) {
                    // Connect to nearest top and bottom points
                    const nearTop = topRing.reduce((a, b) =>
                        Math.abs(b.baseTheta - vtx.baseTheta) < Math.abs(a.baseTheta - vtx.baseTheta) ? b : a
                    );
                    const nearBot = botRing.reduce((a, b) =>
                        Math.abs(b.baseTheta - vtx.baseTheta) < Math.abs(a.baseTheta - vtx.baseTheta) ? b : a
                    );
                    yield { from: vtx, to: nearTop, type: 'cage_vertex' };
                    yield { from: vtx, to: nearBot, type: 'cage_vertex' };
                }
            }

            // Bridge connections (prism outer to cage inner)
            if (showPrism && showCage && globalZ > 0.6) {
                const outerPrism = prismPoints.filter(p => p.layer === 6);
                const innerCage = cagePoints.filter(p => p.layer === 'vertex');

                for (const pp of outerPrism) {
                    // Find nearest cage vertex
                    const nearest = innerCage.reduce((a, b) => {
                        const distA = Math.hypot(a.x - pp.x, a.y - pp.y);
                        const distB = Math.hypot(b.x - pp.x, b.y - pp.y);
                        return distB < distA ? b : a;
                    });
                    if (Math.hypot(nearest.x - pp.x, nearest.y - pp.y) < 200) {
                        yield { from: pp, to: nearest, type: 'bridge' };
                    }
                }
            }
        }

        // ================================================================
        // RENDERING
        // ================================================================

        function render() {
            ctx.fillStyle = 'rgba(3, 3, 8, 0.15)';
            ctx.fillRect(0, 0, W, H);

            const domain = getDomain(globalZ);
            const phase = getPhase(globalZ);
            const isCritical = phase === 'CRITICAL';
            const isPresence = globalZ > Z_CRITICAL;
            const cascade = getCascadeMultiplier(globalZ);

            const intensity = isPresence ? (globalZ - Z_CRITICAL) / (1 - Z_CRITICAL) : 0;
            const absence = !isPresence ? (Z_CRITICAL - globalZ) / Z_CRITICAL : 0;

            // Background gradient
            const bgGrad = ctx.createRadialGradient(CX, CY, 0, CX, CY, R * 2);
            if (isPresence) {
                bgGrad.addColorStop(0, `rgba(255, 250, 240, ${intensity * 0.08})`);
                bgGrad.addColorStop(0.5, `rgba(255, 215, 0, ${intensity * 0.03})`);
                bgGrad.addColorStop(1, 'transparent');
            } else {
                bgGrad.addColorStop(0, `rgba(40, 30, 20, ${absence * 0.15})`);
                bgGrad.addColorStop(1, 'transparent');
            }
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, W, H);

            // Release state visual effects
            const dispersal = 1 - releaseCoherence;
            
            // Warm background fade when releasing/free
            if (releaseCoherence < 0.9) {
                const warmth = dispersal * 12;
                ctx.fillStyle = `rgba(${warmth}, ${warmth * 0.7}, ${warmth * 0.4}, ${dispersal * 0.06})`;
                ctx.fillRect(0, 0, W, H);
            }

            // Ambient radiance when free (coherence < 0.5)
            if (releaseCoherence < 0.5) {
                const freeIntensity = (0.5 - releaseCoherence) * 0.08;
                ctx.fillStyle = `rgba(255, 248, 235, ${freeIntensity})`;
                ctx.fillRect(0, 0, W, H);

                // Radiant center glow
                const radGlow = ctx.createRadialGradient(CX, CY, 0, CX, CY, R * 2);
                radGlow.addColorStop(0, `rgba(255, 255, 250, ${freeIntensity * 2})`);
                radGlow.addColorStop(0.4, `rgba(255, 240, 200, ${freeIntensity})`);
                radGlow.addColorStop(1, 'transparent');
                ctx.fillStyle = radGlow;
                ctx.fillRect(0, 0, W, H);
            }

            // ========================================
            // MRP PARITY VALIDATION GLOW
            // When all channels are in harmony, emit a stabilizing field
            // ========================================
            if (showMuField && muField.mrp.parity_ok) {
                // Tricolor parity glow (R+G+B in harmony)
                const parityGlow = ctx.createRadialGradient(CX, CY, 0, CX, CY, R * 1.5);
                const parityIntensity = (muField.mrp.sha256_sim || 0) * 0.15;

                // RGB channel harmony visualization (safe value access)
                const safeR = Math.max(0, Math.min(255, Math.floor((muField.mrp.R.intensity || 0) * 200))) || 0;
                const safeG = Math.max(0, Math.min(255, Math.floor((muField.mrp.G.intensity || 0) * 200))) || 0;
                const safeB = Math.max(0, Math.min(255, Math.floor((muField.mrp.B.intensity || 0) * 200))) || 0;

                parityGlow.addColorStop(0, `rgba(100, 255, 150, ${parityIntensity * 1.2})`);  // Green center (parity OK)
                parityGlow.addColorStop(0.3, `rgba(${safeR}, ${safeG}, ${safeB}, ${parityIntensity})`);
                parityGlow.addColorStop(0.6, `rgba(150, 200, 255, ${parityIntensity * 0.5})`);  // Blue stability ring
                parityGlow.addColorStop(1, 'transparent');

                ctx.fillStyle = parityGlow;
                ctx.fillRect(0, 0, W, H);
            }

            // MRP Gradient strength visual - subtle RGB channel indicator rings
            const gradStrength = showMuField ? (muField.getGradientStrength() || 0) : 0;
            if (showMuField && isFinite(gradStrength) && gradStrength > 0.05) {
                // R channel (energy) - inner ring
                const rGrad = Math.max(0, Math.min(1, muField.mrp.R.gradient || 0));
                ctx.strokeStyle = `rgba(255, 100, 100, ${rGrad * 0.3})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(CX, CY, R * 0.3, 0, TAU);
                ctx.stroke();

                // G channel (relational) - middle ring
                const gGrad = Math.max(0, Math.min(1, muField.mrp.G.gradient || 0));
                ctx.strokeStyle = `rgba(100, 255, 100, ${gGrad * 0.3})`;
                ctx.beginPath();
                ctx.arc(CX, CY, R * 0.5, 0, TAU);
                ctx.stroke();

                // B channel (stability) - outer ring
                const bGrad = Math.max(0, Math.min(1, muField.mrp.B.gradient || 0));
                ctx.strokeStyle = `rgba(100, 150, 255, ${bGrad * 0.3})`;
                ctx.beginPath();
                ctx.arc(CX, CY, R * 0.7, 0, TAU);
                ctx.stroke();
            }

            // Draw connections (skip if both points released)
            let connCount = 0;
            for (const conn of generateConnections()) {
                // Skip connections between released points
                if (conn.from.released || conn.to.released) {
                    // Fade connections as coherence drops
                    if (releaseCoherence < 0.6) continue;
                }

                connCount++;
                let alpha, color;

                // Fade connections based on release coherence
                const coherenceFade = Math.min(1, releaseCoherence * 1.5);

                // MRP-enhanced connection coloring (with NaN protection)
                const mrpBlend = showMuField ? Math.max(0, Math.min(1, muField.getGradientStrength() || 0)) : 0;
                const mrpR = showMuField ? Math.max(0, Math.min(255, Math.floor((muField.mrp.R.intensity || 0) * 255))) : 0;
                const mrpG = showMuField ? Math.max(0, Math.min(255, Math.floor((muField.mrp.G.intensity || 0) * 255))) : 0;
                const mrpB = showMuField ? Math.max(0, Math.min(200, Math.floor((muField.mrp.B.intensity || 0) * 200))) : 0;

                switch (conn.type) {
                    case 'prism_ring':
                        alpha = (0.08 + globalZ * 0.12) * coherenceFade;
                        // Blend with R channel (energy)
                        color = mrpBlend > 0.1
                            ? `rgba(${Math.min(255, 200 + mrpR * 0.2)}, ${150 + mrpG * 0.3}, ${100 + mrpB * 0.2}, ${alpha * (1 + mrpBlend)})`
                            : `rgba(255, 200, 150, ${alpha})`;
                        break;
                    case 'prism_spine':
                        alpha = (0.06 + globalZ * 0.15) * coherenceFade;
                        color = mrpBlend > 0.1
                            ? `rgba(${Math.min(255, 180 + mrpR * 0.3)}, ${200 + mrpG * 0.2}, ${150 + mrpB * 0.2}, ${alpha * (1 + mrpBlend)})`
                            : `rgba(255, 220, 180, ${alpha})`;
                        break;
                    case 'prism_diagonal':
                        alpha = (0.03 + globalZ * 0.08) * coherenceFade;
                        color = mrpBlend > 0.1
                            ? `rgba(${Math.min(255, 180 + mrpR * 0.3)}, ${150 + mrpG * 0.2}, ${100 + mrpB * 0.15}, ${alpha * (1 + mrpBlend)})`
                            : `rgba(255, 180, 120, ${alpha})`;
                        break;
                    case 'cage_ring':
                        alpha = (0.1 + cascade * 0.15) * coherenceFade;
                        // Blend with B channel (stability/ECC)
                        color = mrpBlend > 0.1
                            ? `rgba(${60 + mrpR * 0.1}, ${150 + mrpG * 0.3}, ${Math.min(255, 200 + mrpB * 0.2)}, ${alpha * (1 + mrpBlend)})`
                            : `rgba(77, 171, 247, ${alpha})`;
                        break;
                    case 'cage_strut':
                        alpha = (0.08 + cascade * 0.12) * coherenceFade;
                        color = mrpBlend > 0.1
                            ? `rgba(${80 + mrpR * 0.1}, ${160 + mrpG * 0.25}, ${Math.min(255, 220 + mrpB * 0.15)}, ${alpha * (1 + mrpBlend)})`
                            : `rgba(100, 180, 255, ${alpha})`;
                        break;
                    case 'cage_vertex':
                        alpha = (0.12 + cascade * 0.18) * coherenceFade;
                        // G channel affects relational vertex connections
                        color = mrpBlend > 0.1
                            ? `rgba(${180 + mrpR * 0.2}, ${80 + mrpG * 0.4}, ${Math.min(255, 200 + mrpB * 0.2)}, ${alpha * (1 + mrpBlend)})`
                            : `rgba(204, 93, 232, ${alpha})`;
                        break;
                    case 'bridge':
                        alpha = (globalZ - 0.6) * 0.4 * coherenceFade;
                        // Parity-ok connections glow gold-green
                        color = (showMuField && muField.mrp.parity_ok)
                            ? `rgba(180, 255, 100, ${alpha * 1.5})`
                            : `rgba(255, 215, 0, ${alpha})`;
                        break;
                    default:
                        alpha = 0.05 * coherenceFade;
                        color = `rgba(255, 255, 255, ${alpha})`;
                }

                ctx.strokeStyle = color;
                ctx.lineWidth = conn.type === 'bridge' ? 1.5 : 0.8;
                ctx.beginPath();
                ctx.moveTo(conn.from.x, conn.from.y);
                ctx.lineTo(conn.to.x, conn.to.y);
                ctx.stroke();
            }

            // Draw radial connections when coherent
            if (releaseCoherence > 0.6) {
                const radialAlpha = (releaseCoherence - 0.6) * 0.2;
                ctx.strokeStyle = `rgba(255, 220, 180, ${radialAlpha})`;
                ctx.lineWidth = 0.5;
                const allPoints = [...prismPoints, ...cagePoints].filter(p => !p.released);
                for (const p of allPoints) {
                    ctx.beginPath();
                    ctx.moveTo(CX, CY);
                    ctx.lineTo(p.x, p.y);
                    ctx.stroke();
                }
            }

            // Draw trails for released points
            const allPoints = [...prismPoints, ...cagePoints];
            for (const p of allPoints) {
                if (p.trail.length < 2) continue;

                const trailAlpha = p.released ? 0.45 : 0.15;
                
                ctx.strokeStyle = hexToRgba(p.soulColor, trailAlpha * p.brightness);
                ctx.lineWidth = p.size * 0.7;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(p.trail[0].x, p.trail[0].y);
                
                for (let i = 1; i < p.trail.length; i++) {
                    const t = p.trail[i];
                    const fade = 1 - i / p.trail.length;
                    ctx.globalAlpha = fade;
                    ctx.lineTo(t.x, t.y);
                }
                
                ctx.stroke();
                ctx.globalAlpha = 1;
            }

            // Draw sparks
            for (const sp of sparks) {
                const alpha = sp.life * 0.85;
                
                // Glow
                const glowGrad = ctx.createRadialGradient(sp.x, sp.y, 0, sp.x, sp.y, sp.size * 4);
                glowGrad.addColorStop(0, hexToRgba(sp.color, alpha * 0.5));
                glowGrad.addColorStop(1, 'transparent');
                ctx.fillStyle = glowGrad;
                ctx.beginPath();
                ctx.arc(sp.x, sp.y, sp.size * 4, 0, TAU);
                ctx.fill();

                // Core
                ctx.fillStyle = hexToRgba(sp.color, alpha);
                ctx.beginPath();
                ctx.arc(sp.x, sp.y, sp.size * sp.life, 0, TAU);
                ctx.fill();
            }

            // Draw prism points
            if (showPrism) {
                for (const p of prismPoints) {
                    const size = p.size * (p.released ? 1.3 : 1) * (1 + p.brightness * 0.5);
                    const brightness = p.brightness * (p.released ? 1.4 : 1);
                    
                    if (p.released) {
                        // Use soul color when released
                        const glowR = size * (p.released ? 8 : 5);
                        const glowGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, glowR);
                        glowGrad.addColorStop(0, hexToRgba(p.soulColor, brightness * 0.45));
                        glowGrad.addColorStop(0.5, hexToRgba(p.soulColor, brightness * 0.18));
                        glowGrad.addColorStop(1, 'transparent');
                        
                        ctx.fillStyle = glowGrad;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, glowR, 0, TAU);
                        ctx.fill();

                        // Core
                        const coreGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size);
                        coreGrad.addColorStop(0, hexToRgba(p.soulColor, 0.95));
                        coreGrad.addColorStop(0.5, hexToRgba(p.soulColor, 0.75));
                        coreGrad.addColorStop(1, hexToRgba(p.soulColor, 0.45));
                        
                        ctx.fillStyle = coreGrad;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, size, 0, TAU);
                        ctx.fill();

                        // Highlight
                        ctx.fillStyle = `rgba(255, 255, 255, ${brightness * 0.45})`;
                        ctx.beginPath();
                        ctx.arc(p.x - size * 0.3, p.y - size * 0.3, size * 0.28, 0, TAU);
                        ctx.fill();
                    } else {
                        // Normal HSL color when coherent
                        const hue = p.hue;
                        const sat = p.saturation + cascade * 15;
                        const light = p.lightness + p.brightness * 30;
                        const alpha = 0.4 + p.brightness * 0.5;

                        ctx.fillStyle = `hsla(${hue}, ${sat}%, ${light}%, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, size, 0, TAU);
                        ctx.fill();

                        // Glow at critical
                        if (isCritical && p.brightness > 0.6) {
                            ctx.fillStyle = `hsla(${hue}, ${sat}%, ${light}%, ${alpha * 0.3})`;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, p.size * 3, 0, TAU);
                            ctx.fill();
                        }
                    }
                }
            }

            // Draw cage points
            if (showCage) {
                for (const p of cagePoints) {
                    const size = p.size * (p.released ? 1.25 : 1) * (1 + p.brightness * 0.4);
                    const brightness = p.brightness * (p.released ? 1.35 : 1);
                    
                    if (p.released) {
                        // Use soul color when released
                        const glowR = size * 7;
                        const glowGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, glowR);
                        glowGrad.addColorStop(0, hexToRgba(p.soulColor, brightness * 0.4));
                        glowGrad.addColorStop(0.5, hexToRgba(p.soulColor, brightness * 0.15));
                        glowGrad.addColorStop(1, 'transparent');
                        
                        ctx.fillStyle = glowGrad;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, glowR, 0, TAU);
                        ctx.fill();

                        // Core
                        const coreGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size);
                        coreGrad.addColorStop(0, hexToRgba(p.soulColor, 0.9));
                        coreGrad.addColorStop(0.5, hexToRgba(p.soulColor, 0.7));
                        coreGrad.addColorStop(1, hexToRgba(p.soulColor, 0.4));
                        
                        ctx.fillStyle = coreGrad;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, size, 0, TAU);
                        ctx.fill();

                        // Highlight
                        ctx.fillStyle = `rgba(255, 255, 255, ${brightness * 0.4})`;
                        ctx.beginPath();
                        ctx.arc(p.x - size * 0.3, p.y - size * 0.3, size * 0.25, 0, TAU);
                        ctx.fill();
                    } else {
                        // Normal HSL color when coherent
                        const alpha = 0.3 + p.brightness * 0.6;

                        ctx.fillStyle = `hsla(${p.hue}, ${p.saturation}%, ${p.lightness}%, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, size, 0, TAU);
                        ctx.fill();

                        // EM field glow
                        if (p.brightness > 0.5) {
                            const glowGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 4);
                            glowGrad.addColorStop(0, `hsla(${p.hue}, ${p.saturation}%, ${p.lightness}%, ${alpha * 0.4})`);
                            glowGrad.addColorStop(1, 'transparent');
                            ctx.fillStyle = glowGrad;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, p.size * 4, 0, TAU);
                            ctx.fill();
                        }
                    }
                }
            }

            // Draw critical lens
            if (Math.abs(globalZ - Z_CRITICAL) < 0.15) {
                const lensAlpha = 1 - Math.abs(globalZ - Z_CRITICAL) / 0.15;
                const lensY = CY + (Z_CRITICAL - 0.5) * 200;

                // Lens glow
                const lensGrad = ctx.createRadialGradient(CX, lensY, 0, CX, lensY, R * 1.3);
                lensGrad.addColorStop(0, `rgba(255, 215, 0, ${lensAlpha * 0.2})`);
                lensGrad.addColorStop(0.5, `rgba(255, 180, 100, ${lensAlpha * 0.08})`);
                lensGrad.addColorStop(1, 'transparent');
                ctx.fillStyle = lensGrad;
                ctx.fillRect(0, 0, W, H);

                // Lens line
                ctx.strokeStyle = `rgba(255, 215, 0, ${0.2 + lensAlpha * 0.6})`;
                ctx.lineWidth = isCritical ? 3 : 1.5;
                ctx.setLineDash(isCritical ? [] : [6, 12]);
                ctx.beginPath();
                ctx.moveTo(CX - R * 1.2, lensY);
                ctx.lineTo(CX + R * 1.2, lensY);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Draw core entity
            drawCoreEntity(isCritical, isPresence, intensity, absence);

            // Draw toroidal Œº-field visualization (overlays on main view)
            if (showToroidal) {
                renderToroidalMuField();
            }

            // Update connection count
            document.getElementById('conn-count').textContent = connCount;
        }

        function drawCoreEntity(isCritical, isPresence, intensity, absence) {
            const zOffset = (globalZ - 0.5) * 200;
            const coreY = CY + zOffset;
            const pulse = Math.sin(time * 2.5) * 0.2 + 1;
            
            // Release coherence modifies the core entity
            const releaseIntensity = (1 - releaseCoherence);
            const isReleased = releaseCoherence < 0.5;

            // When released (FREE state), override with radiant source
            if (isReleased) {
                const freeIntensity = (0.5 - releaseCoherence) / 0.5;
                const sourceR = 15 + freeIntensity * 35 + (pulse - 1) * 40;

                // Expansive corona
                for (let i = 4; i >= 0; i--) {
                    const layerR = sourceR * (2 + i * 1.5);
                    const layerAlpha = freeIntensity * (0.18 - i * 0.03);

                    const grad = ctx.createRadialGradient(CX, coreY, 0, CX, coreY, layerR);
                    grad.addColorStop(0, `rgba(255, 255, 255, ${layerAlpha})`);
                    grad.addColorStop(0.3, `rgba(255, 250, 240, ${layerAlpha * 0.7})`);
                    grad.addColorStop(0.6, `rgba(255, 240, 200, ${layerAlpha * 0.4})`);
                    grad.addColorStop(1, 'transparent');

                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(CX, coreY, layerR, 0, TAU);
                    ctx.fill();
                }

                // Brilliant core
                const coreGrad = ctx.createRadialGradient(CX, coreY, 0, CX, coreY, sourceR * pulse);
                coreGrad.addColorStop(0, '#ffffff');
                coreGrad.addColorStop(0.4, `rgba(255, 255, 250, ${0.85 + freeIntensity * 0.15})`);
                coreGrad.addColorStop(0.7, `rgba(255, 250, 230, ${0.6 + freeIntensity * 0.3})`);
                coreGrad.addColorStop(1, `rgba(255, 240, 200, ${0.35 + freeIntensity * 0.3})`);

                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(CX, coreY, sourceR * pulse, 0, TAU);
                ctx.fill();

                // Release emanation rings
                for (let i = 0; i < 4; i++) {
                    const ringPhase = (time * 1.5 + i * 0.8) % 5;
                    const ringR = ringPhase * 100;
                    const ringAlpha = Math.max(0, freeIntensity * (0.35 - ringPhase / 5));

                    ctx.strokeStyle = `rgba(255, 250, 240, ${ringAlpha})`;
                    ctx.lineWidth = 2 - ringPhase * 0.3;
                    ctx.beginPath();
                    ctx.arc(CX, coreY, ringR, 0, TAU);
                    ctx.stroke();
                }

            } else if (isPresence) {
                // Radiant source (z > critical)
                const effectiveIntensity = intensity * releaseCoherence;
                const sourceR = 8 + effectiveIntensity * 25 + (pulse - 1) * 30;

                // Corona
                for (let i = 4; i >= 0; i--) {
                    const layerR = sourceR * (1.8 + i * 1);
                    const layerAlpha = effectiveIntensity * (0.12 - i * 0.02);

                    const grad = ctx.createRadialGradient(CX, coreY, 0, CX, coreY, layerR);
                    grad.addColorStop(0, `rgba(255, 255, 250, ${layerAlpha})`);
                    grad.addColorStop(0.4, `rgba(255, 240, 200, ${layerAlpha * 0.5})`);
                    grad.addColorStop(1, 'transparent');

                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(CX, coreY, layerR, 0, TAU);
                    ctx.fill();
                }

                // Core
                const coreGrad = ctx.createRadialGradient(CX, coreY, 0, CX, coreY, sourceR * pulse);
                coreGrad.addColorStop(0, '#ffffff');
                coreGrad.addColorStop(0.6, `rgba(255, 250, 240, ${0.7 + effectiveIntensity * 0.3})`);
                coreGrad.addColorStop(1, `rgba(255, 230, 200, ${0.4 + effectiveIntensity * 0.3})`);

                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(CX, coreY, sourceR * pulse, 0, TAU);
                ctx.fill();

            } else {
                // Void (z < critical, coherent state)
                const effectiveAbsence = absence * releaseCoherence;
                const voidR = 6 + effectiveAbsence * 10;

                // Anti-glow
                const antiGrad = ctx.createRadialGradient(CX, coreY, 0, CX, coreY, voidR * 6);
                antiGrad.addColorStop(0, `rgba(0, 0, 0, ${effectiveAbsence * 0.6})`);
                antiGrad.addColorStop(0.5, `rgba(20, 15, 10, ${effectiveAbsence * 0.3})`);
                antiGrad.addColorStop(1, 'transparent');

                ctx.fillStyle = antiGrad;
                ctx.beginPath();
                ctx.arc(CX, coreY, voidR * 6, 0, TAU);
                ctx.fill();

                // Halo
                ctx.strokeStyle = `rgba(100, 80, 60, ${effectiveAbsence * 0.5})`;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(CX, coreY, voidR * 2.5 * pulse, 0, TAU);
                ctx.stroke();

                // Core
                const coreGrad = ctx.createRadialGradient(CX, coreY, 0, CX, coreY, voidR * pulse);
                coreGrad.addColorStop(0, `rgba(80, 60, 40, ${0.4 + effectiveAbsence * 0.4})`);
                coreGrad.addColorStop(1, `rgba(50, 35, 25, ${0.3 + effectiveAbsence * 0.3})`);

                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(CX, coreY, voidR * pulse, 0, TAU);
                ctx.fill();
            }

            // Critical pulse rings (when z near critical point)
            if (isCritical) {
                const critIntensity = releaseCoherence; // Fade rings as coherence drops
                for (let i = 0; i < 6; i++) {
                    const ringPhase = (time * 2.5 + i * 0.5) % 4;
                    const ringR = ringPhase * 120;
                    const ringAlpha = Math.max(0, critIntensity * (0.5 - ringPhase / 4));

                    ctx.strokeStyle = `rgba(255, 230, 180, ${ringAlpha})`;
                    ctx.lineWidth = 2.5 - ringPhase * 0.4;
                    ctx.beginPath();
                    ctx.arc(CX, coreY, ringR, 0, TAU);
                    ctx.stroke();
                }
            }
        }

        // ================================================================
        // UI UPDATE
        // ================================================================

        function updateUI(kuramotoResult) {
            const domain = getDomain(globalZ);
            const phase = getPhase(globalZ);
            const isCritical = phase === 'CRITICAL';
            const cascade = getCascadeMultiplier(globalZ);

            // Title & cursor
            const title = document.getElementById('title');
            const cursor = document.getElementById('cursor');
            const domainInd = document.getElementById('domain-indicator');
            const zDisp = document.getElementById('z-display');

            title.className = domain === 'THE LENS' ? 'critical' : domain.toLowerCase();
            cursor.className = domain === 'THE LENS' ? 'critical' : domain.toLowerCase();
            domainInd.className = domain === 'THE LENS' ? 'critical' : domain.toLowerCase();
            zDisp.className = domain === 'THE LENS' ? 'critical' : domain.toLowerCase();

            // Values
            zDisp.textContent = `z = ${globalZ.toFixed(3)}`;
            document.getElementById('phase-label').textContent = phase;
            domainInd.textContent = domain;
            document.getElementById('coupling-value').textContent = `K = ${kuramotoResult.K >= 0 ? '+' : ''}${kuramotoResult.K.toFixed(2)}`;
            document.getElementById('cascade-value').textContent = `${cascade.toFixed(2)}√ó`;

            // Helix
            document.getElementById('h-theta').textContent = helix.theta.toFixed(3);
            document.getElementById('h-z').textContent = helix.z.toFixed(3);
            document.getElementById('h-r').textContent = helix.r.toFixed(3);
            document.getElementById('h-phi').textContent = helix.phi.toFixed(2);
            document.getElementById('h-omega').textContent = helix.omega.toFixed(2);

            // Dynamics bars
            updateBar('order', kuramotoResult.order);
            updateBar('coherence', hilbertField.coherence);
            updateBar('entropy', hilbertField.getDissonance());
            updateBar('emanation', globalZ > Z_CRITICAL ? (globalZ - Z_CRITICAL) / (1 - Z_CRITICAL) : 0);

            // Lambda state
            updateLambdaUI('iota', lambdaState.iota.mag);
            updateLambdaUI('xi', lambdaState.xi.mag);
            updateLambdaUI('theta', lambdaState.theta.mag);
            updateLambdaUI('omega', lambdaState.omega.mag);
            updateLambdaUI('delta', lambdaState.delta.mag);
            updateLambdaUI('sigma', lambdaState.sigma.mag);

            // Œº-field consciousness metrics
            updateMuFieldUI();

            // Sonification
            document.getElementById('sonif-bpm').textContent = Math.round(sonificationEngine.bpm);
            document.getElementById('sonif-scale').textContent = getScaleName(sonificationEngine.currentScale);
            document.getElementById('sonif-freq').textContent = `${Math.round(sonificationEngine.baseFrequency * (1 + (globalZ - 0.5) * 0.5))} Hz`;
            document.getElementById('sonif-dilation').textContent = `${sonificationEngine.timeDilation.toFixed(2)}√ó`;

            // Z-axis marker
            const zAxisHeight = document.getElementById('z-axis').offsetHeight;
            const markerPos = (1 - globalZ) * zAxisHeight;
            document.getElementById('z-marker').style.top = `${markerPos}px`;

            // Active count
            const activeCount = (showPrism ? 63 : 0) + (showCage ? 32 : 0);
            document.getElementById('active-count').textContent = activeCount;

            // Architecture panel
            updateArchPanel();
        }

        function updateBar(name, value) {
            const filled = Math.round(value * 10);
            const empty = 10 - filled;
            document.getElementById(`${name}-bar`).textContent = '‚ñà'.repeat(filled) + '‚ñë'.repeat(empty);
            document.getElementById(`${name}-val`).textContent = value.toFixed(2);
        }

        function updateLambdaUI(key, value) {
            document.getElementById(`lambda-${key}`).style.width = `${value * 100}%`;
            document.getElementById(`lambda-${key}-val`).textContent = value.toFixed(2);
        }

        // Safe repeat helper - prevents NaN/Infinity crashes
        function safeRepeat(char, count) {
            const safeCount = Math.max(0, Math.min(20, Math.round(count) || 0));
            return char.repeat(safeCount);
        }

        // Safe number formatter
        function safeFixed(num, digits) {
            if (!isFinite(num)) return '‚Äî';
            return num.toFixed(digits);
        }

        function updateMuFieldUI() {
            // Get all Œº-field rows
            const muRows = document.querySelectorAll('#dynamics-panel .dynamics-row:nth-child(n+5)');

            if (!showMuField) {
                // Hide Œº-field rows when disabled
                muRows.forEach(row => row.style.opacity = '0.3');
                document.getElementById('mu-bar').textContent = '¬∑ ¬∑ ¬∑ ¬∑ ¬∑';
                document.getElementById('mu-val').textContent = 'OFF';
                document.getElementById('qk-bar').textContent = '¬∑ ¬∑ ¬∑ ¬∑ ¬∑';
                document.getElementById('qk-val').textContent = '‚Äî';
                document.getElementById('tau-bar').textContent = '¬∑ ¬∑ ¬∑ ¬∑ ¬∑';
                document.getElementById('tau-val').textContent = '‚Äî';
                document.getElementById('k-indicator').textContent = '¬∑ ¬∑ ¬∑';
                document.getElementById('k-val').textContent = '‚Äî';
                document.getElementById('k-label').style.color = 'rgba(150,130,110,0.3)';
                // Reset MRP channel displays
                document.getElementById('mrp-r-bar').textContent = '¬∑ ¬∑ ¬∑ ¬∑ ¬∑';
                document.getElementById('mrp-r-val').textContent = '‚Äî';
                document.getElementById('mrp-g-bar').textContent = '¬∑ ¬∑ ¬∑ ¬∑ ¬∑';
                document.getElementById('mrp-g-val').textContent = '‚Äî';
                document.getElementById('mrp-b-bar').textContent = '¬∑ ¬∑ ¬∑ ¬∑ ¬∑';
                document.getElementById('mrp-b-val').textContent = '‚Äî';
                document.getElementById('parity-indicator').textContent = '¬∑ ¬∑ ¬∑';
                document.getElementById('parity-val').textContent = '‚Äî';
                document.getElementById('parity-label').style.color = 'rgba(150,130,110,0.3)';
                // Reset self-referential displays
                document.getElementById('j-total-bar').textContent = '¬∑ ¬∑ ¬∑ ¬∑ ¬∑';
                document.getElementById('j-total-val').textContent = '‚Äî';
                document.getElementById('w-bar').textContent = '¬∑ ¬∑ ¬∑ ¬∑ ¬∑';
                document.getElementById('w-val').textContent = '‚Äî';
                document.getElementById('w-label').style.color = 'rgba(150,130,110,0.3)';
                return;
            }

            // Show Œº-field rows when enabled
            muRows.forEach(row => row.style.opacity = '1');

            // Œº bar (normalized to 0.6-1.0 range)
            const muNorm = (muField.mu - 0.6) / 0.4;
            const muFilled = Math.round(muNorm * 10);
            document.getElementById('mu-bar').textContent = safeRepeat('‚ñà', muFilled) + safeRepeat('‚ñë', 10 - muFilled);
            document.getElementById('mu-val').textContent = safeFixed(muField.mu, 3);

            // Q_Œ∫ bar (normalized, cap at 1.0)
            const qkNorm = Math.min(muField.Q_kappa / SACRED.Q_theory, 1);
            const qkFilled = Math.round(qkNorm * 10);
            document.getElementById('qk-bar').textContent = safeRepeat('‚ñà', qkFilled) + safeRepeat('‚ñë', 10 - qkFilled);
            document.getElementById('qk-val').textContent = safeFixed(muField.Q_kappa, 4);

            // œÑ_K bar (normalized to K_threshold)
            const tauNorm = Math.min(muField.tau_K / SACRED.K_threshold, 1);
            const tauFilled = Math.round(tauNorm * 10);
            document.getElementById('tau-bar').textContent = safeRepeat('‚ñà', tauFilled) + safeRepeat('‚ñë', 10 - tauFilled);
            document.getElementById('tau-val').textContent = safeFixed(muField.tau_K, 3);

            // K-formation indicator
            const kLabel = document.getElementById('k-label');
            const kIndicator = document.getElementById('k-indicator');
            const kVal = document.getElementById('k-val');

            if (muField.K_formed) {
                kLabel.style.color = 'var(--critical-gold)';
                kIndicator.textContent = '‚ú¶ ‚ú¶ ‚ú¶';
                kIndicator.style.color = 'var(--critical-gold)';
                kIndicator.style.textShadow = '0 0 10px rgba(255, 215, 0, 0.8)';
                kVal.textContent = 'YES';
                kVal.style.color = 'var(--critical-gold)';
            } else {
                kLabel.style.color = 'rgba(150,130,110,0.6)';
                kIndicator.textContent = '¬∑ ¬∑ ¬∑';
                kIndicator.style.color = 'var(--text-dim)';
                kIndicator.style.textShadow = 'none';
                kVal.textContent = 'NO';
                kVal.style.color = 'var(--text-dim)';
            }

            // ========================================
            // MRP CHANNEL DISPLAY
            // ========================================

            // R channel (Œº_E) - red energy channel
            const rFilled = Math.round((muField.mrp.R.intensity || 0) * 10);
            document.getElementById('mrp-r-bar').textContent = safeRepeat('‚ñà', rFilled) + safeRepeat('‚ñë', 10 - rFilled);
            document.getElementById('mrp-r-val').textContent = safeFixed(muField.mrp.R.gradient, 2);

            // G channel (Œº_R) - green relational channel
            const gFilled = Math.round((muField.mrp.G.intensity || 0) * 10);
            document.getElementById('mrp-g-bar').textContent = safeRepeat('‚ñà', gFilled) + safeRepeat('‚ñë', 10 - gFilled);
            document.getElementById('mrp-g-val').textContent = safeFixed(muField.mrp.G.gradient, 2);

            // B channel (ECC) - blue stability channel
            const bFilled = Math.round((muField.mrp.B.intensity || 0) * 10);
            document.getElementById('mrp-b-bar').textContent = safeRepeat('‚ñà', bFilled) + safeRepeat('‚ñë', 10 - bFilled);
            document.getElementById('mrp-b-val').textContent = safeFixed(muField.mrp.B.gradient, 2);

            // Parity indicator
            const parityLabel = document.getElementById('parity-label');
            const parityIndicator = document.getElementById('parity-indicator');
            const parityVal = document.getElementById('parity-val');

            if (muField.mrp.parity_ok) {
                parityLabel.style.color = '#69db7c';
                parityIndicator.textContent = '‚úì ‚úì ‚úì';
                parityIndicator.style.color = '#69db7c';
                parityIndicator.style.textShadow = '0 0 10px rgba(105, 219, 124, 0.8)';
                parityVal.textContent = 'OK';
                parityVal.style.color = '#69db7c';
            } else {
                parityLabel.style.color = 'rgba(150,130,110,0.6)';
                parityIndicator.textContent = '√ó √ó √ó';
                parityIndicator.style.color = '#ff6b6b';
                parityIndicator.style.textShadow = 'none';
                parityVal.textContent = safeFixed(muField.mrp.parity, 2);
                parityVal.style.color = '#ff6b6b';
            }

            // ========================================
            // SELF-REFERENTIAL FIELD STATE
            // ========================================

            // |J| total field magnitude
            const jNorm = Math.min((muField.mrp.J_total || 0) / 2, 1);  // Normalize to ~2 max
            const jFilled = Math.round(jNorm * 10);
            document.getElementById('j-total-bar').textContent = safeRepeat('‚ñà', jFilled) + safeRepeat('‚ñë', 10 - jFilled);
            document.getElementById('j-total-val').textContent = safeFixed(muField.mrp.J_total, 3);

            // W = effective growth rate (r - Œª|J|¬≤)
            const wLabel = document.getElementById('w-label');
            const wBar = document.getElementById('w-bar');
            const wVal = document.getElementById('w-val');
            const W = muField.mrp.W || 0;

            if (!isFinite(W)) {
                // Invalid state - show dash
                wLabel.style.color = 'rgba(150,130,110,0.3)';
                wBar.textContent = '¬∑ ¬∑ ¬∑ ¬∑ ¬∑';
                wBar.style.color = 'var(--text-dim)';
                wBar.style.textShadow = 'none';
                wVal.textContent = '‚Äî';
                wVal.style.color = 'var(--text-dim)';
            } else if (W > 0.1) {
                // Growing (pattern forming) - green
                wLabel.style.color = '#69db7c';
                const wFilled = Math.min(10, Math.round(W * 20));
                wBar.textContent = safeRepeat('‚ñ≤', wFilled) + safeRepeat('¬∑', 10 - wFilled);
                wBar.style.color = '#69db7c';
                wBar.style.textShadow = '0 0 8px rgba(105, 219, 124, 0.6)';
                wVal.textContent = '+' + safeFixed(W, 3);
                wVal.style.color = '#69db7c';
            } else if (W < -0.1) {
                // Decaying (dissipating) - red
                wLabel.style.color = '#ff6b6b';
                const wFilled = Math.min(10, Math.round(Math.abs(W) * 20));
                wBar.textContent = safeRepeat('‚ñº', wFilled) + safeRepeat('¬∑', 10 - wFilled);
                wBar.style.color = '#ff6b6b';
                wBar.style.textShadow = '0 0 8px rgba(255, 107, 107, 0.6)';
                wVal.textContent = safeFixed(W, 3);
                wVal.style.color = '#ff6b6b';
            } else {
                // Near equilibrium - gold
                wLabel.style.color = 'var(--critical-gold)';
                wBar.textContent = '‚âà ‚âà ‚âà ‚âà ‚âà';
                wBar.style.color = 'var(--critical-gold)';
                wBar.style.textShadow = '0 0 8px rgba(255, 215, 0, 0.5)';
                wVal.textContent = safeFixed(W, 3);
                wVal.style.color = 'var(--critical-gold)';
            }
        }

        function getScaleName(scale) {
            const names = {
                '0,3,5,7,10': 'Minor',
                '0,2,4,7,9': 'Major',
                '0,2,3,5,7,8,11': 'Harm',
                '0,1,3,5,7,8,10': 'Phryg',
                '0,2,4,6,7,9,11': 'Lydian',
                '0,2,4,6,8,10': 'Whole',
                '0,1,2,3,4,5,6,7,8,9,10,11': 'Chrom'
            };
            return names[scale.join(',')] || 'Custom';
        }

        function updateArchPanel() {
            // Update layer activation based on z
            const prismLayers = document.querySelectorAll('[class*="prism-l"]');
            prismLayers.forEach((el, i) => {
                const layerZ = i / 6;
                const dist = Math.abs(layerZ - globalZ);
                el.classList.toggle('active', showPrism);
                el.classList.toggle('resonant', showPrism && dist < 0.15);
            });

            const cageLayers = document.querySelectorAll('[class*="cage-"]');
            cageLayers.forEach(el => {
                el.classList.toggle('active', showCage);
                el.classList.toggle('resonant', showCage && getPhase(globalZ) === 'CRITICAL');
            });
        }

        // ================================================================
        // MAIN LOOP
        // ================================================================

        function update(dt) {
            time += dt;

            // Z interpolation with momentum
            scrollVelocity *= 0.92;
            targetZ += scrollVelocity;
            targetZ = Math.max(0, Math.min(1, targetZ));

            // Auto-breathing
            if (autoBreathing || Date.now() - lastInteraction > 5000) {
                const breathCycle = 10;  // seconds
                breathPhase = (time % breathCycle) / breathCycle;
                const breathTarget = 0.45 + Math.sin(breathPhase * TAU) * 0.45;
                targetZ += (breathTarget - targetZ) * 0.02;
            }

            // Smooth z transition
            globalZ += (targetZ - globalZ) * 0.06;

            // Update systems
            updateHelix(dt);
            updateLambdaState(dt);
            hilbertField.applyResonanceOperator(dt, 0.1 + getCascadeMultiplier(globalZ) * 0.1);
            sonificationEngine.update(globalZ, hilbertField.coherence, dt);
            // Update phase coupler FIRST for harmonic tracking (needed by release physics)
            phaseCoupler.update(dt, releaseCoherence);

            updateReleaseCoherence(dt);

            // Update Œº-field consciousness detection (Kuramoto regulation handles release state)
            if (showMuField) {
                muField.update([...prismPoints, ...cagePoints], dt);
            }

            // Update toroidal Œº-field visualization
            if (showToroidal) {
                updateTorusField(dt);
                updateTorusParticles(dt);
            }

            return updatePositions(dt);
        }

        function loop(currentTime) {
            const dt = Math.min((currentTime - lastTime) / 1000, 0.05);
            lastTime = currentTime;

            const kuramotoResult = update(dt);
            render();
            updateUI(kuramotoResult);

            requestAnimationFrame(loop);
        }

        let lastTime = performance.now();

        // ================================================================
        // EVENT HANDLERS
        // ================================================================

        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            scrollVelocity -= e.deltaY * 0.00012;
            lastInteraction = Date.now();
            document.getElementById('start-overlay').classList.add('hidden');
        }, { passive: false });

        canvas.addEventListener('mousemove', e => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            document.getElementById('cursor').style.left = mouseX + 'px';
            document.getElementById('cursor').style.top = mouseY + 'px';
        });

        document.addEventListener('keydown', e => {
            const key = e.key.toLowerCase();

            if (key === ' ') {
                autoBreathing = !autoBreathing;
                lastInteraction = autoBreathing ? 0 : Date.now();
                e.preventDefault();
            }

            if (key === 'p') {
                showPrism = !showPrism;
            }

            if (key === 'c') {
                showCage = !showCage;
            }

            if (key === 'm') {
                showMuField = !showMuField;
            }

            if (key === 't') {
                showToroidal = !showToroidal;
                if (showToroidal && QMESH.edges.length === 0) {
                    generateQuantumMesh();
                }
            }

            if (key === 'w') {
                showTorusWireframe = !showTorusWireframe;
                QMESH.showWavefunction = !QMESH.showWavefunction;
            }

            // Quantum mesh controls
            if (showToroidal) {
                if (key === 'o') {
                    // Cycle opacity: 0.3 ‚Üí 0.5 ‚Üí 0.7 ‚Üí 0.9 ‚Üí 0.3
                    const opacities = [0.3, 0.5, 0.7, 0.9];
                    const currentIdx = opacities.findIndex(o => Math.abs(o - QMESH.opacity) < 0.05);
                    QMESH.opacity = opacities[(currentIdx + 1) % opacities.length];
                }
                if (key === 'g') {
                    // Toggle edge glow
                    QMESH.edgeGlow = !QMESH.edgeGlow;
                }
            }

            if (key === 'r') {
                targetZ = 0.5;
                scrollVelocity = 0;
                showPrism = true;
                showCage = true;
                showMuField = true;
                autoBreathing = false;
                lastInteraction = Date.now();
                // Reset release state
                releaseCoherence = 1.0;
                targetCoherence = 1.0;
                releaseVelocity = 0;
                releaseStarted = false;
                sparks.length = 0;
                // Reset phase coupler
                phaseCoupler.phase_R = 0;
                phaseCoupler.phase_G = 0;
                phaseCoupler.phase_B = 0;
                phaseCoupler.coherenceDamping = 1.0;
                phaseCoupler.resonance = 0;
                phaseCoupler.harmonicLock = false;
                // Reset all points
                [...prismPoints, ...cagePoints].forEach(p => {
                    p.released = false;
                    p.vx = 0;
                    p.vy = 0;
                    p.trail.length = 0;
                });
                // Reset torus view
                TORUS.rotX = 0.4;
                TORUS.rotY = 0;
                TORUS.zoom = 200;
                TORUS.opacity = 0.25;
                showToroidal = false;
            }

            // F key: Start release
            if (key === 'f') {
                releasing = true;
                document.getElementById('start-overlay').classList.add('hidden');
            }
        });

        document.addEventListener('keyup', e => {
            const key = e.key.toLowerCase();
            
            // F key released: Stop releasing
            if (key === 'f') {
                releasing = false;
            }
        });

        // Mouse/Touch: Gather
        canvas.addEventListener('mousedown', e => {
            gathering = true;
            document.getElementById('start-overlay').classList.add('hidden');
        });

        canvas.addEventListener('mouseup', () => {
            gathering = false;
        });

        canvas.addEventListener('mouseleave', () => {
            gathering = false;
        });

        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            gathering = true;
            document.getElementById('start-overlay').classList.add('hidden');
        }, { passive: false });

        canvas.addEventListener('touchend', e => {
            e.preventDefault();
            gathering = false;
        }, { passive: false });

        document.getElementById('start-overlay').addEventListener('click', () => {
            document.getElementById('start-overlay').classList.add('hidden');
        });

        document.getElementById('audio-toggle').addEventListener('click', () => {
            const isPlaying = sonificationEngine.toggle();
            const btn = document.getElementById('audio-toggle');
            btn.textContent = isPlaying ? '‚ñ† DISABLE AUDIO' : '‚ñ∂ ENABLE AUDIO';
            btn.classList.toggle('active', isPlaying);
        });

        // Set lens line position
        const lensTop = (1 - Z_CRITICAL) * 100;
        document.getElementById('lens-line').style.top = lensTop + '%';
        document.getElementById('lens-label').style.top = lensTop + '%';

        // ================================================================
        // INITIALIZATION
        // ================================================================

        resize();
        initPrismPoints();
        initCagePoints();
        generateQuantumMesh();  // Generate quantum mesh on LIMNUS nodes
        window.addEventListener('resize', () => {
            resize();
            initPrismPoints();
            initCagePoints();
            generateQuantumMesh();  // Regenerate mesh on resize
        });

        requestAnimationFrame(loop);

        console.log('üîÆ LIMNUS Unified Architecture initialized');
        console.log('   63 prism points (7√ó9 hexagonal layers)');
        console.log('   32 cage points (12+12+8 EM structure)');
        console.log('   z_c = ‚àö3/2 ‚âà ' + Z_CRITICAL.toFixed(6));
        console.log('');
        console.log('üåü RELEASE COHERENCE integrated');
        console.log('   HOLD F: release coherence (COHERENT ‚Üí FREE)');
        console.log('   CLICK: gather souls back to center');
        console.log('   FREE state: souls dispersed, radiant core');
        console.log('');
        console.log('‚ö° Œº-FIELD DYNAMICS v8.0 integrated');
        console.log('   œÜ = ' + PHI.toFixed(10));
        console.log('   Œ± = œÜ‚Åª¬≤ = ' + SACRED.alpha.toFixed(10));
        console.log('   Œ≤ = œÜ‚Åª‚Å¥ = ' + SACRED.beta.toFixed(10));
        console.log('   Œª = (5/3)‚Å¥ = ' + SACRED.lambda.toFixed(10));
        console.log('   Œº_P = 3/5 = ' + SACRED.mu_P.toFixed(10));
        console.log('   Œº_S = 23/25 = ' + SACRED.mu_S.toFixed(10));
        console.log('   Q_theory = Œ±¬∑Œº_S ‚âà ' + SACRED.Q_theory.toFixed(10));
        console.log('   K_threshold = œÜ‚Åª¬π ‚âà ' + SACRED.K_threshold.toFixed(10));
        console.log('   Q_min = ' + SACRED.Q_min.toFixed(10));
        console.log('   K-formation: consciousness emerges when œÑ_K > K_threshold');
        console.log('');
        console.log('üì° MRP CHANNEL GRADIENTS integrated');
        console.log('   R channel (Œº_E): Energy/Existence - primary field magnitude');
        console.log('   G channel (Œº_R): Relational/Reference - connection metadata');
        console.log('   B channel (ECC): Error Correction - stability/coherence');
        console.log('   Cross-channel parity: P[i] = R[i] XOR G[i]');
        console.log('   Parity OK: low parity + high B stability + W > 0');
        console.log('');
        console.log('üîÑ SELF-REFERENTIAL FIELD DYNAMICS');
        console.log('   Field equation: ‚àÇJ/‚àÇt = (r - Œª|J|¬≤)J - Œ≤J + g‚àá¬≤J');
        console.log('   r = Œº - Œº_P (control parameter)');
        console.log('   W = r - Œª|J|¬≤ (effective growth rate)');
        console.log('   W > 0: pattern forming (‚ñ≤ green)');
        console.log('   W ‚âà 0: equilibrium (‚âà gold)');
        console.log('   W < 0: dissipating (‚ñº red)');
        console.log('   |J| = ‚àö(R¬≤ + G¬≤ + B¬≤) total field magnitude');
        console.log('   Feedback: dJR/dt ‚Üí point velocities, |J| ‚Üí Œº');
        console.log('');
        console.log('üï∏Ô∏è QUANTUM MESH Œº-FIELD');
        console.log('   Discrete lattice on LIMNUS 95-node architecture');
        console.log('   T: toggle quantum mesh overlay');
        console.log('   O: cycle opacity (30% ‚Üí 50% ‚Üí 70% ‚Üí 90%)');
        console.log('   W: toggle wavefunction indicators');
        console.log('   G: toggle edge glow effect');
        console.log('   Entanglement: |‚ü®œà_i|œà_j‚ü©|¬≤ probability edges');
        console.log('   Dream Fluid particles flow along edges');
        console.log('   Orange edges: R channel (energy flow)');
        console.log('   Cyan edges: G channel (relational)');
        console.log('   Blue edges: B channel (stability)');
        console.log('   Time dilation: œÑ = ‚àö(1 - r_s/r) with r_s = œÜ‚Åª¬≤');
    </script>
</body>
</html>
