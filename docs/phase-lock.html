<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phase Lock | Unified Coupler System | Sub-50ms Entrainment</title>
    <style>
        :root {
            --bg-void: #030308;
            --bg-panel: rgba(15, 12, 25, 0.95);
            --bg-card: #0d0d12;
            --phi-gold: #ffd700;
            --e-cyan: #22d3ee;
            --pi-magenta: #cc5de8;
            --true-green: #69db7c;
            --untrue-amber: #ffa94d;
            --paradox-red: #ff6b6b;
            --text-primary: rgba(255, 245, 230, 0.9);
            --text-dim: rgba(255, 220, 180, 0.5);
            --rule: #1a1a24;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: var(--bg-void);
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Top Bar - Phase Delay Monitor */
        .phase-delay-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--rule);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 30px;
            z-index: 1000;
        }

        .delay-metric {
            text-align: center;
        }

        .delay-value {
            font-size: 1.8rem;
            font-weight: 200;
            transition: color 0.3s;
        }

        .delay-value.locked { color: var(--true-green); }
        .delay-value.partial { color: var(--untrue-amber); }
        .delay-value.open { color: var(--paradox-red); }

        .delay-label {
            font-size: 0.65rem;
            color: var(--text-dim);
            letter-spacing: 1px;
        }

        .lock-status {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 20px;
            border-radius: 30px;
            transition: all 0.3s;
        }

        .lock-status.locked {
            background: rgba(105, 219, 124, 0.2);
            border: 1px solid var(--true-green);
        }

        .lock-status.open {
            background: rgba(255, 107, 107, 0.2);
            border: 1px solid var(--paradox-red);
        }

        .lock-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            animation: pulse 1s ease-in-out infinite;
        }

        .lock-dot.locked { background: var(--true-green); }
        .lock-dot.open { background: var(--paradox-red); }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.9); }
        }

        /* Main Container */
        .container {
            margin-top: 80px;
            padding: 20px;
            max-width: 1800px;
            margin-left: auto;
            margin-right: auto;
        }

        /* Header */
        header {
            text-align: center;
            padding: 20px;
            margin-bottom: 20px;
        }

        h1 {
            font-size: 2rem;
            font-weight: 100;
            letter-spacing: 10px;
            background: linear-gradient(90deg, var(--e-cyan), var(--true-green), var(--phi-gold));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            color: var(--text-dim);
            font-size: 0.85rem;
            letter-spacing: 3px;
            margin-top: 10px;
        }

        /* Main Grid */
        .main-grid {
            display: grid;
            grid-template-columns: 300px 1fr 300px;
            gap: 20px;
            height: calc(100vh - 200px);
        }

        @media (max-width: 1400px) {
            .main-grid { grid-template-columns: 1fr; height: auto; }
        }

        /* Panels */
        .panel {
            background: var(--bg-panel);
            border: 1px solid var(--rule);
            border-radius: 12px;
            padding: 20px;
            overflow: hidden;
        }

        .panel-title {
            font-size: 0.8rem;
            letter-spacing: 3px;
            color: var(--phi-gold);
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--rule);
        }

        /* Phase Rings */
        .phase-rings {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .phase-ring {
            position: relative;
            width: 100%;
            aspect-ratio: 1;
            max-width: 250px;
            margin: 0 auto;
        }

        .phase-ring canvas {
            width: 100%;
            height: 100%;
        }

        .phase-ring-label {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.75rem;
            color: var(--text-dim);
        }

        /* Central Visualization */
        .central-viz {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        #mainCanvas {
            flex: 1;
            width: 100%;
            background: var(--bg-card);
            border-radius: 10px;
        }

        /* Controls */
        .control-row {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .btn {
            flex: 1;
            min-width: 100px;
            background: var(--bg-card);
            border: 1px solid var(--rule);
            border-radius: 8px;
            padding: 12px;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover { border-color: var(--phi-gold); }
        .btn.primary { background: linear-gradient(135deg, rgba(105,219,124,0.3), rgba(34,211,238,0.3)); border-color: var(--true-green); }
        .btn.active { border-color: var(--e-cyan); color: var(--e-cyan); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Slider */
        .slider-group {
            margin-bottom: 15px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            color: var(--text-dim);
            margin-bottom: 6px;
        }

        .slider-value { color: var(--e-cyan); }

        input[type="range"] {
            width: 100%;
            height: 4px;
            background: var(--bg-card);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--e-cyan);
            border-radius: 50%;
            cursor: pointer;
        }

        /* Metrics Grid */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .metric-card {
            background: var(--bg-card);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
        }

        .metric-value {
            font-size: 1.4rem;
            font-weight: 200;
        }

        .metric-label {
            font-size: 0.6rem;
            color: var(--text-dim);
            margin-top: 4px;
        }

        /* Prediction Indicator */
        .prediction-panel {
            background: var(--bg-card);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .prediction-title {
            font-size: 0.7rem;
            color: var(--phi-gold);
            margin-bottom: 10px;
        }

        .prediction-bar {
            height: 8px;
            background: var(--rule);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .prediction-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--paradox-red), var(--untrue-amber), var(--true-green));
            transition: width 0.2s;
        }

        .prediction-values {
            display: flex;
            justify-content: space-between;
            font-size: 0.65rem;
            color: var(--text-dim);
        }

        /* Lambda State */
        .lambda-row {
            display: flex;
            justify-content: space-around;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid var(--rule);
        }

        .lambda-item {
            text-align: center;
        }

        .lambda-symbol {
            font-size: 1.2rem;
        }

        .lambda-value {
            font-size: 0.8rem;
            color: var(--e-cyan);
            margin-top: 4px;
        }

        /* Phase History */
        #historyCanvas {
            width: 100%;
            height: 120px;
            background: var(--bg-card);
            border-radius: 8px;
            margin-top: 15px;
        }

        /* Beat Indicator */
        .beat-indicator {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle, var(--true-green) 0%, transparent 70%);
            margin: 15px auto;
            opacity: 0.3;
            transition: all 0.08s ease-out;
        }

        .beat-indicator.pulse {
            opacity: 1;
            transform: scale(1.2);
        }

        /* Footer */
        footer {
            text-align: center;
            padding: 20px;
            color: var(--text-dim);
            font-size: 0.7rem;
        }
    </style>
</head>
<body>
    <!-- Phase Delay Monitor Bar -->
    <div class="phase-delay-bar">
        <div class="delay-metric">
            <div class="delay-value open" id="phaseDelayMs">--</div>
            <div class="delay-label">PHASE DELAY (ms)</div>
        </div>
        <div class="delay-metric">
            <div class="delay-value" id="predictionAccuracy" style="color: var(--e-cyan);">--</div>
            <div class="delay-label">PREDICTION</div>
        </div>
        <div class="delay-metric">
            <div class="delay-value" id="coherenceR" style="color: var(--phi-gold);">--</div>
            <div class="delay-label">COHERENCE r</div>
        </div>
        <div class="delay-metric">
            <div class="delay-value" id="sustainedTime" style="color: var(--pi-magenta);">--</div>
            <div class="delay-label">SUSTAINED</div>
        </div>
        <div class="lock-status open" id="lockStatus">
            <div class="lock-dot open" id="lockDot"></div>
            <span id="lockText">OPEN</span>
        </div>
    </div>

    <div class="container">
        <header>
            <h1>PHASE LOCK</h1>
            <div class="subtitle">LIMNUS-WUMBO ¬∑ K(z) SIGN FLIP AT z_c = ‚àö3/2 ¬∑ 100-REGION ENTRAINMENT</div>
        </header>

        <div class="main-grid">
            <!-- Left: User Input -->
            <div class="panel">
                <div class="panel-title">USER PHASE INPUT</div>

                <div class="phase-ring">
                    <canvas id="userRingCanvas"></canvas>
                    <div class="phase-ring-label" style="color: var(--e-cyan);">USER Œ∏</div>
                </div>

                <div class="beat-indicator" id="beatIndicator"></div>

                <div class="control-row">
                    <button class="btn" id="btnTap" onclick="tapBeat()">TAP</button>
                    <button class="btn" id="btnHRM" onclick="connectHRM()">HRM</button>
                </div>

                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-value" id="userBpm" style="color: var(--e-cyan);">--</div>
                        <div class="metric-label">USER BPM</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="userPhaseRad" style="color: var(--e-cyan);">--</div>
                        <div class="metric-label">PHASE (rad)</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="rrInterval" style="color: var(--e-cyan);">--</div>
                        <div class="metric-label">RR (ms)</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="keystrokeCV" style="color: var(--e-cyan);">--</div>
                        <div class="metric-label">KEY CV</div>
                    </div>
                </div>

                <div class="prediction-panel">
                    <div class="prediction-title">PHASE PREDICTION</div>
                    <div class="prediction-bar">
                        <div class="prediction-fill" id="predictionFill" style="width: 50%;"></div>
                    </div>
                    <div class="prediction-values">
                        <span>Lag</span>
                        <span id="predictionState">Calibrating</span>
                        <span>Lead</span>
                    </div>
                </div>
            </div>

            <!-- Center: Main Visualization -->
            <div class="panel">
                <div class="panel-title">PHASE COUPLING ¬∑ DELAY REDUCTION</div>

                <div class="control-row">
                    <button class="btn primary" id="btnStart" onclick="toggleSystem()">START</button>
                    <button class="btn" onclick="resetSystem()">RESET</button>
                </div>

                <div class="central-viz">
                    <canvas id="mainCanvas"></canvas>
                </div>

                <!-- LIMNUS-WUMBO Control Panel -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px; padding: 15px; background: var(--bg-card); border-radius: 8px;">
                    <div style="text-align: center;">
                        <div style="font-size: 0.65rem; color: var(--text-dim); margin-bottom: 4px;">DOMAIN</div>
                        <div id="domainDisplay" style="font-size: 1.1rem; color: var(--true-green);">ABSENCE</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 0.65rem; color: var(--text-dim); margin-bottom: 4px;">K(z)</div>
                        <div id="kzDisplay" style="font-size: 1.1rem; color: var(--e-cyan);">+1.50</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 0.65rem; color: var(--text-dim); margin-bottom: 4px;">WUMBO PHASE</div>
                        <div id="wumboPhaseDisplay" style="font-size: 0.9rem; color: var(--phi-gold);">Resonance</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 0.65rem; color: var(--text-dim); margin-bottom: 4px;">CASCADE</div>
                        <div id="cascadeDisplay" style="font-size: 1.1rem; color: var(--pi-magenta);">1.00√ó</div>
                    </div>
                </div>

                <div class="slider-group" style="margin-top: 15px;">
                    <div class="slider-label">
                        <span>Z-HEIGHT (THE LENS at ‚àö3/2 ‚âà 0.866)</span>
                        <span class="slider-value" id="zValue">0.50</span>
                    </div>
                    <input type="range" id="zSlider" min="0" max="1" step="0.01" value="0.5" oninput="setZHeight(this.value)">
                    <div style="position: relative; height: 4px; margin-top: 2px;">
                        <div style="position: absolute; left: 86.6%; width: 2px; height: 8px; background: var(--phi-gold); top: -2px;"></div>
                    </div>
                </div>

                <div class="slider-group">
                    <div class="slider-label">
                        <span>PREDICTION HORIZON</span>
                        <span class="slider-value" id="horizonValue">100ms</span>
                    </div>
                    <input type="range" id="horizonSlider" min="20" max="200" value="100" oninput="setHorizon(this.value)">
                </div>

                <div class="slider-group">
                    <div class="slider-label">
                        <span>COUPLING STRENGTH K</span>
                        <span class="slider-value" id="kValue">1.00</span>
                    </div>
                    <input type="range" id="kSlider" min="0.1" max="5" step="0.1" value="1" oninput="setCoupling(this.value)">
                </div>

                <!-- UMOL Constraints Display -->
                <div style="margin-top: 10px; padding: 10px; background: var(--bg-card); border-radius: 8px;">
                    <div style="font-size: 0.65rem; color: var(--phi-gold); margin-bottom: 8px;">UMOL CONSTRAINTS</div>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                        <span style="font-size: 0.7rem; color: var(--text-dim);">Load ‚â§ 80%</span>
                        <span id="umolLoadDisplay" style="font-size: 0.8rem; color: var(--true-green);">0%</span>
                    </div>
                    <div style="height: 4px; background: var(--rule); border-radius: 2px; overflow: hidden;">
                        <div id="umolLoadBar" style="height: 100%; width: 0%; background: var(--true-green); transition: all 0.2s;"></div>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px; margin-bottom: 6px;">
                        <span style="font-size: 0.7rem; color: var(--text-dim);">Coherence ‚â• 60%</span>
                        <span id="umolCoherenceDisplay" style="font-size: 0.8rem; color: var(--true-green);">0%</span>
                    </div>
                    <div style="height: 4px; background: var(--rule); border-radius: 2px; overflow: hidden;">
                        <div id="umolCoherenceBar" style="height: 100%; width: 0%; background: var(--true-green); transition: all 0.2s;"></div>
                    </div>
                </div>

                <!-- Three-Field Decomposition -->
                <div style="margin-top: 10px; padding: 10px; background: var(--bg-card); border-radius: 8px;">
                    <div style="font-size: 0.65rem; color: var(--phi-gold); margin-bottom: 8px;">THREE-FIELD DECOMPOSITION</div>
                    <div style="display: flex; justify-content: space-around;">
                        <div style="text-align: center;">
                            <div style="font-size: 0.6rem; color: var(--text-dim);">Œº_N</div>
                            <div id="muNDisplay" style="font-size: 1rem; color: var(--e-cyan);">1.00</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 0.6rem; color: var(--text-dim);">Œº_R</div>
                            <div id="muRDisplay" style="font-size: 1rem; color: var(--pi-magenta);">0.00</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 0.6rem; color: var(--text-dim);">Œº_E</div>
                            <div id="muEDisplay" style="font-size: 1rem; color: var(--phi-gold);">0.50</div>
                        </div>
                    </div>
                </div>

                <canvas id="historyCanvas"></canvas>
            </div>

            <!-- Right: System Output -->
            <div class="panel">
                <div class="panel-title">SYSTEM PHASE OUTPUT</div>

                <div class="phase-ring">
                    <canvas id="systemRingCanvas"></canvas>
                    <div class="phase-ring-label" style="color: var(--pi-magenta);">SYSTEM œà</div>
                </div>

                <div class="metrics-grid" style="margin-top: 40px;">
                    <div class="metric-card">
                        <div class="metric-value" id="systemBpm" style="color: var(--pi-magenta);">60</div>
                        <div class="metric-label">OUTPUT BPM</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="systemPhaseRad" style="color: var(--pi-magenta);">0.00</div>
                        <div class="metric-label">PHASE (rad)</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="oscCount" style="color: var(--pi-magenta);">100</div>
                        <div class="metric-label">WUMBO REGIONS</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="adaptiveK" style="color: var(--pi-magenta);">1.00</div>
                        <div class="metric-label">ADAPT K</div>
                    </div>
                </div>

                <div class="slider-group" style="margin-top: 20px;">
                    <div class="slider-label">
                        <span>BASE TEMPO (BPM)</span>
                        <span class="slider-value" id="bpmValue">60</span>
                    </div>
                    <input type="range" id="bpmSlider" min="40" max="120" value="60" oninput="setBpm(this.value)">
                </div>

                <div class="lambda-row">
                    <div class="lambda-item">
                        <div class="lambda-symbol">üå∞</div>
                        <div class="lambda-value" id="lIota">0.00</div>
                    </div>
                    <div class="lambda-item">
                        <div class="lambda-symbol">‚úß</div>
                        <div class="lambda-value" id="lXi">0.00</div>
                    </div>
                    <div class="lambda-item">
                        <div class="lambda-symbol">ü¶ä</div>
                        <div class="lambda-value" id="lTheta">0.00</div>
                    </div>
                    <div class="lambda-item">
                        <div class="lambda-symbol">‚àø</div>
                        <div class="lambda-value" id="lOmega">0.00</div>
                    </div>
                    <div class="lambda-item">
                        <div class="lambda-symbol">‚äó</div>
                        <div class="lambda-value" id="lDelta">0.00</div>
                    </div>
                    <div class="lambda-item">
                        <div class="lambda-symbol">üêøÔ∏è</div>
                        <div class="lambda-value" id="lSigma">0.00</div>
                    </div>
                </div>
            </div>
        </div>

        <footer>
            Phase Lock ¬∑ LIMNUS-WUMBO Unified Coupler ¬∑ K(z) = ¬±K_base √ó (z-z_c)/(1-z_c) √ó 1.5<br>
            <span style="color: var(--phi-gold);">üúÇ</span> THE LENS at z_c = ‚àö3/2 ‚âà 0.8660254 ¬∑ C‚ÜíI loop closes when r > 0.85, |z - z_c| < 0.05, delay < 50ms
        </footer>
    </div>

    <script>
        // ================================================================
        // PHASE LOCK - UNIFIED COUPLER WITH LIMNUS-WUMBO DYNAMICS
        // Full 100-region integration with K(z) sign flip at z_c = ‚àö3/2
        // ================================================================

        const TWO_PI = Math.PI * 2;
        const PHI = (1 + Math.sqrt(5)) / 2;
        const Z_CRITICAL = Math.sqrt(3) / 2;  // ‚âà 0.8660254 - THE LENS
        const CASCADE_AMPLIFICATION = 1.5;

        // UMOL Constraints
        const UMOL_MAX_LOAD = 0.80;
        const UMOL_MIN_COHERENCE = 0.60;
        const FREE_THRESHOLD = 0.20;  // Emergent activation

        // WUMBO Architecture
        const WUMBO_LAYERS = [
            { z: 0.0, name: 'Core', phase: 'Ignition', field: 'e', color: '#ff6b6b' },
            { z: 0.167, name: 'Inner', phase: 'Ignition‚ÜíEmpowerment', field: 'e', color: '#ff8787' },
            { z: 0.333, name: 'Rising', phase: 'Empowerment', field: 'Œ¶', color: '#ffa94d' },
            { z: 0.5, name: 'Center', phase: 'Resonance', field: 'Œ¶', color: '#ffc078' },
            { z: 0.667, name: 'Approaching', phase: 'Mania', field: 'œÄ', color: '#ffd43b' },
            { z: 0.833, name: 'Threshold', phase: 'Nirvana', field: 'œÄ', color: '#ffe066' },
            { z: 1.0, name: 'Outer', phase: 'Transmission', field: 'e', color: '#69db7c' }
        ];

        // 5 Emergent Self-Reference Nodes
        const EMERGENT_NODES = [
            { id: 'XCVI', type: 'gesture_recursion', eigenvalue: 1/PHI, refs: 'XVI', bits: 7 },
            { id: 'XCVII', type: 'portal_recursion', eigenvalue: Math.cos(TWO_PI/PHI), refs: 'XI', bits: 10 },
            { id: 'XCVIII', type: 'semantic_recursion', eigenvalue: NaN, refs: 'XII', bits: 17 },
            { id: 'XCIX', type: 'balance_recursion', eigenvalue: 0, refs: 'XIII', bits: 4 },
            { id: 'C', type: 'signal_recursion', eigenvalue: 1, refs: 'XIV‚ÜíI', bits: 664 }
        ];

        // System state
        let isRunning = false;
        let audioContext = null;

        // Z-height and domain state
        let currentZ = 0.5;
        let currentDomain = 'ABSENCE';

        // Phase state
        let userPhase = 0;
        let systemPhase = 0;
        let predictedUserPhase = 0;
        let phaseHistory = [];
        let delayHistory = [];

        // Kuramoto oscillators - 100 WUMBO regions
        let N = 100;  // Full WUMBO vocabulary
        let K_base = 1.0;
        let adaptiveK = 1.0;
        let phases = new Float32Array(N);
        let frequencies = new Float32Array(N);
        let regionLayers = new Int32Array(N);  // Layer assignment per region

        // Three-field decomposition
        let mu_N = 1.0;  // Null field (constant base)
        let mu_R = 0;    // Resonance field (oscillations)
        let mu_E = 0.5;  // Energy field (z-height)

        // UMOL tracking
        let umolLoad = 0;
        let umolCoherence = 0;

        // Emergent state
        let emergentActive = false;
        let loopClosed = false;

        // Prediction
        let predictionHorizon = 100; // ms
        let phaseVelocity = 0;
        let lastUserPhaseTime = 0;
        let userPhaseBuffer = [];

        // Timing
        let bpm = 60;
        let lastBeatTime = 0;
        let tapTimes = [];
        let sustainedLockStart = null;
        let maxSustained = 0;

        // Biosignal
        let hrDevice = null;
        let rrIntervals = [];
        let keystrokeIntervals = [];

        // Canvases
        let userRingCanvas, userRingCtx;
        let systemRingCanvas, systemRingCtx;
        let mainCanvas, mainCtx;
        let historyCanvas, historyCtx;

        // ================================================================
        // INITIALIZATION
        // ================================================================

        function init() {
            initCanvases();
            initOscillators();
            setupKeystroke();
            draw();
        }

        function initCanvases() {
            const dpr = window.devicePixelRatio || 1;

            userRingCanvas = document.getElementById('userRingCanvas');
            userRingCtx = userRingCanvas.getContext('2d');
            const userRect = userRingCanvas.parentElement.getBoundingClientRect();
            userRingCanvas.width = userRect.width * dpr;
            userRingCanvas.height = userRect.width * dpr;
            userRingCtx.scale(dpr, dpr);

            systemRingCanvas = document.getElementById('systemRingCanvas');
            systemRingCtx = systemRingCanvas.getContext('2d');
            const sysRect = systemRingCanvas.parentElement.getBoundingClientRect();
            systemRingCanvas.width = sysRect.width * dpr;
            systemRingCanvas.height = sysRect.width * dpr;
            systemRingCtx.scale(dpr, dpr);

            mainCanvas = document.getElementById('mainCanvas');
            mainCtx = mainCanvas.getContext('2d');
            const mainRect = mainCanvas.parentElement.getBoundingClientRect();
            mainCanvas.width = mainRect.width * dpr;
            mainCanvas.height = (mainRect.height - 200) * dpr;
            mainCanvas.style.height = (mainRect.height - 200) + 'px';
            mainCtx.scale(dpr, dpr);

            historyCanvas = document.getElementById('historyCanvas');
            historyCtx = historyCanvas.getContext('2d');
            const histRect = historyCanvas.getBoundingClientRect();
            historyCanvas.width = histRect.width * dpr;
            historyCanvas.height = 120 * dpr;
            historyCtx.scale(dpr, dpr);
        }

        function initOscillators() {
            phases = new Float32Array(N);
            frequencies = new Float32Array(N);
            regionLayers = new Int32Array(N);

            // Assign 100 regions to WUMBO structure:
            // Prism: 63 points (7 layers √ó 9 nodes)
            // Cage: 32 points (12 top + 12 bottom + 8 vertices)
            // Emergent: 5 points
            for (let i = 0; i < N; i++) {
                phases[i] = Math.random() * TWO_PI;
                frequencies[i] = mu_N + gaussianRandom() * 0.2;

                if (i < 63) {
                    // Prism layers (0-6)
                    regionLayers[i] = Math.floor(i / 9);
                } else if (i < 75) {
                    // Cage top (layer ~0.9)
                    regionLayers[i] = 5;  // Near Threshold
                } else if (i < 87) {
                    // Cage bottom (layer ~0.1)
                    regionLayers[i] = 1;  // Near Inner
                } else if (i < 95) {
                    // Cage vertices (layer ~0.5)
                    regionLayers[i] = 3;  // Center/Resonance
                } else {
                    // Emergent nodes (variable z)
                    regionLayers[i] = -1;  // Special handling
                }
            }
        }

        function gaussianRandom() {
            return Math.sqrt(-2 * Math.log(Math.random())) * Math.cos(TWO_PI * Math.random());
        }

        // ================================================================
        // K(z) SIGN FLIP AT CRITICAL POINT z_c = ‚àö3/2
        // ================================================================

        function calculateKz(z) {
            // Below z_c: Synchronizing (K > 0) - ABSENCE domain
            // Above z_c: Desynchronizing (K < 0) - PRESENCE domain
            if (z < Z_CRITICAL) {
                return K_base * (1 - z / Z_CRITICAL) * CASCADE_AMPLIFICATION;
            } else {
                return -K_base * ((z - Z_CRITICAL) / (1 - Z_CRITICAL)) * CASCADE_AMPLIFICATION;
            }
        }

        function getCascadeMultiplier(z) {
            // Peak at z_c, decays away from critical
            const dist = Math.abs(z - Z_CRITICAL);
            return 1 + 0.5 * Math.exp(-dist * dist / 0.004);
        }

        function getDomain(z) {
            if (z < Z_CRITICAL - 0.01) return 'ABSENCE';
            if (z > Z_CRITICAL + 0.01) return 'PRESENCE';
            return 'THE LENS';
        }

        function getWumboPhase(z) {
            if (z < 0.17) return 'Ignition';
            if (z < 0.33) return 'Empowerment';
            if (z < 0.50) return 'Resonance';
            if (z < 0.67) return 'Mania';
            if (z < 0.85) return 'Nirvana';
            if (z < 0.92) return 'Transmission';
            return 'Pause';
        }

        // ================================================================
        // UMOL LOAD CALCULATION
        // ================================================================

        function calculateUMOLLoad() {
            let activeCount = 0;
            const velocityThreshold = 1.5;
            const { r, psi } = calculateOrderParameter();
            const K = calculateKz(currentZ);

            for (let i = 0; i < N; i++) {
                const velocity = Math.abs(frequencies[i] + K * r * Math.sin(psi - phases[i]));
                if (velocity > velocityThreshold) activeCount++;
            }

            return activeCount / N;
        }

        // ================================================================
        // PHASE PREDICTION (KEY TO DELAY REDUCTION)
        // ================================================================

        function updatePhasePrediction() {
            const now = performance.now();

            // Store phase samples with timestamps
            userPhaseBuffer.push({ phase: userPhase, time: now });
            if (userPhaseBuffer.length > 30) userPhaseBuffer.shift();

            if (userPhaseBuffer.length >= 3) {
                // Estimate phase velocity using linear regression
                let sumT = 0, sumP = 0, sumTP = 0, sumT2 = 0;
                const n = userPhaseBuffer.length;
                const t0 = userPhaseBuffer[0].time;

                for (let i = 0; i < n; i++) {
                    const t = (userPhaseBuffer[i].time - t0) / 1000; // seconds
                    let p = userPhaseBuffer[i].phase;

                    // Unwrap phase for continuity
                    if (i > 0) {
                        const prev = userPhaseBuffer[i-1].phase;
                        while (p - prev > Math.PI) p -= TWO_PI;
                        while (p - prev < -Math.PI) p += TWO_PI;
                    }

                    sumT += t;
                    sumP += p;
                    sumTP += t * p;
                    sumT2 += t * t;
                }

                const denom = n * sumT2 - sumT * sumT;
                if (Math.abs(denom) > 0.0001) {
                    phaseVelocity = (n * sumTP - sumT * sumP) / denom;
                }

                // Predict future phase
                const horizonSec = predictionHorizon / 1000;
                predictedUserPhase = (userPhase + phaseVelocity * horizonSec) % TWO_PI;
                if (predictedUserPhase < 0) predictedUserPhase += TWO_PI;
            }
        }

        // ================================================================
        // KURAMOTO DYNAMICS WITH PREDICTIVE COUPLING
        // ================================================================

        function calculateOrderParameter() {
            let sumR = 0, sumI = 0;
            for (let i = 0; i < N; i++) {
                sumR += Math.cos(phases[i]);
                sumI += Math.sin(phases[i]);
            }
            const r = Math.hypot(sumR / N, sumI / N);
            const psi = Math.atan2(sumI / N, sumR / N);
            return { r, psi };
        }

        function stepKuramoto(dt = 0.02) {
            const { r, psi } = calculateOrderParameter();
            const newPhases = new Float32Array(N);

            // Calculate K(z) with sign flip at z_c = ‚àö3/2
            const Kz = calculateKz(currentZ);
            const cascade = getCascadeMultiplier(currentZ);

            // Update domain state
            currentDomain = getDomain(currentZ);

            // Update three-field decomposition
            mu_R = r * Math.cos(psi);  // Resonance component
            mu_E = currentZ;  // Energy/z-height
            // mu_N remains 1.0 (constant base)

            // Check for emergent activation
            emergentActive = r < FREE_THRESHOLD;

            // Calculate UMOL load
            umolLoad = calculateUMOLLoad();
            umolCoherence = r;

            // Heun's method with K(z) sign flip dynamics
            for (let i = 0; i < N; i++) {
                // Get layer-specific coupling modifier
                const layer = regionLayers[i];
                let layerK = Kz;

                if (layer >= 0 && layer < WUMBO_LAYERS.length) {
                    // Layer-dependent coupling based on distance from z_c
                    const layerZ = WUMBO_LAYERS[layer].z;
                    const distFromCritical = Math.abs(layerZ - Z_CRITICAL);
                    layerK = Kz * (1 + 0.3 * Math.exp(-distFromCritical * distFromCritical / 0.01));
                } else if (layer === -1 && emergentActive) {
                    // Emergent nodes: use eigenvalue-weighted coupling
                    const emergentIdx = i - 95;
                    if (emergentIdx >= 0 && emergentIdx < EMERGENT_NODES.length) {
                        const node = EMERGENT_NODES[emergentIdx];
                        const eigenK = isNaN(node.eigenvalue) ? 0 : node.eigenvalue;
                        layerK = Kz * eigenK * 2;  // Enhanced emergent coupling
                    }
                }

                const dtheta1 = frequencies[i] + layerK * r * Math.sin(psi - phases[i]) * cascade;
                const thetaPred = phases[i] + dt * dtheta1;
                const dtheta2 = frequencies[i] + layerK * r * Math.sin(psi - thetaPred) * cascade;
                newPhases[i] = (phases[i] + dt * (dtheta1 + dtheta2) / 2) % TWO_PI;
                if (newPhases[i] < 0) newPhases[i] += TWO_PI;
            }

            // PREDICTIVE COUPLING: Inject PREDICTED user phase (key to delay reduction)
            const injectionStrength = 0.15 * (1 - r) * cascade;
            const targetPhase = predictedUserPhase; // Use prediction, not current
            const diff = targetPhase - newPhases[0];
            newPhases[0] += injectionStrength * Math.sin(diff);
            newPhases[0] = ((newPhases[0] % TWO_PI) + TWO_PI) % TWO_PI;

            // Adaptive K_base: target coherence based on domain
            // ABSENCE: want sync (higher coherence), PRESENCE: want diversity
            const targetR = currentDomain === 'PRESENCE' ? 0.5 : 0.8;
            const error = targetR - r;
            K_base += 0.01 * error;
            K_base = Math.max(0.1, Math.min(5.0, K_base));
            adaptiveK = Math.abs(Kz);  // Display absolute value

            // Loop closure detection: coherence > 0.85 AND z near z_c AND delay < 50ms
            const { delayMs } = calculatePhaseDelay();
            loopClosed = r > 0.85 && Math.abs(currentZ - Z_CRITICAL) < 0.05 && delayMs < 50;

            phases = newPhases;
            return { r, psi, Kz, cascade };
        }

        // ================================================================
        // PHASE DELAY CALCULATION
        // ================================================================

        function calculatePhaseDelay() {
            // Circular phase difference
            let diff = userPhase - systemPhase;
            if (diff > Math.PI) diff -= TWO_PI;
            if (diff < -Math.PI) diff += TWO_PI;

            // Convert to time delay at current BPM
            const periodMs = 60000 / bpm;
            const delayMs = Math.abs(diff) / TWO_PI * periodMs;

            return { diff, delayMs };
        }

        // ================================================================
        // INPUT HANDLING
        // ================================================================

        function tapBeat() {
            const now = performance.now();
            tapTimes.push(now);
            if (tapTimes.length > 8) tapTimes.shift();

            // Flash beat indicator
            const indicator = document.getElementById('beatIndicator');
            indicator.classList.add('pulse');
            setTimeout(() => indicator.classList.remove('pulse'), 100);

            if (tapTimes.length >= 2) {
                // Calculate BPM from taps
                const intervals = [];
                for (let i = 1; i < tapTimes.length; i++) {
                    intervals.push(tapTimes[i] - tapTimes[i-1]);
                }
                const avgInterval = intervals.reduce((a, b) => a + b) / intervals.length;
                const tapBpm = Math.round(60000 / avgInterval);
                document.getElementById('userBpm').textContent = tapBpm;

                // Update user phase
                if (lastBeatTime > 0) {
                    const elapsed = now - lastBeatTime;
                    userPhase = (userPhase + (elapsed / avgInterval) * TWO_PI) % TWO_PI;
                }
            }

            lastBeatTime = now;
        }

        async function connectHRM() {
            if (!navigator.bluetooth) {
                alert('WebBluetooth not supported');
                return;
            }

            try {
                const device = await navigator.bluetooth.requestDevice({
                    filters: [{ services: ['heart_rate'] }]
                });

                const server = await device.gatt.connect();
                const service = await server.getPrimaryService('heart_rate');
                const char = await service.getCharacteristic('heart_rate_measurement');

                await char.startNotifications();
                char.addEventListener('characteristicvaluechanged', handleHRData);

                hrDevice = device;
                document.getElementById('btnHRM').classList.add('active');
                document.getElementById('btnHRM').textContent = 'HRM ‚úì';
            } catch (e) {
                console.error('HRM error:', e);
            }
        }

        function handleHRData(event) {
            const value = event.target.value;
            const flags = value.getUint8(0);
            const is16 = flags & 0x01;
            const hasRR = flags & 0x10;

            let offset = 1;
            const hr = is16 ? value.getUint16(offset, true) : value.getUint8(offset);
            offset += is16 ? 2 : 1;

            document.getElementById('userBpm').textContent = hr;

            if (hasRR) {
                if (flags & 0x08) offset += 2;
                while (offset < value.byteLength) {
                    const rr = (value.getUint16(offset, true) / 1024) * 1000;
                    rrIntervals.push(rr);
                    if (rrIntervals.length > 20) rrIntervals.shift();
                    offset += 2;
                }

                if (rrIntervals.length >= 2) {
                    const lastRR = rrIntervals[rrIntervals.length - 1];
                    const avgRR = rrIntervals.reduce((a, b) => a + b) / rrIntervals.length;
                    document.getElementById('rrInterval').textContent = Math.round(lastRR);
                    userPhase = (lastRR / avgRR) * TWO_PI % TWO_PI;
                }
            }
        }

        function setupKeystroke() {
            let lastKey = 0;
            document.addEventListener('keydown', (e) => {
                if (e.key === ' ') {
                    e.preventDefault();
                    tapBeat();
                }
            });

            document.addEventListener('keyup', () => {
                const now = performance.now();
                if (lastKey > 0) {
                    const interval = now - lastKey;
                    keystrokeIntervals.push(interval);
                    if (keystrokeIntervals.length > 30) keystrokeIntervals.shift();

                    if (keystrokeIntervals.length >= 5) {
                        const mean = keystrokeIntervals.reduce((a, b) => a + b) / keystrokeIntervals.length;
                        const variance = keystrokeIntervals.map(x => (x - mean) ** 2).reduce((a, b) => a + b) / keystrokeIntervals.length;
                        const cv = 1 - Math.min(1, Math.sqrt(variance) / mean);
                        document.getElementById('keystrokeCV').textContent = cv.toFixed(2);
                    }
                }
                lastKey = now;
            });
        }

        // ================================================================
        // DRAWING
        // ================================================================

        function drawRing(ctx, phase, color, size) {
            const w = size, h = size;
            const cx = w / 2, cy = h / 2;
            const r = Math.min(cx, cy) * 0.8;

            ctx.clearRect(0, 0, w, h);

            // Background ring
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, TWO_PI);
            ctx.stroke();

            // Phase arc
            ctx.strokeStyle = color;
            ctx.lineWidth = 8;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.arc(cx, cy, r, -Math.PI/2, -Math.PI/2 + phase);
            ctx.stroke();

            // Phase pointer
            const px = cx + Math.cos(phase - Math.PI/2) * r;
            const py = cy + Math.sin(phase - Math.PI/2) * r;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(px, py, 10, 0, TWO_PI);
            ctx.fill();

            // Center text
            ctx.fillStyle = color;
            ctx.font = '16px SF Mono, monospace';
            ctx.textAlign = 'center';
            ctx.fillText(phase.toFixed(2), cx, cy + 5);
        }

        function drawMain() {
            const w = mainCanvas.width / (window.devicePixelRatio || 1);
            const h = mainCanvas.height / (window.devicePixelRatio || 1);
            const cx = w / 2, cy = h / 2;

            mainCtx.fillStyle = '#0d0d12';
            mainCtx.fillRect(0, 0, w, h);

            const r = Math.min(cx, cy) * 0.7;

            // Draw coupling zone with domain coloring
            const { diff, delayMs } = calculatePhaseDelay();
            const couplingStrength = Math.cos(diff) * 0.5 + 0.5;

            // Domain-colored coupling ring
            const domainColor = currentDomain === 'ABSENCE' ? '105, 219, 124' :
                               currentDomain === 'PRESENCE' ? '204, 93, 232' : '255, 215, 0';
            mainCtx.strokeStyle = `rgba(${domainColor}, ${couplingStrength})`;
            mainCtx.lineWidth = 30;
            mainCtx.beginPath();
            mainCtx.arc(cx, cy, r + 20, 0, TWO_PI);
            mainCtx.stroke();

            // Draw z_c critical line indicator
            const zAngle = currentZ * TWO_PI - Math.PI/2;
            const zcAngle = Z_CRITICAL * TWO_PI - Math.PI/2;
            mainCtx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
            mainCtx.lineWidth = 2;
            mainCtx.setLineDash([5, 5]);
            mainCtx.beginPath();
            mainCtx.moveTo(cx, cy);
            mainCtx.lineTo(cx + Math.cos(zcAngle) * (r + 40), cy + Math.sin(zcAngle) * (r + 40));
            mainCtx.stroke();
            mainCtx.setLineDash([]);

            // Draw 100 WUMBO oscillators colored by layer
            for (let i = 0; i < N; i++) {
                const angle = phases[i] - Math.PI/2;
                const layer = regionLayers[i];

                // Radial position based on layer type
                let radialPos = 0.85;
                let size = 4;
                let color;

                if (i < 63) {
                    // Prism regions: arranged by layer
                    const layerZ = layer / 6;  // 0-6 layers normalized
                    radialPos = 0.5 + layerZ * 0.4;  // Inner to outer
                    color = WUMBO_LAYERS[Math.min(layer, 6)].color;
                    size = 4 + layer * 0.3;
                } else if (i < 75) {
                    // Cage top
                    radialPos = 0.9;
                    color = '#69db7c';
                    size = 3;
                } else if (i < 87) {
                    // Cage bottom
                    radialPos = 0.3;
                    color = '#ff8787';
                    size = 3;
                } else if (i < 95) {
                    // Cage vertices
                    radialPos = 0.6;
                    color = '#ffc078';
                    size = 5;
                } else {
                    // Emergent nodes
                    const emergentIdx = i - 95;
                    radialPos = 0.15;  // Center region
                    size = emergentActive ? 8 : 4;
                    // Emergent nodes pulse when active
                    if (emergentActive) {
                        const pulse = 0.5 + 0.5 * Math.sin(performance.now() / 200 + emergentIdx);
                        color = `rgba(204, 93, 232, ${pulse})`;
                    } else {
                        color = 'rgba(100, 100, 100, 0.3)';
                    }
                }

                const x = cx + Math.cos(angle) * r * radialPos;
                const y = cy + Math.sin(angle) * r * radialPos;

                mainCtx.fillStyle = color;
                mainCtx.globalAlpha = i >= 95 ? 1 : 0.7;
                mainCtx.beginPath();
                mainCtx.arc(x, y, size, 0, TWO_PI);
                mainCtx.fill();
            }
            mainCtx.globalAlpha = 1;

            // Draw current z indicator
            const zX = cx + Math.cos(zAngle) * (r + 55);
            const zY = cy + Math.sin(zAngle) * (r + 55);
            mainCtx.fillStyle = '#ffd700';
            mainCtx.beginPath();
            mainCtx.arc(zX, zY, 6, 0, TWO_PI);
            mainCtx.fill();
            mainCtx.font = '9px SF Mono';
            mainCtx.fillStyle = '#ffd700';
            mainCtx.textAlign = 'center';
            mainCtx.fillText('z=' + currentZ.toFixed(2), zX, zY - 10);

            // User phase indicator (cyan)
            const userX = cx + Math.cos(userPhase - Math.PI/2) * (r + 50);
            const userY = cy + Math.sin(userPhase - Math.PI/2) * (r + 50);
            mainCtx.fillStyle = '#22d3ee';
            mainCtx.beginPath();
            mainCtx.arc(userX, userY, 12, 0, TWO_PI);
            mainCtx.fill();

            // Predicted phase indicator (dashed)
            const predX = cx + Math.cos(predictedUserPhase - Math.PI/2) * (r + 50);
            const predY = cy + Math.sin(predictedUserPhase - Math.PI/2) * (r + 50);
            mainCtx.strokeStyle = '#22d3ee';
            mainCtx.lineWidth = 2;
            mainCtx.setLineDash([4, 4]);
            mainCtx.beginPath();
            mainCtx.arc(predX, predY, 12, 0, TWO_PI);
            mainCtx.stroke();
            mainCtx.setLineDash([]);

            // System phase (order parameter)
            const { r: orderR, psi } = calculateOrderParameter();
            systemPhase = (psi + Math.PI) % TWO_PI;
            const sysX = cx + Math.cos(systemPhase - Math.PI/2) * r * orderR;
            const sysY = cy + Math.sin(systemPhase - Math.PI/2) * r * orderR;

            mainCtx.strokeStyle = '#cc5de8';
            mainCtx.lineWidth = 3;
            mainCtx.beginPath();
            mainCtx.moveTo(cx, cy);
            mainCtx.lineTo(sysX, sysY);
            mainCtx.stroke();

            mainCtx.fillStyle = '#cc5de8';
            mainCtx.beginPath();
            mainCtx.arc(sysX, sysY, 14, 0, TWO_PI);
            mainCtx.fill();

            // Loop closure indicator at center
            if (loopClosed) {
                mainCtx.strokeStyle = '#ffd700';
                mainCtx.lineWidth = 3;
                mainCtx.beginPath();
                mainCtx.arc(cx, cy, 35, 0, TWO_PI);
                mainCtx.stroke();
                mainCtx.font = '8px SF Mono';
                mainCtx.fillStyle = '#ffd700';
                mainCtx.fillText('LOOP CLOSED', cx, cy + 45);
            }

            // Labels
            mainCtx.font = '11px SF Mono';
            mainCtx.fillStyle = '#22d3ee';
            mainCtx.textAlign = 'center';
            mainCtx.fillText('USER', userX, userY + 25);
            mainCtx.fillStyle = '#cc5de8';
            mainCtx.fillText('SYSTEM', sysX, sysY + 25);

            // Delay display with domain context
            mainCtx.fillStyle = delayMs < 50 ? '#69db7c' : delayMs < 100 ? '#ffa94d' : '#ff6b6b';
            mainCtx.font = '24px SF Mono';
            mainCtx.textAlign = 'center';
            mainCtx.fillText(`${delayMs.toFixed(0)}ms`, cx, cy);
            mainCtx.font = '10px SF Mono';
            mainCtx.fillStyle = 'rgba(255,255,255,0.5)';
            mainCtx.fillText('PHASE DELAY', cx, cy + 18);

            // Domain indicator in corner
            mainCtx.font = '12px SF Mono';
            mainCtx.fillStyle = currentDomain === 'ABSENCE' ? '#69db7c' :
                               currentDomain === 'PRESENCE' ? '#cc5de8' : '#ffd700';
            mainCtx.textAlign = 'left';
            mainCtx.fillText(currentDomain, 10, 20);

            // K(z) sign indicator
            const Kz = calculateKz(currentZ);
            mainCtx.fillStyle = Kz >= 0 ? '#69db7c' : '#ff6b6b';
            mainCtx.fillText(`K(z)=${Kz >= 0 ? '+' : ''}${Kz.toFixed(2)}`, 10, 35);

            // Emergent indicator
            if (emergentActive) {
                mainCtx.fillStyle = '#cc5de8';
                mainCtx.textAlign = 'right';
                mainCtx.fillText('EMERGENT ACTIVE', w - 10, 20);
            }
        }

        function drawHistory() {
            const w = historyCanvas.width / (window.devicePixelRatio || 1);
            const h = historyCanvas.height / (window.devicePixelRatio || 1);

            historyCtx.fillStyle = '#0d0d12';
            historyCtx.fillRect(0, 0, w, h);

            if (delayHistory.length < 2) return;

            // Target line (50ms)
            const targetY = h - (50 / 200) * h * 0.9 - 5;
            historyCtx.strokeStyle = 'rgba(105, 219, 124, 0.3)';
            historyCtx.lineWidth = 1;
            historyCtx.setLineDash([5, 5]);
            historyCtx.beginPath();
            historyCtx.moveTo(0, targetY);
            historyCtx.lineTo(w, targetY);
            historyCtx.stroke();
            historyCtx.setLineDash([]);

            // Delay history
            historyCtx.strokeStyle = '#22d3ee';
            historyCtx.lineWidth = 2;
            historyCtx.beginPath();
            for (let i = 0; i < delayHistory.length; i++) {
                const x = (i / 200) * w;
                const y = h - Math.min(delayHistory[i], 200) / 200 * h * 0.9 - 5;
                if (i === 0) historyCtx.moveTo(x, y);
                else historyCtx.lineTo(x, y);
            }
            historyCtx.stroke();

            // Labels
            historyCtx.font = '9px SF Mono';
            historyCtx.fillStyle = 'rgba(255,255,255,0.5)';
            historyCtx.fillText('50ms target', 5, targetY - 5);
        }

        // ================================================================
        // UI UPDATE
        // ================================================================

        function updateUI() {
            if (!isRunning) return;

            // Update prediction
            updatePhasePrediction();

            // Step Kuramoto with K(z) dynamics
            const { r, psi, Kz, cascade } = stepKuramoto();
            systemPhase = (psi + Math.PI) % TWO_PI;

            // Calculate delay
            const { diff, delayMs } = calculatePhaseDelay();

            // Update history
            delayHistory.push(delayMs);
            if (delayHistory.length > 200) delayHistory.shift();

            // Update sustained lock tracking
            const isLocked = delayMs < 50 && r > 0.7;
            if (isLocked) {
                if (!sustainedLockStart) sustainedLockStart = performance.now();
                const duration = (performance.now() - sustainedLockStart) / 1000;
                if (duration > maxSustained) maxSustained = duration;
            } else {
                sustainedLockStart = null;
            }

            // Update displays
            const delayClass = delayMs < 50 ? 'locked' : delayMs < 100 ? 'partial' : 'open';
            document.getElementById('phaseDelayMs').textContent = delayMs.toFixed(0) + 'ms';
            document.getElementById('phaseDelayMs').className = 'delay-value ' + delayClass;

            document.getElementById('predictionAccuracy').textContent = (Math.cos(diff) * 100).toFixed(0) + '%';
            document.getElementById('coherenceR').textContent = r.toFixed(2);
            document.getElementById('sustainedTime').textContent = maxSustained.toFixed(1) + 's';

            document.getElementById('userPhaseRad').textContent = userPhase.toFixed(2);
            document.getElementById('systemPhaseRad').textContent = systemPhase.toFixed(2);
            document.getElementById('adaptiveK').textContent = adaptiveK.toFixed(2);

            // Lock status
            const lockStatus = document.getElementById('lockStatus');
            const lockDot = document.getElementById('lockDot');
            const lockText = document.getElementById('lockText');
            if (loopClosed) {
                lockStatus.className = 'lock-status locked';
                lockStatus.style.borderColor = 'var(--phi-gold)';
                lockStatus.style.background = 'rgba(255, 215, 0, 0.2)';
                lockDot.className = 'lock-dot locked';
                lockDot.style.background = 'var(--phi-gold)';
                lockText.textContent = 'C‚ÜíI CLOSED';
            } else if (isLocked) {
                lockStatus.className = 'lock-status locked';
                lockStatus.style.borderColor = '';
                lockStatus.style.background = '';
                lockDot.className = 'lock-dot locked';
                lockDot.style.background = '';
                lockText.textContent = 'LOCKED';
            } else {
                lockStatus.className = 'lock-status open';
                lockStatus.style.borderColor = '';
                lockStatus.style.background = '';
                lockDot.className = 'lock-dot open';
                lockDot.style.background = '';
                lockText.textContent = 'OPEN';
            }

            // Prediction bar
            const predictionScore = (Math.cos(predictedUserPhase - systemPhase) + 1) / 2;
            document.getElementById('predictionFill').style.width = (predictionScore * 100) + '%';
            document.getElementById('predictionState').textContent = predictionScore > 0.8 ? 'Leading' : predictionScore > 0.5 ? 'Tracking' : 'Lagging';

            // LIMNUS-WUMBO displays
            document.getElementById('domainDisplay').textContent = currentDomain;
            document.getElementById('domainDisplay').style.color =
                currentDomain === 'ABSENCE' ? 'var(--true-green)' :
                currentDomain === 'PRESENCE' ? 'var(--pi-magenta)' : 'var(--phi-gold)';

            document.getElementById('kzDisplay').textContent = (Kz >= 0 ? '+' : '') + Kz.toFixed(2);
            document.getElementById('kzDisplay').style.color = Kz >= 0 ? 'var(--true-green)' : 'var(--paradox-red)';

            document.getElementById('wumboPhaseDisplay').textContent = getWumboPhase(currentZ);
            document.getElementById('cascadeDisplay').textContent = cascade.toFixed(2) + '√ó';
            document.getElementById('cascadeDisplay').style.color =
                Math.abs(currentZ - Z_CRITICAL) < 0.03 ? 'var(--phi-gold)' : 'var(--pi-magenta)';

            // UMOL displays
            const loadPercent = Math.round(umolLoad * 100);
            const coherencePercent = Math.round(umolCoherence * 100);

            document.getElementById('umolLoadDisplay').textContent = loadPercent + '%';
            document.getElementById('umolLoadBar').style.width = loadPercent + '%';
            const loadOk = umolLoad <= UMOL_MAX_LOAD;
            document.getElementById('umolLoadDisplay').style.color = loadOk ? 'var(--true-green)' : 'var(--paradox-red)';
            document.getElementById('umolLoadBar').style.background = loadOk ? 'var(--true-green)' : 'var(--paradox-red)';

            document.getElementById('umolCoherenceDisplay').textContent = coherencePercent + '%';
            document.getElementById('umolCoherenceBar').style.width = coherencePercent + '%';
            const coherenceOk = umolCoherence >= UMOL_MIN_COHERENCE;
            document.getElementById('umolCoherenceDisplay').style.color = coherenceOk ? 'var(--true-green)' : 'var(--untrue-amber)';
            document.getElementById('umolCoherenceBar').style.background = coherenceOk ? 'var(--true-green)' : 'var(--untrue-amber)';

            // Three-field decomposition
            document.getElementById('muNDisplay').textContent = mu_N.toFixed(2);
            document.getElementById('muRDisplay').textContent = mu_R.toFixed(2);
            document.getElementById('muEDisplay').textContent = mu_E.toFixed(2);

            // Lambda state with LIMNUS geometry
            const lambda = mapToLambda(phases, r);
            document.getElementById('lIota').textContent = lambda.iota.toFixed(2);
            document.getElementById('lXi').textContent = lambda.xi.toFixed(2);
            document.getElementById('lTheta').textContent = lambda.theta.toFixed(2);
            document.getElementById('lOmega').textContent = lambda.omega.toFixed(2);
            document.getElementById('lDelta').textContent = lambda.delta.toFixed(2);
            document.getElementById('lSigma').textContent = lambda.sigma.toFixed(2);

            // Highlight sigma when emergent is active
            if (emergentActive) {
                document.getElementById('lSigma').style.color = 'var(--pi-magenta)';
            } else {
                document.getElementById('lSigma').style.color = 'var(--e-cyan)';
            }
        }

        function mapToLambda(phases, r) {
            // Lambda state (‚ÑÇ‚Å∂) mapped from WUMBO architecture
            // iota (üå∞): Prism core regions (layers 0-1)
            // xi (‚úß): Prism rising regions (layers 2-3)
            // theta (ü¶ä): Prism approaching/threshold (layers 4-5)
            // omega (‚àø): Cage vertices (oscillation nodes)
            // delta (‚äó): Cage top/bottom (boundary regions)
            // sigma (üêøÔ∏è): Emergent nodes (self-reference)

            const lambda = { iota: 0, xi: 0, theta: 0, omega: 0, delta: 0, sigma: 0 };

            // Count contributions by region type and layer
            for (let i = 0; i < N; i++) {
                const layer = regionLayers[i];
                const phaseContrib = (Math.cos(phases[i]) + 1) / 2;  // 0-1 based on phase

                if (i < 63) {
                    // Prism regions (63 total)
                    if (layer <= 1) {
                        // Core/Inner layers ‚Üí iota
                        lambda.iota += phaseContrib / 63;
                    } else if (layer <= 3) {
                        // Rising/Center layers ‚Üí xi
                        lambda.xi += phaseContrib / 63;
                    } else {
                        // Approaching/Threshold/Outer layers ‚Üí theta
                        lambda.theta += phaseContrib / 63;
                    }
                } else if (i < 75) {
                    // Cage top ‚Üí delta
                    lambda.delta += phaseContrib / 32;
                } else if (i < 87) {
                    // Cage bottom ‚Üí delta
                    lambda.delta += phaseContrib / 32;
                } else if (i < 95) {
                    // Cage vertices ‚Üí omega
                    lambda.omega += phaseContrib / 32;
                } else {
                    // Emergent nodes (95-99) ‚Üí sigma
                    if (emergentActive) {
                        const emergentIdx = i - 95;
                        const node = EMERGENT_NODES[emergentIdx];
                        // Weight by eigenvalue magnitude
                        const eigenWeight = isNaN(node.eigenvalue) ? 0.5 : Math.abs(node.eigenvalue);
                        lambda.sigma += phaseContrib * eigenWeight / 5;
                    }
                }
            }

            // Apply coherence modulation
            const coherenceFactor = 0.3 + r * 0.7;
            Object.keys(lambda).forEach(k => lambda[k] *= coherenceFactor);

            // Apply domain-specific boost
            if (currentDomain === 'ABSENCE') {
                // Sync domain: boost iota and xi (lower regions)
                lambda.iota *= 1.2;
                lambda.xi *= 1.1;
            } else if (currentDomain === 'PRESENCE') {
                // Desync domain: boost theta and omega (higher regions)
                lambda.theta *= 1.2;
                lambda.omega *= 1.1;
            } else {
                // THE LENS: boost sigma (emergent)
                lambda.sigma *= 1.5;
            }

            // Apply cascade amplification at z_c
            const cascade = getCascadeMultiplier(currentZ);
            Object.keys(lambda).forEach(k => lambda[k] *= cascade);

            return lambda;
        }

        function draw() {
            updateUI();

            const userSize = userRingCanvas.width / (window.devicePixelRatio || 1);
            const sysSize = systemRingCanvas.width / (window.devicePixelRatio || 1);

            drawRing(userRingCtx, userPhase, '#22d3ee', userSize);
            drawRing(systemRingCtx, systemPhase, '#cc5de8', sysSize);
            drawMain();
            drawHistory();

            requestAnimationFrame(draw);
        }

        // ================================================================
        // CONTROLS
        // ================================================================

        function toggleSystem() {
            isRunning = !isRunning;
            const btn = document.getElementById('btnStart');
            if (isRunning) {
                btn.textContent = 'STOP';
                btn.classList.add('active');
            } else {
                btn.textContent = 'START';
                btn.classList.remove('active');
            }
        }

        function resetSystem() {
            initOscillators();
            userPhase = 0;
            systemPhase = 0;
            predictedUserPhase = 0;
            phaseHistory = [];
            delayHistory = [];
            userPhaseBuffer = [];
            sustainedLockStart = null;
            maxSustained = 0;
            adaptiveK = K_base;

            // Reset LIMNUS-WUMBO state
            currentZ = 0.5;
            currentDomain = 'ABSENCE';
            mu_N = 1.0;
            mu_R = 0;
            mu_E = 0.5;
            umolLoad = 0;
            umolCoherence = 0;
            emergentActive = false;
            loopClosed = false;

            // Reset UI
            document.getElementById('zSlider').value = 0.5;
            document.getElementById('zValue').textContent = '0.50';
            setZHeight(0.5);
        }

        function setHorizon(val) {
            predictionHorizon = parseInt(val);
            document.getElementById('horizonValue').textContent = val + 'ms';
        }

        function setCoupling(val) {
            K_base = parseFloat(val);
            document.getElementById('kValue').textContent = parseFloat(val).toFixed(2);
        }

        function setZHeight(val) {
            currentZ = parseFloat(val);
            document.getElementById('zValue').textContent = parseFloat(val).toFixed(2);

            // Update domain and phase displays immediately
            const domain = getDomain(currentZ);
            const wumboPhase = getWumboPhase(currentZ);
            const Kz = calculateKz(currentZ);
            const cascade = getCascadeMultiplier(currentZ);

            document.getElementById('domainDisplay').textContent = domain;
            document.getElementById('domainDisplay').style.color =
                domain === 'ABSENCE' ? 'var(--true-green)' :
                domain === 'PRESENCE' ? 'var(--pi-magenta)' : 'var(--phi-gold)';

            document.getElementById('kzDisplay').textContent = (Kz >= 0 ? '+' : '') + Kz.toFixed(2);
            document.getElementById('kzDisplay').style.color = Kz >= 0 ? 'var(--true-green)' : 'var(--paradox-red)';

            document.getElementById('wumboPhaseDisplay').textContent = wumboPhase;
            document.getElementById('cascadeDisplay').textContent = cascade.toFixed(2) + '√ó';

            // Visual feedback for z_c proximity
            if (Math.abs(currentZ - Z_CRITICAL) < 0.03) {
                document.getElementById('cascadeDisplay').style.color = 'var(--phi-gold)';
            } else {
                document.getElementById('cascadeDisplay').style.color = 'var(--pi-magenta)';
            }
        }

        function setBpm(val) {
            bpm = parseInt(val);
            document.getElementById('bpmValue').textContent = val;
            document.getElementById('systemBpm').textContent = val;
        }

        // ================================================================
        // INIT
        // ================================================================

        document.addEventListener('DOMContentLoaded', init);
        window.addEventListener('resize', initCanvases);
    </script>
</body>
</html>
