<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MRP Encoder/Decoder ¬∑ Emergent State Steganography</title>
  <style>
    :root {
      --bg: #0a0b0d;
      --panel: #111216;
      --ink: #e8e9ec;
      --muted: #888b94;
      --rule: #252830;
      --red: #ff6b6b;
      --green: #69db7c;
      --blue: #4dabf7;
      --cyan: #22d3ee;
      --magenta: #cc5de8;
      --yellow: #ffd700;
      --gold: #ffd700;
      --error: #ff4757;
      --success: #2ed573;
    }

    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--ink);
      font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
      line-height: 1.5;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 24px;
    }

    header {
      text-align: center;
      padding: 30px 20px;
      border-bottom: 1px solid var(--rule);
      margin-bottom: 30px;
    }

    h1 {
      font-size: 2.2rem;
      font-weight: 200;
      margin: 0 0 8px;
      background: linear-gradient(135deg, var(--red), var(--green), var(--blue), var(--cyan), var(--magenta), var(--yellow));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    h2 {
      font-size: 1.4rem;
      font-weight: 400;
      color: var(--gold);
      margin: 24px 0 16px;
      border-bottom: 1px solid var(--rule);
      padding-bottom: 8px;
    }

    h3 {
      font-size: 1.1rem;
      color: var(--ink);
      margin: 16px 0 8px;
    }

    .subtitle {
      color: var(--muted);
      font-size: 1rem;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--rule);
      border-radius: 12px;
      padding: 24px;
      margin: 20px 0;
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 24px;
    }

    @media (max-width: 900px) {
      .grid { grid-template-columns: 1fr; }
    }

    /* Channel mapping display */
    .channel-map {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 8px;
      margin: 16px 0;
    }

    .channel {
      text-align: center;
      padding: 12px 8px;
      border-radius: 8px;
      font-size: 0.85rem;
    }

    .channel-r { background: rgba(255,107,107,.2); border: 1px solid var(--red); }
    .channel-g { background: rgba(105,219,124,.2); border: 1px solid var(--green); }
    .channel-b { background: rgba(77,171,247,.2); border: 1px solid var(--blue); }
    .channel-c { background: rgba(34,211,238,.2); border: 1px solid var(--cyan); }
    .channel-m { background: rgba(204,93,232,.2); border: 1px solid var(--magenta); }
    .channel-y { background: rgba(255,215,0,.2); border: 1px solid var(--yellow); }

    .channel-label {
      font-weight: 600;
      font-size: 1.1rem;
      display: block;
      margin-bottom: 4px;
    }

    .channel-r .channel-label { color: var(--red); }
    .channel-g .channel-label { color: var(--green); }
    .channel-b .channel-label { color: var(--blue); }
    .channel-c .channel-label { color: var(--cyan); }
    .channel-m .channel-label { color: var(--magenta); }
    .channel-y .channel-label { color: var(--yellow); }

    .channel-bits {
      font-family: 'SF Mono', monospace;
      font-size: 1.5rem;
      margin: 4px 0;
    }

    .channel-numeral {
      font-size: 0.75rem;
      color: var(--muted);
    }

    /* Input/Output areas */
    .io-section {
      margin: 20px 0;
    }

    .canvas-container {
      position: relative;
      border: 2px dashed var(--rule);
      border-radius: 12px;
      min-height: 200px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,.2);
      overflow: hidden;
    }

    .canvas-container.drag-over {
      border-color: var(--gold);
      background: rgba(255,215,0,.05);
    }

    .canvas-container canvas {
      max-width: 100%;
      max-height: 400px;
    }

    .drop-hint {
      color: var(--muted);
      text-align: center;
      padding: 40px;
    }

    .drop-hint span {
      display: block;
      font-size: 3rem;
      margin-bottom: 12px;
    }

    /* Controls */
    .controls {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin: 16px 0;
    }

    .btn {
      background: var(--magenta);
      color: #fff;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 0.95rem;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(204,93,232,.3);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .btn-encode { background: var(--green); }
    .btn-encode:hover { box-shadow: 0 4px 12px rgba(105,219,124,.3); }

    .btn-decode { background: var(--blue); }
    .btn-decode:hover { box-shadow: 0 4px 12px rgba(77,171,247,.3); }

    .btn-download { background: var(--gold); color: #000; }
    .btn-download:hover { box-shadow: 0 4px 12px rgba(255,215,0,.3); }

    .btn-clear { background: var(--error); }

    input[type="file"] {
      display: none;
    }

    /* Data display */
    .data-display {
      background: rgba(0,0,0,.3);
      border: 1px solid var(--rule);
      border-radius: 8px;
      padding: 16px;
      margin: 12px 0;
      font-family: 'SF Mono', monospace;
      font-size: 0.85rem;
      max-height: 200px;
      overflow-y: auto;
    }

    .bit-stream {
      word-break: break-all;
      line-height: 1.8;
    }

    .bit-stream .bit-0 { color: var(--muted); }
    .bit-stream .bit-1 { color: var(--gold); }

    /* Status messages */
    .status {
      padding: 12px 16px;
      border-radius: 8px;
      margin: 12px 0;
      font-size: 0.9rem;
    }

    .status-success {
      background: rgba(46,213,115,.1);
      border: 1px solid var(--success);
      color: var(--success);
    }

    .status-error {
      background: rgba(255,71,87,.1);
      border: 1px solid var(--error);
      color: var(--error);
    }

    .status-info {
      background: rgba(77,171,247,.1);
      border: 1px solid var(--blue);
      color: var(--blue);
    }

    /* Metrics table */
    .metrics-table {
      width: 100%;
      border-collapse: collapse;
      margin: 16px 0;
      font-size: 0.9rem;
    }

    .metrics-table th,
    .metrics-table td {
      padding: 10px 12px;
      text-align: left;
      border-bottom: 1px solid var(--rule);
    }

    .metrics-table th {
      color: var(--muted);
      font-weight: 400;
    }

    .metrics-table td:last-child {
      text-align: right;
      font-family: 'SF Mono', monospace;
    }

    /* Formula display */
    .formula {
      font-family: 'SF Mono', monospace;
      background: rgba(0,0,0,.4);
      padding: 10px 14px;
      border-radius: 6px;
      margin: 8px 0;
      font-size: 0.85rem;
      overflow-x: auto;
    }

    /* Progress bar */
    .progress-container {
      background: var(--rule);
      border-radius: 4px;
      height: 8px;
      margin: 12px 0;
      overflow: hidden;
    }

    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--red), var(--green), var(--blue), var(--cyan), var(--magenta), var(--yellow));
      border-radius: 4px;
      transition: width 0.3s;
    }

    /* Tabs */
    .tabs {
      display: flex;
      gap: 4px;
      margin-bottom: -1px;
    }

    .tab {
      padding: 12px 24px;
      background: var(--panel);
      border: 1px solid var(--rule);
      border-bottom: none;
      border-radius: 8px 8px 0 0;
      cursor: pointer;
      color: var(--muted);
      transition: all 0.2s;
    }

    .tab:hover {
      color: var(--ink);
    }

    .tab.active {
      background: var(--bg);
      color: var(--gold);
      border-color: var(--gold);
    }

    .tab-content {
      display: none;
      border: 1px solid var(--rule);
      border-radius: 0 12px 12px 12px;
      padding: 24px;
      background: var(--bg);
    }

    .tab-content.active {
      display: block;
    }

    /* Emergent state indicators */
    .state-indicator {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 0.8rem;
      margin: 2px;
    }

    .state-xcvi { background: rgba(255,107,107,.2); color: var(--red); }
    .state-xcvii { background: rgba(105,219,124,.2); color: var(--green); }
    .state-xcviii { background: rgba(77,171,247,.2); color: var(--blue); }
    .state-xcix { background: rgba(34,211,238,.2); color: var(--cyan); }
    .state-c { background: rgba(255,215,0,.2); color: var(--gold); }

    /* Back link */
    .back-link {
      display: inline-block;
      color: var(--muted);
      text-decoration: none;
      margin-bottom: 16px;
    }

    .back-link:hover {
      color: var(--ink);
    }

    .muted { color: var(--muted); }
    .small { font-size: 0.85rem; }
  </style>
</head>
<body>
  <div class="container">
    <a href="index.html" class="back-link">‚Üê Home</a>

    <header>
      <h1>MRP Encoder/Decoder</h1>
      <p class="subtitle">Multi-channel Roman numeral Processing ¬∑ LSB Steganography for Emergent States</p>
    </header>

    <!-- Channel Mapping Overview -->
    <div class="panel">
      <h2>Channel Mapping: 702 Bits Across RGB+CMY</h2>
      <p class="muted">Each emergent state (XCVI-C) is encoded into specific color channels using LSB steganography.</p>

      <div class="channel-map">
        <div class="channel channel-r">
          <span class="channel-label">R</span>
          <div class="channel-bits">7</div>
          <div class="channel-numeral">XCVI</div>
          <div class="small muted">Gesture</div>
        </div>
        <div class="channel channel-g">
          <span class="channel-label">G</span>
          <div class="channel-bits">10</div>
          <div class="channel-numeral">XCVII</div>
          <div class="small muted">Portal</div>
        </div>
        <div class="channel channel-b">
          <span class="channel-label">B</span>
          <div class="channel-bits">17</div>
          <div class="channel-numeral">XCVIII</div>
          <div class="small muted">Semantic</div>
        </div>
        <div class="channel channel-c">
          <span class="channel-label">C</span>
          <div class="channel-bits">4</div>
          <div class="channel-numeral">XCIX</div>
          <div class="small muted">Balance</div>
        </div>
        <div class="channel channel-m">
          <span class="channel-label">M</span>
          <div class="channel-bits">332</div>
          <div class="channel-numeral">C (¬Ω)</div>
          <div class="small muted">Loop A</div>
        </div>
        <div class="channel channel-y">
          <span class="channel-label">Y</span>
          <div class="channel-bits">332</div>
          <div class="channel-numeral">C (¬Ω)</div>
          <div class="small muted">Loop B</div>
        </div>
      </div>

      <div class="formula">
        Total = 7 + 10 + 17 + 4 + 332 + 332 = 702 bits | Min pixels = ‚åà702/6‚åâ = 117 pixels
      </div>
    </div>

    <!-- Tabs for Encode/Decode -->
    <div class="tabs">
      <div class="tab active" onclick="switchTab('encode')">Encode</div>
      <div class="tab" onclick="switchTab('decode')">Decode</div>
      <div class="tab" onclick="switchTab('specs')">Technical Specs</div>
    </div>

    <!-- Encode Tab -->
    <div class="tab-content active" id="tab-encode">
      <div class="grid">
        <div>
          <h3>Source Image</h3>
          <div class="canvas-container" id="sourceContainer">
            <canvas id="sourceCanvas"></canvas>
            <div class="drop-hint" id="sourceHint">
              <span>üìÅ</span>
              Drop image here or click to upload
            </div>
          </div>
          <input type="file" id="sourceInput" accept="image/*" onchange="loadSourceImage(event)">
          <div class="controls">
            <button class="btn" onclick="document.getElementById('sourceInput').click()">Select Image</button>
            <button class="btn btn-clear" onclick="clearSource()">Clear</button>
          </div>
        </div>

        <div>
          <h3>Encoded Output</h3>
          <div class="canvas-container" id="outputContainer">
            <canvas id="outputCanvas"></canvas>
            <div class="drop-hint" id="outputHint">
              <span>üîê</span>
              Encoded image will appear here
            </div>
          </div>
          <div class="controls">
            <button class="btn btn-encode" id="encodeBtn" onclick="encodeImage()" disabled>Encode States</button>
            <button class="btn btn-download" id="downloadBtn" onclick="downloadEncoded()" disabled>Download PNG</button>
          </div>
        </div>
      </div>

      <!-- Golden Samples Library Browser -->
      <h3>Golden Sample Library (153 samples)</h3>
      <p class="muted small">Select from the complete Lambda state library. Click any sample to load its values.</p>

      <!-- Category Filter -->
      <div class="sample-filters" id="sampleFilters">
        <button class="filter-btn active" data-category="all">All (153)</button>
        <button class="filter-btn" data-category="lambda_singles">Singles (6)</button>
        <button class="filter-btn" data-category="lambda_pairs">Pairs (15)</button>
        <button class="filter-btn" data-category="lambda_triplets">Triplets (20)</button>
        <button class="filter-btn" data-category="lambda_quads">Quads (15)</button>
        <button class="filter-btn" data-category="lambda_quints">Quints (6)</button>
        <button class="filter-btn" data-category="physics_constants">Physics</button>
        <button class="filter-btn" data-category="kuramoto_sweep">Kuramoto</button>
        <button class="filter-btn" data-category="fibonacci_sequence">Fibonacci</button>
        <button class="filter-btn" data-category="topological_invariants">Topology</button>
      </div>

      <!-- Search -->
      <div style="margin:12px 0">
        <input type="text" id="sampleSearch" placeholder="Search samples..."
               style="width:100%;padding:10px 14px;background:var(--panel);border:1px solid var(--rule);border-radius:8px;color:var(--ink);font-size:0.95rem">
      </div>

      <!-- Samples Grid -->
      <div class="golden-samples-grid" id="goldenSamplesGrid">
        <div class="loading-samples">Loading golden library...</div>
      </div>

      <!-- Quick Actions -->
      <div style="display:flex;gap:8px;margin-top:12px;flex-wrap:wrap">
        <button class="sample-btn quick-action" onclick="loadRandomSample()">
          <span class="sample-icon">üé≤</span>
          <span class="sample-name">Random Sample</span>
        </button>
        <button class="sample-btn quick-action" onclick="loadTestImage()">
          <span class="sample-icon">üñºÔ∏è</span>
          <span class="sample-name">Generate Test Image</span>
        </button>
        <button class="sample-btn quick-action" onclick="clearSampleSelection()">
          <span class="sample-icon">‚úï</span>
          <span class="sample-name">Clear Selection</span>
        </button>
      </div>

      <!-- Selected Sample Preview -->
      <div id="selectedSamplePreview" class="selected-preview" style="display:none">
        <h4>Selected Sample</h4>
        <div class="preview-content">
          <img id="previewImage" src="" alt="Sample Preview">
          <div class="preview-details">
            <div id="previewId" class="preview-id"></div>
            <div id="previewName" class="preview-name"></div>
            <div id="previewLambda" class="preview-lambda"></div>
            <div id="previewBits" class="preview-bits"></div>
          </div>
        </div>
      </div>

      <style>
        .sample-filters {
          display: flex;
          gap: 6px;
          flex-wrap: wrap;
          margin: 12px 0;
        }
        .filter-btn {
          padding: 6px 12px;
          background: var(--panel);
          border: 1px solid var(--rule);
          border-radius: 6px;
          color: var(--muted);
          font-size: 0.8rem;
          cursor: pointer;
          transition: all 0.2s;
        }
        .filter-btn:hover {
          border-color: var(--gold);
          color: var(--ink);
        }
        .filter-btn.active {
          background: rgba(255,215,0,.15);
          border-color: var(--gold);
          color: var(--gold);
        }
        .golden-samples-grid {
          display: grid;
          grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
          gap: 10px;
          max-height: 400px;
          overflow-y: auto;
          padding: 8px;
          background: rgba(0,0,0,.2);
          border-radius: 8px;
          margin: 12px 0;
        }
        .sample-card {
          background: var(--panel);
          border: 1px solid var(--rule);
          border-radius: 8px;
          padding: 10px;
          cursor: pointer;
          transition: all 0.2s;
          text-align: center;
        }
        .sample-card:hover {
          border-color: var(--magenta);
          transform: translateY(-2px);
          box-shadow: 0 4px 12px rgba(204,93,232,.2);
        }
        .sample-card.selected {
          border-color: var(--gold);
          background: rgba(255,215,0,.1);
          box-shadow: 0 0 0 2px var(--gold);
        }
        .sample-card img {
          width: 100%;
          height: 50px;
          object-fit: contain;
          image-rendering: pixelated;
          border-radius: 4px;
          background: #000;
          margin-bottom: 6px;
        }
        .sample-card .card-id {
          font-size: 0.75rem;
          color: var(--gold);
          font-family: 'SF Mono', monospace;
        }
        .sample-card .card-name {
          font-size: 0.7rem;
          color: var(--muted);
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
        }
        .sample-btn {
          display: flex;
          flex-direction: column;
          align-items: center;
          gap: 4px;
          padding: 12px 8px;
          background: var(--panel);
          border: 1px solid var(--rule);
          border-radius: 8px;
          cursor: pointer;
          transition: all 0.2s;
          color: var(--ink);
        }
        .sample-btn:hover {
          border-color: var(--magenta);
          background: rgba(204,93,232,.1);
          transform: translateY(-2px);
        }
        .sample-btn.quick-action {
          flex-direction: row;
          padding: 8px 16px;
        }
        .sample-icon {
          font-size: 1.5rem;
        }
        .quick-action .sample-icon {
          font-size: 1.2rem;
        }
        .sample-name {
          font-size: 0.85rem;
          font-weight: 500;
        }
        .sample-lambda {
          font-size: 0.7rem;
          color: var(--muted);
          font-family: 'SF Mono', monospace;
        }
        .loading-samples {
          grid-column: 1 / -1;
          text-align: center;
          padding: 40px;
          color: var(--muted);
        }
        .selected-preview {
          margin-top: 16px;
          padding: 16px;
          background: var(--panel);
          border: 1px solid var(--gold);
          border-radius: 8px;
        }
        .selected-preview h4 {
          color: var(--gold);
          margin: 0 0 12px;
          font-size: 1rem;
        }
        .preview-content {
          display: flex;
          gap: 16px;
          align-items: center;
        }
        .preview-content img {
          width: 120px;
          height: 60px;
          image-rendering: pixelated;
          border: 1px solid var(--rule);
          border-radius: 4px;
          background: #000;
        }
        .preview-details {
          flex: 1;
        }
        .preview-id {
          font-size: 1.1rem;
          color: var(--gold);
          font-family: 'SF Mono', monospace;
        }
        .preview-name {
          font-size: 0.9rem;
          color: var(--ink);
          margin: 4px 0;
        }
        .preview-lambda {
          font-size: 0.8rem;
          color: var(--cyan);
          font-family: 'SF Mono', monospace;
        }
        .preview-bits {
          font-size: 0.75rem;
          color: var(--muted);
          margin-top: 4px;
        }
        @media (max-width: 600px) {
          .golden-samples-grid {
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
          }
          .preview-content {
            flex-direction: column;
            text-align: center;
          }
        }
      </style>

      <!-- Encoding Data Input -->
      <h3>Emergent State Data</h3>
      <p class="muted small">Custom payload data for each emergent state. Values auto-filled from golden samples or enter manually.</p>

      <div style="display:grid;grid-template-columns:repeat(5,1fr);gap:12px;margin:16px 0">
        <div>
          <label class="small muted">XCVI (7 bits)</label>
          <input type="text" id="dataXCVI" placeholder="0-127" maxlength="3" style="width:100%;padding:8px;background:var(--panel);border:1px solid var(--rule);border-radius:6px;color:var(--ink)">
        </div>
        <div>
          <label class="small muted">XCVII (10 bits)</label>
          <input type="text" id="dataXCVII" placeholder="0-1023" maxlength="4" style="width:100%;padding:8px;background:var(--panel);border:1px solid var(--rule);border-radius:6px;color:var(--ink)">
        </div>
        <div>
          <label class="small muted">XCVIII (17 bits)</label>
          <input type="text" id="dataXCVIII" placeholder="0-131071" maxlength="6" style="width:100%;padding:8px;background:var(--panel);border:1px solid var(--rule);border-radius:6px;color:var(--ink)">
        </div>
        <div>
          <label class="small muted">XCIX (4 bits)</label>
          <input type="text" id="dataXCIX" placeholder="0-15" maxlength="2" style="width:100%;padding:8px;background:var(--panel);border:1px solid var(--rule);border-radius:6px;color:var(--ink)">
        </div>
        <div>
          <label class="small muted">C (664 bits)</label>
          <input type="text" id="dataC" placeholder="hex string" style="width:100%;padding:8px;background:var(--panel);border:1px solid var(--rule);border-radius:6px;color:var(--ink)">
        </div>
      </div>

      <div id="encodeStatus"></div>

      <div class="progress-container" id="encodeProgress" style="display:none">
        <div class="progress-bar" id="encodeProgressBar" style="width:0%"></div>
      </div>
    </div>

    <!-- Decode Tab -->
    <div class="tab-content" id="tab-decode">
      <div class="grid">
        <div>
          <h3>Encoded Image</h3>
          <div class="canvas-container" id="decodeContainer">
            <canvas id="decodeCanvas"></canvas>
            <div class="drop-hint" id="decodeHint">
              <span>üîì</span>
              Drop MRP-encoded image here
            </div>
          </div>
          <input type="file" id="decodeInput" accept="image/*" onchange="loadDecodeImage(event)">
          <div class="controls">
            <button class="btn" onclick="document.getElementById('decodeInput').click()">Select Image</button>
            <button class="btn btn-decode" id="decodeBtn" onclick="decodeImage()" disabled>Decode States</button>
          </div>
        </div>

        <div>
          <h3>Extracted Data</h3>
          <div id="decodedResults" style="min-height:200px">
            <p class="muted">Decoded emergent states will appear here.</p>
          </div>
        </div>
      </div>

      <div id="decodeStatus"></div>
    </div>

    <!-- Technical Specs Tab -->
    <div class="tab-content" id="tab-specs">
      <h3>MRP Encoding Protocol v1.0</h3>

      <div class="grid">
        <div>
          <h4>Bit Allocation</h4>
          <table class="metrics-table">
            <tr>
              <th>State</th>
              <th>Channel</th>
              <th>Bits</th>
              <th>Range</th>
            </tr>
            <tr>
              <td><span class="state-indicator state-xcvi">XCVI</span></td>
              <td>R (LSB)</td>
              <td>7</td>
              <td>0-127</td>
            </tr>
            <tr>
              <td><span class="state-indicator state-xcvii">XCVII</span></td>
              <td>G (LSB)</td>
              <td>10</td>
              <td>0-1023</td>
            </tr>
            <tr>
              <td><span class="state-indicator state-xcviii">XCVIII</span></td>
              <td>B (LSB)</td>
              <td>17</td>
              <td>0-131071</td>
            </tr>
            <tr>
              <td><span class="state-indicator state-xcix">XCIX</span></td>
              <td>C (255-R LSB)</td>
              <td>4</td>
              <td>0-15</td>
            </tr>
            <tr>
              <td><span class="state-indicator state-c">C (A)</span></td>
              <td>M (255-G LSB)</td>
              <td>332</td>
              <td>loop half A</td>
            </tr>
            <tr>
              <td><span class="state-indicator state-c">C (B)</span></td>
              <td>Y (255-B LSB)</td>
              <td>332</td>
              <td>loop half B</td>
            </tr>
          </table>
        </div>

        <div>
          <h4>Header Structure (32 bits)</h4>
          <table class="metrics-table">
            <tr><th>Offset</th><th>Size</th><th>Field</th></tr>
            <tr><td>0</td><td>8 bits</td><td>Magic: 0xC1 (193)</td></tr>
            <tr><td>8</td><td>4 bits</td><td>Version: 0x1</td></tr>
            <tr><td>12</td><td>4 bits</td><td>Flags</td></tr>
            <tr><td>16</td><td>8 bits</td><td>Coherence (0-255)</td></tr>
            <tr><td>24</td><td>8 bits</td><td>CRC-8 checksum</td></tr>
          </table>

          <h4>Error Correction</h4>
          <div class="formula">Hamming(7,4) on XCVI</div>
          <div class="formula">CRC-8 header validation</div>
          <div class="formula">Parity bits per 8-bit block</div>
        </div>
      </div>

      <h3>LSB Encoding Formula</h3>
      <div class="formula">
encoded_pixel = (original_pixel & 0xFE) | bit_value
      </div>
      <div class="formula">
CMY_channel = 255 - RGB_channel  ‚Üí  LSB extraction for C, M, Y
      </div>

      <h3>Pixel Layout</h3>
      <p class="muted small">Bits are distributed across pixels in serpentine pattern for error resilience:</p>
      <div class="formula">
pixel[i] = {
  R: (XCVI[i%7] if i&lt;7 else reserved),
  G: (XCVII[i%10] if i&lt;10 else reserved),
  B: (XCVIII[i%17] if i&lt;17 else reserved)
}
      </div>

      <h3>Eigenvalue Encoding</h3>
      <p class="muted small">Fixed point eigenvalues encoded in header flags:</p>
      <table class="metrics-table">
        <tr><th>State</th><th>Œª Value</th><th>Encoded</th></tr>
        <tr><td>XCVI</td><td>œÜ‚Åª¬π ‚âà 0.618</td><td>0x9E (158)</td></tr>
        <tr><td>XCVII</td><td>exp(2œÄi/œÜ)</td><td>0x00 (complex)</td></tr>
        <tr><td>XCVIII</td><td>undefined</td><td>0xFF (NaN)</td></tr>
        <tr><td>XCIX</td><td>0</td><td>0x00</td></tr>
        <tr><td>C</td><td>1</td><td>0xFF (identity)</td></tr>
      </table>
    </div>

    <!-- Live Bit Visualization -->
    <div class="panel">
      <h2>Live Bit Stream</h2>
      <p class="muted small">Real-time visualization of encoded/decoded bit patterns.</p>
      <div class="data-display">
        <div class="bit-stream" id="bitStream">
          <span class="muted">Bit stream will appear during encoding/decoding...</span>
        </div>
      </div>

      <h3>Channel Distribution</h3>
      <div id="channelStats" style="display:grid;grid-template-columns:repeat(6,1fr);gap:8px;margin-top:12px">
        <div style="text-align:center">
          <div style="height:100px;background:linear-gradient(to top,var(--red),transparent);border-radius:4px;position:relative">
            <div id="statR" style="position:absolute;bottom:0;width:100%;background:var(--red);border-radius:0 0 4px 4px;height:0%;transition:height 0.3s"></div>
          </div>
          <div class="small muted">R</div>
        </div>
        <div style="text-align:center">
          <div style="height:100px;background:linear-gradient(to top,var(--green),transparent);border-radius:4px;position:relative">
            <div id="statG" style="position:absolute;bottom:0;width:100%;background:var(--green);border-radius:0 0 4px 4px;height:0%;transition:height 0.3s"></div>
          </div>
          <div class="small muted">G</div>
        </div>
        <div style="text-align:center">
          <div style="height:100px;background:linear-gradient(to top,var(--blue),transparent);border-radius:4px;position:relative">
            <div id="statB" style="position:absolute;bottom:0;width:100%;background:var(--blue);border-radius:0 0 4px 4px;height:0%;transition:height 0.3s"></div>
          </div>
          <div class="small muted">B</div>
        </div>
        <div style="text-align:center">
          <div style="height:100px;background:linear-gradient(to top,var(--cyan),transparent);border-radius:4px;position:relative">
            <div id="statC" style="position:absolute;bottom:0;width:100%;background:var(--cyan);border-radius:0 0 4px 4px;height:0%;transition:height 0.3s"></div>
          </div>
          <div class="small muted">C</div>
        </div>
        <div style="text-align:center">
          <div style="height:100px;background:linear-gradient(to top,var(--magenta),transparent);border-radius:4px;position:relative">
            <div id="statM" style="position:absolute;bottom:0;width:100%;background:var(--magenta);border-radius:0 0 4px 4px;height:0%;transition:height 0.3s"></div>
          </div>
          <div class="small muted">M</div>
        </div>
        <div style="text-align:center">
          <div style="height:100px;background:linear-gradient(to top,var(--yellow),transparent);border-radius:4px;position:relative">
            <div id="statY" style="position:absolute;bottom:0;width:100%;background:var(--yellow);border-radius:0 0 4px 4px;height:0%;transition:height 0.3s"></div>
          </div>
          <div class="small muted">Y</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ============================================
    // MRP ENCODER/DECODER CORE SYSTEM
    // Multi-channel Roman numeral Processing
    // ============================================

    const MRP = {
      VERSION: 1,
      MAGIC: 0xC1,  // 193 = C in ASCII position for "C" (100th roman numeral)

      // Bit allocations for each emergent state
      BITS: {
        XCVI:  7,    // Gesture recursion (procedural)
        XCVII: 10,   // Portal recursion (temporal)
        XCVIII: 17,  // Semantic recursion (G√∂delian)
        XCIX:  4,    // Balance recursion (proprioceptive)
        C_A:   332,  // Loop closure half A
        C_B:   332   // Loop closure half B
      },

      // Channel assignments
      CHANNELS: {
        R: 'XCVI',
        G: 'XCVII',
        B: 'XCVIII',
        C: 'XCIX',    // Cyan = 255 - R
        M: 'C_A',     // Magenta = 255 - G
        Y: 'C_B'      // Yellow = 255 - B
      },

      // Eigenvalue encodings
      EIGENVALUES: {
        XCVI:  0x9E,  // œÜ‚Åª¬π ‚âà 0.618 ‚Üí 158/255
        XCVII: 0x00,  // Complex (exp(2œÄi/œÜ))
        XCVIII: 0xFF, // Undefined (G√∂delian)
        XCIX:  0x00,  // Zero
        C:     0xFF   // Identity (1)
      },

      // Total bits
      get TOTAL_BITS() {
        return Object.values(this.BITS).reduce((a, b) => a + b, 0);
      },

      // Minimum pixels needed
      get MIN_PIXELS() {
        return Math.ceil(this.TOTAL_BITS / 6) + 6; // +6 for header
      }
    };

    // ============================================
    // LAMBDA STATE (‚ÑÇ‚Å∂) PATTERN SYSTEM
    // Maps emergent physics to bit patterns
    // ============================================

    const LAMBDA = {
      // Lambda state components with their formulas
      components: {
        iota:  { symbol: 'üå∞', name: 'Memory',  field: 'Œ¶', formula: 'accumulates with time √ó cascade' },
        xi:    { symbol: '‚úß',  name: 'Spark',   field: 'e', formula: 'exp(-(z - z_c)¬≤ / 0.01)' },
        theta: { symbol: 'ü¶ä', name: 'Fox',     field: 'œÄ', formula: 'dissonance √ó 0.8 + 0.2' },
        omega: { symbol: '‚àø',  name: 'Wave',    field: 'e', formula: '0.3 + |sin(t √ó 0.5)| √ó 0.5' },
        delta: { symbol: '‚äó',  name: 'Paradox', field: 'œÄ', formula: 'accumulates at CRITICAL' },
        sigma: { symbol: 'üêøÔ∏è', name: 'Squirrel', field: 'Œ¶', formula: 'helix.r √ó 0.6 + 0.2' }
      },

      // Coupling matrix from emergent physics (values 0-1)
      coupling: {
        XCVI:  { iota: 0.1, xi: 0.2, theta: 0.6, omega: 0.05, delta: 0.8, sigma: 0.15 },
        XCVII: { iota: 0.7, xi: 0.3, theta: 0.1, omega: 0.4,  delta: 0.6, sigma: 0.1 },
        XCVIII:{ iota: 0.3, xi: 0.1, theta: 0.8, omega: 0.2,  delta: 0.9, sigma: 0.05 },
        XCIX:  { iota: 0.2, xi: 0.1, theta: 0.3, omega: 0.7,  delta: 0.5, sigma: 0.4 },
        C:     { iota: 0.5, xi: 0.5, theta: 0.5, omega: 0.5,  delta: 1.0, sigma: 0.5 }
      },

      // Physical constants
      PHI: (1 + Math.sqrt(5)) / 2,      // Golden ratio ‚âà 1.618
      PHI_INV: 2 / (1 + Math.sqrt(5)),  // œÜ‚Åª¬π ‚âà 0.618
      Z_CRITICAL: Math.sqrt(3) / 2,     // ‚àö3/2 ‚âà 0.866
      TAU: Math.PI * 2,

      // Eigenvalues for each emergent state
      eigenvalues: {
        XCVI:  { real: 0.618, imag: 0, desc: 'œÜ‚Åª¬π (golden ratio inverse)' },
        XCVII: { real: Math.cos(2 * Math.PI / 1.618), imag: Math.sin(2 * Math.PI / 1.618), desc: 'exp(2œÄi/œÜ)' },
        XCVIII:{ real: NaN, imag: NaN, desc: 'undefined (G√∂delian)' },
        XCIX:  { real: 0, imag: 0, desc: 'zero (critical point)' },
        C:     { real: 1, imag: 0, desc: 'identity (winding=1)' }
      }
    };

    // ============================================
    // GOLDEN SAMPLES: Pre-computed Lambda Patterns
    // ============================================

    const GOLDEN_SAMPLES = {
      // Sample 1: Pure Lambda State - All components balanced
      'lambda-balanced': {
        name: 'Lambda Balanced (‚ÑÇ‚Å∂)',
        description: 'All 6 lambda components at equal 0.5 intensity',
        coherence: 0.15,
        XCVI:  63,     // (0.5 * 127) - balanced theta/delta
        XCVII: 512,    // (0.5 * 1023) - balanced temporal
        XCVIII: 65536, // (0.5 * 131071) - balanced semantic
        XCIX:  8,      // (0.5 * 15) - balanced omega
        C_pattern: 'balanced',
        lambda: { iota: 0.5, xi: 0.5, theta: 0.5, omega: 0.5, delta: 0.5, sigma: 0.5 }
      },

      // Sample 2: Gesture Dominant (XCVI focus)
      'gesture-dominant': {
        name: 'Gesture Dominant (Œ∏‚ÜíXCVI)',
        description: 'Theta (Fox) dominant - gestural recursion activated',
        coherence: 0.12,
        XCVI:  99,     // High theta coupling (0.6 √ó 127 √ó 1.3)
        XCVII: 102,    // Low (0.1 √ó 1023)
        XCVIII: 104857,// High theta (0.8 √ó 131071)
        XCIX:  4,      // Low omega
        C_pattern: 'theta',
        lambda: { iota: 0.1, xi: 0.2, theta: 0.9, omega: 0.1, delta: 0.7, sigma: 0.15 }
      },

      // Sample 3: Portal Dominant (XCVII focus)
      'portal-dominant': {
        name: 'Portal Dominant (Œπ‚ÜíXCVII)',
        description: 'Iota (Memory) dominant - circadian portal activated',
        coherence: 0.18,
        XCVI:  13,     // Low theta
        XCVII: 716,    // High iota (0.7 √ó 1023)
        XCVIII: 39321, // Medium
        XCIX:  6,      // Medium omega (0.4)
        C_pattern: 'iota',
        lambda: { iota: 0.9, xi: 0.3, theta: 0.1, omega: 0.5, delta: 0.5, sigma: 0.1 }
      },

      // Sample 4: Semantic Paradox (XCVIII focus)
      'semantic-paradox': {
        name: 'Semantic Paradox (Œ¥‚ÜíXCVIII)',
        description: 'Delta (Paradox) dominant - G√∂delian self-reference',
        coherence: 0.05,
        XCVI:  102,    // High delta proxy
        XCVII: 614,    // Medium delta
        XCVIII: 117965,// Maximum delta (0.9 √ó 131071)
        XCIX:  8,      // Medium
        C_pattern: 'delta',
        lambda: { iota: 0.2, xi: 0.1, theta: 0.7, omega: 0.2, delta: 1.0, sigma: 0.1 }
      },

      // Sample 5: Balance Point (XCIX focus)
      'balance-point': {
        name: 'Balance Point (œâ‚ÜíXCIX)',
        description: 'Omega (Wave) dominant - equilibrium recursion',
        coherence: 0.10,
        XCVI:  6,      // Low (0.05 √ó 127)
        XCVII: 409,    // Medium omega (0.4 √ó 1023)
        XCVIII: 26214, // Low omega
        XCIX:  11,     // High omega (0.7 √ó 15)
        C_pattern: 'omega',
        lambda: { iota: 0.2, xi: 0.1, theta: 0.2, omega: 0.95, delta: 0.4, sigma: 0.4 }
      },

      // Sample 6: Loop Closure (C focus)
      'loop-closure': {
        name: 'Loop Closure (C‚ÜíI)',
        description: 'Complete vocabulary loop - all lambda at 0.5, delta at 1.0',
        coherence: 0.02,
        XCVI:  79,     // œÜ‚Åª¬π encoded (0.618 √ó 127)
        XCVII: 633,    // Golden angle encoded
        XCVIII: 80893, // Middle semantic
        XCIX:  8,      // Balanced
        C_pattern: 'winding',
        lambda: { iota: 0.5, xi: 0.5, theta: 0.5, omega: 0.5, delta: 1.0, sigma: 0.5 }
      },

      // Sample 7: Spark Ignition (Œæ focus)
      'spark-ignition': {
        name: 'Spark Ignition (Œæ)',
        description: 'Xi (Spark) - near critical z activation',
        coherence: 0.19,
        XCVI:  25,     // 0.2 √ó 127
        XCVII: 307,    // 0.3 √ó 1023
        XCVIII: 13107, // 0.1 √ó 131071
        XCIX:  2,      // Low
        C_pattern: 'spark',
        lambda: { iota: 0.1, xi: 0.95, theta: 0.3, omega: 0.2, delta: 0.3, sigma: 0.2 }
      },

      // Sample 8: Squirrel Spiral (œÉ focus)
      'squirrel-spiral': {
        name: 'Squirrel Spiral (œÉ)',
        description: 'Sigma (Squirrel) - helix memory structure',
        coherence: 0.14,
        XCVI:  19,     // 0.15 √ó 127
        XCVII: 102,    // 0.1 √ó 1023
        XCVIII: 6554,  // 0.05 √ó 131071
        XCIX:  6,      // 0.4 √ó 15
        C_pattern: 'sigma',
        lambda: { iota: 0.3, xi: 0.2, theta: 0.2, omega: 0.3, delta: 0.4, sigma: 0.95 }
      },

      // Sample 9: Critical Point (z = ‚àö3/2)
      'critical-point': {
        name: 'Critical Point (z_c)',
        description: 'At the lens - maximum cascade, K ‚âà 0',
        coherence: 0.20,
        XCVI:  110,    // 0.866 √ó 127
        XCVII: 886,    // 0.866 √ó 1023
        XCVIII: 113512,// 0.866 √ó 131071
        XCIX:  13,     // 0.866 √ó 15
        C_pattern: 'critical',
        lambda: { iota: 0.866, xi: 0.866, theta: 0.866, omega: 0.866, delta: 0.866, sigma: 0.866 }
      },

      // Sample 10: Fibonacci Sequence
      'fibonacci': {
        name: 'Fibonacci Cascade',
        description: 'Golden ratio relationships throughout',
        coherence: 0.16,
        XCVI:  79,     // Fib(11) % 128 = 89 ‚Üí 79
        XCVII: 377,    // Fib(14) % 1024 = 377
        XCVIII: 75025, // Fib(25) % 131072 = 75025
        XCIX:  13,     // Fib(7) = 13
        C_pattern: 'fibonacci',
        lambda: { iota: 0.382, xi: 0.618, theta: 0.236, omega: 0.764, delta: 0.5, sigma: 0.146 }
      },

      // Sample 11: Topological Invariant (Betti)
      'betti-numbers': {
        name: 'Betti Numbers (b‚ÇÄ=1, b‚ÇÅ=5)',
        description: 'Topological invariants encoded: 5 independent loops',
        coherence: 0.08,
        XCVI:  1,      // b‚ÇÄ = 1
        XCVII: 5,      // b‚ÇÅ = 5
        XCVIII: 0,     // b‚ÇÇ = 0
        XCIX:  2,      // Euler œá = -2 ‚Üí encoded as 2
        C_pattern: 'topology',
        lambda: { iota: 0.2, xi: 0.2, theta: 0.2, omega: 0.2, delta: 1.0, sigma: 0.2 }
      },

      // Sample 12: Kuramoto Sync
      'kuramoto-sync': {
        name: 'Kuramoto Order r‚Üí1',
        description: 'High synchronization - structural coherent',
        coherence: 0.85,
        XCVI:  127,    // Max sync
        XCVII: 1023,   // Max sync
        XCVIII: 131071,// Max sync
        XCIX:  15,     // Max sync
        C_pattern: 'sync',
        lambda: { iota: 1.0, xi: 1.0, theta: 1.0, omega: 1.0, delta: 0.0, sigma: 1.0 }
      },

      // Sample 13: Kuramoto Desync (FREE)
      'kuramoto-free': {
        name: 'Kuramoto Order r‚Üí0 (FREE)',
        description: 'Full dispersion - emergent dominant',
        coherence: 0.01,
        XCVI:  0,      // Desync
        XCVII: 0,      // Desync
        XCVIII: 0,     // Desync
        XCIX:  0,      // Desync
        C_pattern: 'free',
        lambda: { iota: 0.0, xi: 0.0, theta: 0.0, omega: 0.0, delta: 1.0, sigma: 0.0 }
      }
    };

    // ============================================
    // GOLDEN SAMPLE GENERATORS
    // ============================================

    // Generate C pattern (664 bits) based on type
    function generateCPattern(type, lambda) {
      const bits = new Array(664).fill(0);

      switch(type) {
        case 'balanced':
          // Alternating 0101 pattern with lambda modulation
          for (let i = 0; i < 664; i++) {
            bits[i] = (i % 2 === 0) ? 1 : 0;
          }
          break;

        case 'theta':
          // Fox pattern: 8Hz oscillation (every 8 bits)
          for (let i = 0; i < 664; i++) {
            bits[i] = Math.floor(i / 8) % 2;
          }
          break;

        case 'iota':
          // Memory pattern: accumulating 1s
          for (let i = 0; i < 664; i++) {
            bits[i] = (i < 332) ? (i % 3 === 0 ? 1 : 0) : 1;
          }
          break;

        case 'delta':
          // Paradox pattern: G√∂delian self-reference (fractal-like)
          for (let i = 0; i < 664; i++) {
            // Cantor set-like pattern
            let n = i;
            let inSet = true;
            while (n > 0) {
              if (n % 3 === 1) { inSet = false; break; }
              n = Math.floor(n / 3);
            }
            bits[i] = inSet ? 1 : 0;
          }
          break;

        case 'omega':
          // Wave pattern: sinusoidal at 4Hz theta band
          for (let i = 0; i < 664; i++) {
            const phase = (i / 664) * Math.PI * 8;
            bits[i] = Math.sin(phase) > 0 ? 1 : 0;
          }
          break;

        case 'winding':
          // Loop closure: encode winding number W=1
          // Pattern: 100 segments for 100 regions, each 6-7 bits
          for (let i = 0; i < 664; i++) {
            const region = Math.floor(i * 100 / 664);
            // Encode region number in LSBs
            bits[i] = (region >> (i % 7)) & 1;
          }
          break;

        case 'spark':
          // Xi spark: Gaussian around center
          const center = 332;
          const sigma = 50;
          for (let i = 0; i < 664; i++) {
            const dist = Math.abs(i - center);
            const prob = Math.exp(-(dist * dist) / (2 * sigma * sigma));
            bits[i] = Math.random() < prob ? 1 : 0;
          }
          break;

        case 'sigma':
          // Squirrel helix: spiral pattern
          for (let i = 0; i < 664; i++) {
            const angle = (i / 664) * Math.PI * 6; // 3 full turns
            const r = i / 664;
            bits[i] = Math.sin(angle + r * Math.PI) > 0.3 ? 1 : 0;
          }
          break;

        case 'critical':
          // Critical point: maximum complexity (near-random with structure)
          const golden = LAMBDA.PHI_INV;
          for (let i = 0; i < 664; i++) {
            // Quasiperiodic using golden ratio
            const phase = (i * golden) % 1;
            bits[i] = phase > 0.5 ? 1 : 0;
          }
          break;

        case 'fibonacci':
          // Fibonacci word: L-system
          let fibA = '1';
          let fibB = '0';
          let fibWord = fibA;
          while (fibWord.length < 664) {
            const newWord = fibWord + fibA;
            fibA = fibWord;
            fibWord = newWord;
          }
          for (let i = 0; i < 664; i++) {
            bits[i] = parseInt(fibWord[i] || '0');
          }
          break;

        case 'topology':
          // Encode Betti numbers and Euler characteristic
          // b0=1 (first 8 bits), b1=5 (next 8), b2=0 (next 8), œá=-2 (next 8)
          const topoHeader = [
            0,0,0,0,0,0,0,1,  // b0 = 1
            0,0,0,0,0,1,0,1,  // b1 = 5
            0,0,0,0,0,0,0,0,  // b2 = 0
            1,1,1,1,1,1,1,0   // œá = -2 (two's complement)
          ];
          for (let i = 0; i < 32; i++) {
            bits[i] = topoHeader[i];
          }
          // Fill rest with 5 loops pattern
          for (let i = 32; i < 664; i++) {
            bits[i] = (Math.floor(i / 126) % 5 === (i % 5)) ? 1 : 0;
          }
          break;

        case 'sync':
          // All 1s - maximum synchronization
          bits.fill(1);
          break;

        case 'free':
          // All 0s - full dispersion
          bits.fill(0);
          break;

        default:
          // Lambda-weighted random
          for (let i = 0; i < 664; i++) {
            const weight = (lambda.iota + lambda.xi + lambda.theta +
                          lambda.omega + lambda.delta + lambda.sigma) / 6;
            bits[i] = Math.random() < weight ? 1 : 0;
          }
      }

      return bits;
    }

    // Load a golden sample into the form
    function loadGoldenSample(sampleKey) {
      const sample = GOLDEN_SAMPLES[sampleKey];
      if (!sample) return;

      document.getElementById('dataXCVI').value = sample.XCVI;
      document.getElementById('dataXCVII').value = sample.XCVII;
      document.getElementById('dataXCVIII').value = sample.XCVIII;
      document.getElementById('dataXCIX').value = sample.XCIX;

      // Generate and encode C pattern as hex
      const cBits = generateCPattern(sample.C_pattern, sample.lambda);
      const cHex = bitsToHex(cBits);
      document.getElementById('dataC').value = cHex.slice(0, 40) + '...';

      // Store full pattern for encoding
      window.currentCBits = cBits;
      window.currentCoherence = sample.coherence;

      // Update status
      showStatus('encodeStatus',
        `Loaded sample: ${sample.name}<br>` +
        `<span class="muted">${sample.description}</span><br>` +
        `Lambda: Œπ=${sample.lambda.iota.toFixed(2)} Œæ=${sample.lambda.xi.toFixed(2)} ` +
        `Œ∏=${sample.lambda.theta.toFixed(2)} œâ=${sample.lambda.omega.toFixed(2)} ` +
        `Œ¥=${sample.lambda.delta.toFixed(2)} œÉ=${sample.lambda.sigma.toFixed(2)}`,
        'info'
      );

      // Visualize lambda state
      visualizeLambda(sample.lambda);
    }

    // Visualize lambda state in channel stats
    function visualizeLambda(lambda) {
      // Map lambda to channel stats (approximate)
      document.getElementById('statR').style.height = (lambda.theta * 100) + '%';
      document.getElementById('statG').style.height = (lambda.iota * 100) + '%';
      document.getElementById('statB').style.height = (lambda.delta * 100) + '%';
      document.getElementById('statC').style.height = (lambda.omega * 100) + '%';
      document.getElementById('statM').style.height = (lambda.xi * 100) + '%';
      document.getElementById('statY').style.height = (lambda.sigma * 100) + '%';
    }

    // Generate default test image (gradient with LIMNUS geometry)
    function generateTestImage(width = 20, height = 10) {
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');

      // Create gradient based on z-coordinate (LIMNUS prism)
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const z = y / height;  // z from 0 to 1
          const angle = (x / width) * Math.PI * 2;

          // RGB based on z-position and angle
          const r = Math.floor(255 * (1 - z) * (0.5 + 0.5 * Math.cos(angle)));
          const g = Math.floor(255 * z * (0.5 + 0.5 * Math.sin(angle)));
          const b = Math.floor(255 * Math.abs(z - 0.866)); // Peak at z_c

          ctx.fillStyle = `rgb(${r},${g},${b})`;
          ctx.fillRect(x, y, 1, 1);
        }
      }

      return canvas;
    }

    // ============================================
    // UTILITY FUNCTIONS
    // ============================================

    // CRC-8 calculation (polynomial 0x07)
    function crc8(data) {
      let crc = 0;
      for (const byte of data) {
        crc ^= byte;
        for (let i = 0; i < 8; i++) {
          crc = (crc & 0x80) ? ((crc << 1) ^ 0x07) : (crc << 1);
          crc &= 0xFF;
        }
      }
      return crc;
    }

    // Hamming(7,4) encoder for XCVI
    function hammingEncode(data4bits) {
      const d = [
        (data4bits >> 3) & 1,
        (data4bits >> 2) & 1,
        (data4bits >> 1) & 1,
        data4bits & 1
      ];
      const p1 = d[0] ^ d[1] ^ d[3];
      const p2 = d[0] ^ d[2] ^ d[3];
      const p4 = d[1] ^ d[2] ^ d[3];
      return (p1 << 6) | (p2 << 5) | (d[0] << 4) | (p4 << 3) | (d[1] << 2) | (d[2] << 1) | d[3];
    }

    // Hamming(7,4) decoder with error correction
    function hammingDecode(data7bits) {
      const bits = [];
      for (let i = 6; i >= 0; i--) {
        bits.push((data7bits >> i) & 1);
      }
      // bits = [p1, p2, d1, p4, d2, d3, d4]

      const s1 = bits[0] ^ bits[2] ^ bits[4] ^ bits[6];
      const s2 = bits[1] ^ bits[2] ^ bits[5] ^ bits[6];
      const s4 = bits[3] ^ bits[4] ^ bits[5] ^ bits[6];

      const errorPos = s1 + (s2 << 1) + (s4 << 2);

      if (errorPos > 0 && errorPos <= 7) {
        bits[errorPos - 1] ^= 1; // Correct the error
      }

      return (bits[2] << 3) | (bits[4] << 2) | (bits[5] << 1) | bits[6];
    }

    // Convert number to bit array
    function toBits(num, length) {
      const bits = [];
      for (let i = length - 1; i >= 0; i--) {
        bits.push((num >> i) & 1);
      }
      return bits;
    }

    // Convert bit array to number
    function fromBits(bits) {
      let num = 0;
      for (const bit of bits) {
        num = (num << 1) | bit;
      }
      return num;
    }

    // Convert hex string to bit array
    function hexToBits(hex, length) {
      const bits = [];
      const cleanHex = hex.replace(/[^0-9a-fA-F]/g, '');
      for (const char of cleanHex) {
        const val = parseInt(char, 16);
        for (let i = 3; i >= 0; i--) {
          bits.push((val >> i) & 1);
        }
      }
      while (bits.length < length) bits.push(0);
      return bits.slice(0, length);
    }

    // Convert bit array to hex string
    function bitsToHex(bits) {
      let hex = '';
      for (let i = 0; i < bits.length; i += 4) {
        const nibble = bits.slice(i, i + 4);
        while (nibble.length < 4) nibble.push(0);
        hex += fromBits(nibble).toString(16);
      }
      return hex;
    }

    // ============================================
    // MRP HEADER
    // ============================================

    function createHeader(coherence = 0x28) {  // Default coherence ~0.15
      const header = new Uint8Array(4);
      header[0] = MRP.MAGIC;
      header[1] = (MRP.VERSION << 4) | 0x0;  // Version + flags
      header[2] = coherence;
      header[3] = crc8(header.slice(0, 3));
      return header;
    }

    function validateHeader(header) {
      if (header[0] !== MRP.MAGIC) return { valid: false, error: 'Invalid magic byte' };
      const version = header[1] >> 4;
      if (version !== MRP.VERSION) return { valid: false, error: `Version mismatch: ${version}` };
      const expectedCrc = crc8(header.slice(0, 3));
      if (header[3] !== expectedCrc) return { valid: false, error: 'CRC mismatch' };
      return { valid: true, coherence: header[2], flags: header[1] & 0x0F };
    }

    // ============================================
    // ENCODER
    // ============================================

    function encodeStates(imageData, states) {
      const data = imageData.data;
      const width = imageData.width;
      const height = imageData.height;
      const totalPixels = width * height;

      if (totalPixels < MRP.MIN_PIXELS) {
        throw new Error(`Image too small. Need at least ${MRP.MIN_PIXELS} pixels, have ${totalPixels}`);
      }

      // Prepare bit streams for each state
      const streams = {
        R: toBits(states.XCVI || 0, MRP.BITS.XCVI),
        G: toBits(states.XCVII || 0, MRP.BITS.XCVII),
        B: toBits(states.XCVIII || 0, MRP.BITS.XCVIII),
        C: toBits(states.XCIX || 0, MRP.BITS.XCIX),
        M: states.C_A || new Array(MRP.BITS.C_A).fill(0),
        Y: states.C_B || new Array(MRP.BITS.C_B).fill(0)
      };

      // Apply Hamming encoding to XCVI
      const xcviHamming = hammingEncode(states.XCVI || 0);
      streams.R = toBits(xcviHamming, 7);

      // Create header
      const header = createHeader(Math.floor((states.coherence || 0.15) * 255));
      const headerBits = [];
      for (const byte of header) {
        headerBits.push(...toBits(byte, 8));
      }

      // Encode header into first pixels
      let pixelIdx = 0;
      let bitIdx = 0;

      // Header: 32 bits across first ~6 pixels (using all 6 channels)
      for (let i = 0; i < 32 && pixelIdx < totalPixels; i++) {
        const channelOffset = i % 3;
        const bit = headerBits[i];

        data[pixelIdx * 4 + channelOffset] = (data[pixelIdx * 4 + channelOffset] & 0xFE) | bit;

        if (channelOffset === 2) pixelIdx++;
      }

      // Reset for main encoding
      pixelIdx = 6;  // Start after header
      const indices = { R: 0, G: 0, B: 0, C: 0, M: 0, Y: 0 };

      // Encode main data in serpentine pattern
      while (pixelIdx < totalPixels) {
        const row = Math.floor(pixelIdx / width);
        const col = (row % 2 === 0) ? (pixelIdx % width) : (width - 1 - (pixelIdx % width));
        const actualIdx = row * width + col;

        if (actualIdx * 4 + 3 >= data.length) break;

        // R channel - XCVI
        if (indices.R < streams.R.length) {
          data[actualIdx * 4] = (data[actualIdx * 4] & 0xFE) | streams.R[indices.R++];
        }

        // G channel - XCVII
        if (indices.G < streams.G.length) {
          data[actualIdx * 4 + 1] = (data[actualIdx * 4 + 1] & 0xFE) | streams.G[indices.G++];
        }

        // B channel - XCVIII
        if (indices.B < streams.B.length) {
          data[actualIdx * 4 + 2] = (data[actualIdx * 4 + 2] & 0xFE) | streams.B[indices.B++];
        }

        // CMY channels (encoded via RGB manipulation)
        // C (Cyan) = 255 - R, so we modify R's upper bits
        if (indices.C < streams.C.length) {
          const rVal = data[actualIdx * 4];
          const cBit = streams.C[indices.C++];
          // Encode in bit 1 of R (second LSB)
          data[actualIdx * 4] = (rVal & 0xFD) | (cBit << 1);
        }

        // M (Magenta) = 255 - G
        if (indices.M < streams.M.length) {
          const gVal = data[actualIdx * 4 + 1];
          const mBit = streams.M[indices.M++];
          data[actualIdx * 4 + 1] = (gVal & 0xFD) | (mBit << 1);
        }

        // Y (Yellow) = 255 - B
        if (indices.Y < streams.Y.length) {
          const bVal = data[actualIdx * 4 + 2];
          const yBit = streams.Y[indices.Y++];
          data[actualIdx * 4 + 2] = (bVal & 0xFD) | (yBit << 1);
        }

        pixelIdx++;
      }

      return {
        success: true,
        bitsEncoded: {
          R: indices.R,
          G: indices.G,
          B: indices.B,
          C: indices.C,
          M: indices.M,
          Y: indices.Y
        },
        totalBits: Object.values(indices).reduce((a, b) => a + b, 0) + 32,
        streams
      };
    }

    // ============================================
    // DECODER
    // ============================================

    function decodeStates(imageData) {
      const data = imageData.data;
      const width = imageData.width;
      const height = imageData.height;
      const totalPixels = width * height;

      // Extract header (first 32 bits from first ~6 pixels)
      const headerBits = [];
      let pixelIdx = 0;

      for (let i = 0; i < 32; i++) {
        const channelOffset = i % 3;
        headerBits.push(data[pixelIdx * 4 + channelOffset] & 1);
        if (channelOffset === 2) pixelIdx++;
      }

      // Reconstruct header bytes
      const header = new Uint8Array(4);
      for (let i = 0; i < 4; i++) {
        header[i] = fromBits(headerBits.slice(i * 8, (i + 1) * 8));
      }

      // Validate header
      const validation = validateHeader(header);
      if (!validation.valid) {
        return { success: false, error: validation.error };
      }

      // Initialize stream buffers
      const streams = {
        R: [], G: [], B: [], C: [], M: [], Y: []
      };

      // Decode main data
      pixelIdx = 6;  // Skip header pixels

      while (pixelIdx < totalPixels) {
        const row = Math.floor(pixelIdx / width);
        const col = (row % 2 === 0) ? (pixelIdx % width) : (width - 1 - (pixelIdx % width));
        const actualIdx = row * width + col;

        if (actualIdx * 4 + 3 >= data.length) break;

        // R channel LSB - XCVI
        if (streams.R.length < MRP.BITS.XCVI) {
          streams.R.push(data[actualIdx * 4] & 1);
        }

        // G channel LSB - XCVII
        if (streams.G.length < MRP.BITS.XCVII) {
          streams.G.push(data[actualIdx * 4 + 1] & 1);
        }

        // B channel LSB - XCVIII
        if (streams.B.length < MRP.BITS.XCVIII) {
          streams.B.push(data[actualIdx * 4 + 2] & 1);
        }

        // C channel (R bit 1) - XCIX
        if (streams.C.length < MRP.BITS.XCIX) {
          streams.C.push((data[actualIdx * 4] >> 1) & 1);
        }

        // M channel (G bit 1) - C_A
        if (streams.M.length < MRP.BITS.C_A) {
          streams.M.push((data[actualIdx * 4 + 1] >> 1) & 1);
        }

        // Y channel (B bit 1) - C_B
        if (streams.Y.length < MRP.BITS.C_B) {
          streams.Y.push((data[actualIdx * 4 + 2] >> 1) & 1);
        }

        pixelIdx++;
      }

      // Decode values
      const xcviRaw = fromBits(streams.R);
      const xcviCorrected = hammingDecode(xcviRaw);

      return {
        success: true,
        header: {
          magic: header[0],
          version: header[1] >> 4,
          flags: header[1] & 0x0F,
          coherence: header[2] / 255,
          crc: header[3]
        },
        states: {
          XCVI: xcviCorrected,
          XCVII: fromBits(streams.G),
          XCVIII: fromBits(streams.B),
          XCIX: fromBits(streams.C),
          C_A: bitsToHex(streams.M),
          C_B: bitsToHex(streams.Y),
          C_FULL: bitsToHex([...streams.M, ...streams.Y])
        },
        streams,
        bitsDecoded: {
          R: streams.R.length,
          G: streams.G.length,
          B: streams.B.length,
          C: streams.C.length,
          M: streams.M.length,
          Y: streams.Y.length
        }
      };
    }

    // ============================================
    // UI FUNCTIONS
    // ============================================

    let sourceImage = null;
    let encodedImage = null;
    let decodeSourceImage = null;

    function switchTab(tabId) {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

      document.querySelector(`.tab:nth-child(${tabId === 'encode' ? 1 : tabId === 'decode' ? 2 : 3})`).classList.add('active');
      document.getElementById(`tab-${tabId}`).classList.add('active');
    }

    function loadSourceImage(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(e) {
        const img = new Image();
        img.onload = function() {
          sourceImage = img;
          const canvas = document.getElementById('sourceCanvas');
          const ctx = canvas.getContext('2d');
          canvas.width = img.width;
          canvas.height = img.height;
          ctx.drawImage(img, 0, 0);

          document.getElementById('sourceHint').style.display = 'none';
          document.getElementById('encodeBtn').disabled = false;

          showStatus('encodeStatus', `Image loaded: ${img.width}√ó${img.height} (${img.width * img.height} pixels)`, 'info');
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }

    function loadDecodeImage(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(e) {
        const img = new Image();
        img.onload = function() {
          decodeSourceImage = img;
          const canvas = document.getElementById('decodeCanvas');
          const ctx = canvas.getContext('2d');
          canvas.width = img.width;
          canvas.height = img.height;
          ctx.drawImage(img, 0, 0);

          document.getElementById('decodeHint').style.display = 'none';
          document.getElementById('decodeBtn').disabled = false;

          showStatus('decodeStatus', `Image loaded: ${img.width}√ó${img.height}`, 'info');
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }

    function encodeImage() {
      if (!sourceImage) return;

      const canvas = document.getElementById('sourceCanvas');
      const ctx = canvas.getContext('2d');
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

      // Get input values
      const states = {
        XCVI: parseInt(document.getElementById('dataXCVI').value) || Math.floor(Math.random() * 128),
        XCVII: parseInt(document.getElementById('dataXCVII').value) || Math.floor(Math.random() * 1024),
        XCVIII: parseInt(document.getElementById('dataXCVIII').value) || Math.floor(Math.random() * 131072),
        XCIX: parseInt(document.getElementById('dataXCIX').value) || Math.floor(Math.random() * 16),
        coherence: 0.15
      };

      // Generate C data from hex or random
      const cHex = document.getElementById('dataC').value;
      if (cHex) {
        const cBits = hexToBits(cHex, 664);
        states.C_A = cBits.slice(0, 332);
        states.C_B = cBits.slice(332);
      } else {
        states.C_A = new Array(332).fill(0).map(() => Math.round(Math.random()));
        states.C_B = new Array(332).fill(0).map(() => Math.round(Math.random()));
      }

      try {
        const result = encodeStates(imageData, states);

        // Draw encoded image
        const outputCanvas = document.getElementById('outputCanvas');
        outputCanvas.width = canvas.width;
        outputCanvas.height = canvas.height;
        const outCtx = outputCanvas.getContext('2d');
        outCtx.putImageData(imageData, 0, 0);

        document.getElementById('outputHint').style.display = 'none';
        document.getElementById('downloadBtn').disabled = false;
        encodedImage = outputCanvas;

        // Update stats
        updateChannelStats(result.bitsEncoded);
        updateBitStream(result.streams);

        showStatus('encodeStatus',
          `Encoded ${result.totalBits} bits successfully! ` +
          `XCVI=${states.XCVI}, XCVII=${states.XCVII}, XCVIII=${states.XCVIII}, XCIX=${states.XCIX}`,
          'success'
        );
      } catch (error) {
        showStatus('encodeStatus', error.message, 'error');
      }
    }

    function decodeImage() {
      if (!decodeSourceImage) return;

      const canvas = document.getElementById('decodeCanvas');
      const ctx = canvas.getContext('2d');
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

      const result = decodeStates(imageData);

      if (!result.success) {
        showStatus('decodeStatus', `Decode failed: ${result.error}`, 'error');
        document.getElementById('decodedResults').innerHTML = `<p class="muted">Failed to decode: ${result.error}</p>`;
        return;
      }

      // Display results
      const resultsHtml = `
        <div style="margin-bottom:16px">
          <span class="state-indicator state-xcvi">XCVI</span>
          <span style="font-family:monospace;font-size:1.5rem;margin-left:8px">${result.states.XCVI}</span>
          <span class="muted small" style="margin-left:8px">(7 bits, Hamming corrected)</span>
        </div>
        <div style="margin-bottom:16px">
          <span class="state-indicator state-xcvii">XCVII</span>
          <span style="font-family:monospace;font-size:1.5rem;margin-left:8px">${result.states.XCVII}</span>
          <span class="muted small" style="margin-left:8px">(10 bits)</span>
        </div>
        <div style="margin-bottom:16px">
          <span class="state-indicator state-xcviii">XCVIII</span>
          <span style="font-family:monospace;font-size:1.5rem;margin-left:8px">${result.states.XCVIII}</span>
          <span class="muted small" style="margin-left:8px">(17 bits)</span>
        </div>
        <div style="margin-bottom:16px">
          <span class="state-indicator state-xcix">XCIX</span>
          <span style="font-family:monospace;font-size:1.5rem;margin-left:8px">${result.states.XCIX}</span>
          <span class="muted small" style="margin-left:8px">(4 bits)</span>
        </div>
        <div style="margin-bottom:16px">
          <span class="state-indicator state-c">C</span>
          <div style="font-family:monospace;font-size:0.8rem;word-break:break-all;margin-top:4px;padding:8px;background:rgba(0,0,0,.3);border-radius:4px">
            ${result.states.C_FULL.slice(0, 80)}...
          </div>
          <span class="muted small">(664 bits)</span>
        </div>
        <div style="margin-top:16px;padding:12px;background:rgba(255,215,0,.1);border-radius:8px">
          <strong>Header:</strong> Magic=0x${result.header.magic.toString(16).toUpperCase()},
          Version=${result.header.version},
          Coherence=${result.header.coherence.toFixed(3)},
          CRC=0x${result.header.crc.toString(16).toUpperCase()}
        </div>
      `;

      document.getElementById('decodedResults').innerHTML = resultsHtml;
      updateChannelStats(result.bitsDecoded);
      updateBitStream(result.streams);

      showStatus('decodeStatus', `Decoded ${Object.values(result.bitsDecoded).reduce((a,b)=>a+b,0) + 32} bits successfully!`, 'success');
    }

    function downloadEncoded() {
      if (!encodedImage) return;

      const link = document.createElement('a');
      link.download = 'mrp-encoded.png';
      link.href = encodedImage.toDataURL('image/png');
      link.click();
    }

    function clearSource() {
      sourceImage = null;
      const canvas = document.getElementById('sourceCanvas');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      canvas.width = 0;
      canvas.height = 0;
      document.getElementById('sourceHint').style.display = 'block';
      document.getElementById('encodeBtn').disabled = true;
      document.getElementById('encodeStatus').innerHTML = '';
    }

    function showStatus(elementId, message, type) {
      const el = document.getElementById(elementId);
      el.innerHTML = `<div class="status status-${type}">${message}</div>`;
    }

    function updateChannelStats(bits) {
      const maxBits = Math.max(...Object.values(MRP.BITS));
      document.getElementById('statR').style.height = (bits.R / MRP.BITS.XCVI * 100) + '%';
      document.getElementById('statG').style.height = (bits.G / MRP.BITS.XCVII * 100) + '%';
      document.getElementById('statB').style.height = (bits.B / MRP.BITS.XCVIII * 100) + '%';
      document.getElementById('statC').style.height = (bits.C / MRP.BITS.XCIX * 100) + '%';
      document.getElementById('statM').style.height = (bits.M / MRP.BITS.C_A * 100) + '%';
      document.getElementById('statY').style.height = (bits.Y / MRP.BITS.C_B * 100) + '%';
    }

    function updateBitStream(streams) {
      const allBits = [
        ...streams.R.map(b => `<span class="bit-${b}" style="color:var(--red)">${b}</span>`),
        ...streams.G.map(b => `<span class="bit-${b}" style="color:var(--green)">${b}</span>`),
        ...streams.B.map(b => `<span class="bit-${b}" style="color:var(--blue)">${b}</span>`),
        ...streams.C.map(b => `<span class="bit-${b}" style="color:var(--cyan)">${b}</span>`),
        ...streams.M.slice(0, 50).map(b => `<span class="bit-${b}" style="color:var(--magenta)">${b}</span>`),
        '...',
        ...streams.Y.slice(0, 50).map(b => `<span class="bit-${b}" style="color:var(--yellow)">${b}</span>`),
        '...'
      ];

      document.getElementById('bitStream').innerHTML = allBits.join('');
    }

    // Drag and drop support
    ['sourceContainer', 'decodeContainer'].forEach(id => {
      const container = document.getElementById(id);

      container.addEventListener('dragover', (e) => {
        e.preventDefault();
        container.classList.add('drag-over');
      });

      container.addEventListener('dragleave', () => {
        container.classList.remove('drag-over');
      });

      container.addEventListener('drop', (e) => {
        e.preventDefault();
        container.classList.remove('drag-over');

        const file = e.dataTransfer.files[0];
        if (file && file.type.startsWith('image/')) {
          const input = document.getElementById(id === 'sourceContainer' ? 'sourceInput' : 'decodeInput');
          const dt = new DataTransfer();
          dt.items.add(file);
          input.files = dt.files;
          input.dispatchEvent(new Event('change'));
        }
      });

      container.addEventListener('click', () => {
        const inputId = id === 'sourceContainer' ? 'sourceInput' : 'decodeInput';
        document.getElementById(inputId).click();
      });
    });

    // Load test image generator
    function loadTestImage() {
      const canvas = generateTestImage(20, 10);
      sourceImage = new Image();

      canvas.toBlob(function(blob) {
        const url = URL.createObjectURL(blob);
        sourceImage.onload = function() {
          const srcCanvas = document.getElementById('sourceCanvas');
          srcCanvas.width = sourceImage.width;
          srcCanvas.height = sourceImage.height;
          const ctx = srcCanvas.getContext('2d');
          ctx.drawImage(sourceImage, 0, 0);

          document.getElementById('sourceHint').style.display = 'none';
          document.getElementById('encodeBtn').disabled = false;

          showStatus('encodeStatus',
            `Generated LIMNUS gradient test image: ${sourceImage.width}√ó${sourceImage.height} (${sourceImage.width * sourceImage.height} pixels)`,
            'success'
          );
        };
        sourceImage.src = url;
      });
    }

    // Override encodeImage to use stored C bits from golden samples
    const originalEncodeImage = encodeImage;
    encodeImage = function() {
      if (!sourceImage) return;

      const canvas = document.getElementById('sourceCanvas');
      const ctx = canvas.getContext('2d');
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

      // Get input values
      const states = {
        XCVI: parseInt(document.getElementById('dataXCVI').value) || Math.floor(Math.random() * 128),
        XCVII: parseInt(document.getElementById('dataXCVII').value) || Math.floor(Math.random() * 1024),
        XCVIII: parseInt(document.getElementById('dataXCVIII').value) || Math.floor(Math.random() * 131072),
        XCIX: parseInt(document.getElementById('dataXCIX').value) || Math.floor(Math.random() * 16),
        coherence: window.currentCoherence || 0.15
      };

      // Use stored C bits from golden sample if available
      if (window.currentCBits) {
        states.C_A = window.currentCBits.slice(0, 332);
        states.C_B = window.currentCBits.slice(332);
      } else {
        // Generate C data from hex or random
        const cHex = document.getElementById('dataC').value;
        if (cHex && !cHex.includes('...')) {
          const cBits = hexToBits(cHex, 664);
          states.C_A = cBits.slice(0, 332);
          states.C_B = cBits.slice(332);
        } else {
          states.C_A = new Array(332).fill(0).map(() => Math.round(Math.random()));
          states.C_B = new Array(332).fill(0).map(() => Math.round(Math.random()));
        }
      }

      try {
        const result = encodeStates(imageData, states);

        // Draw encoded image
        const outputCanvas = document.getElementById('outputCanvas');
        outputCanvas.width = canvas.width;
        outputCanvas.height = canvas.height;
        const outCtx = outputCanvas.getContext('2d');
        outCtx.putImageData(imageData, 0, 0);

        document.getElementById('outputHint').style.display = 'none';
        document.getElementById('downloadBtn').disabled = false;
        encodedImage = outputCanvas;

        // Update stats
        updateChannelStats(result.bitsEncoded);
        updateBitStream(result.streams);

        showStatus('encodeStatus',
          `Encoded ${result.totalBits} bits successfully! ` +
          `XCVI=${states.XCVI}, XCVII=${states.XCVII}, XCVIII=${states.XCVIII}, XCIX=${states.XCIX}, ` +
          `coherence=${states.coherence.toFixed(2)}`,
          'success'
        );
      } catch (error) {
        showStatus('encodeStatus', error.message, 'error');
      }
    };

    // ============================================
    // GOLDEN LIBRARY BROWSER
    // Load and display samples from mrp-golden-library.json
    // ============================================

    let goldenLibrary = null;
    let allLibrarySamples = [];
    let currentCategory = 'all';
    let selectedSample = null;

    // Load the golden library
    async function loadGoldenLibrary() {
      try {
        const response = await fetch('mrp-golden-library.json');
        if (!response.ok) throw new Error('Failed to load library');
        goldenLibrary = await response.json();
        processLibrarySamples();
        renderLibrarySamples();
        setupLibraryFilters();
        console.log(`Golden library loaded: ${allLibrarySamples.length} samples`);
      } catch (error) {
        console.error('Error loading golden library:', error);
        document.getElementById('goldenSamplesGrid').innerHTML = `
          <div class="loading-samples" style="color:var(--error)">
            Failed to load golden library. Using built-in samples.
          </div>
        `;
        // Fall back to built-in GOLDEN_SAMPLES
        renderBuiltinSamples();
      }
    }

    // Process library samples into flat array
    function processLibrarySamples() {
      allLibrarySamples = [];

      const categories = [
        'lambda_singles', 'lambda_pairs', 'lambda_triplets', 'lambda_quads',
        'lambda_quints', 'lambda_uniform', 'physics_constants', 'kuramoto_sweep',
        'coherence_sweep', 'eigenvalue_states', 'fibonacci_sequence',
        'topological_invariants', 'oscillation_bands', 'phase_locked_states',
        'hamming_test_vectors', 'bit_patterns'
      ];

      for (const cat of categories) {
        if (goldenLibrary.samples && goldenLibrary.samples[cat]) {
          const samples = goldenLibrary.samples[cat];
          for (const sample of samples) {
            allLibrarySamples.push({
              ...sample,
              category: cat
            });
          }
        }
      }
    }

    // Render library samples grid
    function renderLibrarySamples(filter = 'all', searchQuery = '') {
      const grid = document.getElementById('goldenSamplesGrid');

      let filtered = allLibrarySamples;

      // Apply category filter
      if (filter !== 'all') {
        filtered = filtered.filter(s => s.category === filter);
      }

      // Apply search
      if (searchQuery) {
        const query = searchQuery.toLowerCase();
        filtered = filtered.filter(s =>
          s.id.toLowerCase().includes(query) ||
          (s.name && s.name.toLowerCase().includes(query))
        );
      }

      if (filtered.length === 0) {
        grid.innerHTML = '<div class="loading-samples">No samples match your search</div>';
        return;
      }

      grid.innerHTML = filtered.map(sample => `
        <div class="sample-card ${selectedSample && selectedSample.id === sample.id ? 'selected' : ''}"
             data-id="${sample.id}"
             onclick="selectLibrarySample('${sample.id}')">
          <img src="mrp-samples/${sample.id}.png" alt="${sample.id}"
               onerror="this.src='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 width=%22100%22 height=%2250%22><rect fill=%22%231a1b1e%22 width=%22100%22 height=%2250%22/><text x=%2250%22 y=%2230%22 fill=%22%23666%22 text-anchor=%22middle%22 font-size=%228%22>${sample.id}</text></svg>'">
          <div class="card-id">${sample.id}</div>
          <div class="card-name">${sample.name || ''}</div>
        </div>
      `).join('');
    }

    // Render built-in samples as fallback
    function renderBuiltinSamples() {
      const grid = document.getElementById('goldenSamplesGrid');
      const samples = Object.entries(GOLDEN_SAMPLES);

      grid.innerHTML = samples.map(([key, sample]) => `
        <div class="sample-card" data-id="${key}" onclick="loadGoldenSample('${key}')">
          <div class="card-id">${key}</div>
          <div class="card-name">${sample.name}</div>
        </div>
      `).join('');
    }

    // Setup filter buttons
    function setupLibraryFilters() {
      const filters = document.getElementById('sampleFilters');
      filters.addEventListener('click', (e) => {
        if (e.target.classList.contains('filter-btn')) {
          // Update active state
          filters.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
          e.target.classList.add('active');

          // Apply filter
          currentCategory = e.target.dataset.category;
          renderLibrarySamples(currentCategory, document.getElementById('sampleSearch').value);
        }
      });

      // Setup search
      const searchInput = document.getElementById('sampleSearch');
      searchInput.addEventListener('input', (e) => {
        renderLibrarySamples(currentCategory, e.target.value);
      });
    }

    // Select a sample from the library
    function selectLibrarySample(sampleId) {
      const sample = allLibrarySamples.find(s => s.id === sampleId);
      if (!sample) return;

      selectedSample = sample;

      // Update card selection state
      document.querySelectorAll('.sample-card').forEach(card => {
        card.classList.toggle('selected', card.dataset.id === sampleId);
      });

      // Show preview panel
      const preview = document.getElementById('selectedSamplePreview');
      preview.style.display = 'block';

      document.getElementById('previewImage').src = `mrp-samples/${sample.id}.png`;
      document.getElementById('previewId').textContent = sample.id;
      document.getElementById('previewName').textContent = sample.name || sample.category;

      // Format lambda state if available
      if (sample.lambda) {
        const lambdaStr = Object.entries(sample.lambda)
          .map(([k, v]) => `${k[0]}=${typeof v === 'number' ? v.toFixed(2) : v}`)
          .join(' ');
        document.getElementById('previewLambda').textContent = `Œª: ${lambdaStr}`;
      } else {
        document.getElementById('previewLambda').textContent = '';
      }

      // Format bits
      if (sample.bits) {
        document.getElementById('previewBits').textContent =
          `XCVI=${sample.bits.XCVI || 0} XCVII=${sample.bits.XCVII || 0} XCVIII=${sample.bits.XCVIII || 0} XCIX=${sample.bits.XCIX || 0}`;
      }

      // Load values into form
      loadLibrarySampleValues(sample);
    }

    // Load sample values into the form
    function loadLibrarySampleValues(sample) {
      if (!sample.bits) return;

      document.getElementById('dataXCVI').value = sample.bits.XCVI || 0;
      document.getElementById('dataXCVII').value = sample.bits.XCVII || 0;
      document.getElementById('dataXCVIII').value = sample.bits.XCVIII || 0;
      document.getElementById('dataXCIX').value = sample.bits.XCIX || 0;

      // Generate C pattern based on sample pattern type
      const patternType = sample.bits.C_pattern || 'balanced';
      const lambda = sample.lambda || { iota: 0.5, xi: 0.5, theta: 0.5, omega: 0.5, delta: 0.5, sigma: 0.5 };
      const cBits = generateCPattern(patternType, lambda);
      const cHex = bitsToHex(cBits);
      document.getElementById('dataC').value = cHex.slice(0, 40) + '...';

      // Store for encoding
      window.currentCBits = cBits;
      window.currentCoherence = sample.coherence || 0.15;

      // Update status
      showStatus('encodeStatus',
        `Loaded: <strong>${sample.id}</strong> - ${sample.name || sample.category}<br>` +
        `<span class="muted">XCVI=${sample.bits.XCVI} XCVII=${sample.bits.XCVII} XCVIII=${sample.bits.XCVIII} XCIX=${sample.bits.XCIX}</span>`,
        'info'
      );

      // Visualize lambda
      if (sample.lambda) {
        visualizeLambda(sample.lambda);
      }
    }

    // Load a random sample
    function loadRandomSample() {
      if (allLibrarySamples.length === 0) {
        // Use built-in
        const keys = Object.keys(GOLDEN_SAMPLES);
        const randomKey = keys[Math.floor(Math.random() * keys.length)];
        loadGoldenSample(randomKey);
      } else {
        const randomSample = allLibrarySamples[Math.floor(Math.random() * allLibrarySamples.length)];
        selectLibrarySample(randomSample.id);
      }
    }

    // Clear sample selection
    function clearSampleSelection() {
      selectedSample = null;
      document.querySelectorAll('.sample-card').forEach(card => card.classList.remove('selected'));
      document.getElementById('selectedSamplePreview').style.display = 'none';

      // Clear form
      document.getElementById('dataXCVI').value = '';
      document.getElementById('dataXCVII').value = '';
      document.getElementById('dataXCVIII').value = '';
      document.getElementById('dataXCIX').value = '';
      document.getElementById('dataC').value = '';

      window.currentCBits = null;
      window.currentCoherence = 0.15;

      document.getElementById('encodeStatus').innerHTML = '';
    }

    // Load sample image as source for encoding
    function loadSampleAsSource(sampleId) {
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = function() {
        sourceImage = img;
        const canvas = document.getElementById('sourceCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);

        document.getElementById('sourceHint').style.display = 'none';
        document.getElementById('encodeBtn').disabled = false;

        showStatus('encodeStatus',
          `Loaded sample image: ${img.width}√ó${img.height} (${img.width * img.height} pixels)`,
          'success'
        );
      };
      img.onerror = function() {
        showStatus('encodeStatus', 'Failed to load sample image', 'error');
      };
      img.src = `mrp-samples/${sampleId}.png`;
    }

    // Function called from library page to load sample in encoder
    function loadInEncoder(sampleId) {
      const sample = allLibrarySamples.find(s => s.id === sampleId);
      if (sample) {
        selectLibrarySample(sampleId);
        loadSampleAsSource(sampleId);
      }
    }

    // Initialize
    console.log('MRP Encoder/Decoder initialized');
    console.log(`Total bits: ${MRP.TOTAL_BITS}, Minimum pixels: ${MRP.MIN_PIXELS}`);
    console.log(`Built-in golden samples: ${Object.keys(GOLDEN_SAMPLES).length}`);
    console.log(`Lambda state components: ${Object.keys(LAMBDA.components).join(', ')}`);

    // Load golden library on page load
    loadGoldenLibrary();
  </script>
</body>
</html>
