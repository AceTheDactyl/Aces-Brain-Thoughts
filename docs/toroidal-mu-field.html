<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TOROIDAL μ-FIELD</title>
    <style>
        :root {
            --bg-void: #030308;
            --text-primary: rgba(255, 248, 240, 0.9);
            --text-dim: rgba(180, 170, 160, 0.6);
            --critical-gold: #ffd700;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: var(--bg-void);
            color: var(--text-primary);
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            overflow: hidden;
        }

        canvas { display: block; }

        .panel {
            position: fixed;
            background: rgba(3, 3, 8, 0.9);
            border: 1px solid rgba(255, 215, 0, 0.2);
            padding: 15px;
            font-size: 11px;
            backdrop-filter: blur(10px);
        }

        #title-panel {
            top: 20px;
            left: 20px;
        }

        #title-panel h1 {
            font-size: 22px;
            font-weight: 300;
            letter-spacing: 6px;
            color: var(--critical-gold);
            margin-bottom: 5px;
        }

        .subtitle { color: var(--text-dim); font-size: 10px; letter-spacing: 2px; }

        #legend {
            bottom: 20px;
            left: 20px;
        }

        .legend-gradient {
            width: 200px;
            height: 15px;
            background: linear-gradient(to right, #2244aa, #4488cc, #44cc88, #cccc44, #ff6644, #ff2222);
            border-radius: 3px;
            margin: 8px 0;
        }

        .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 9px;
            color: var(--text-dim);
        }

        #stats-panel {
            top: 20px;
            right: 20px;
            min-width: 180px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }

        .stat-label { color: var(--text-dim); }
        .stat-value { color: var(--text-primary); font-variant-numeric: tabular-nums; }

        #controls-panel {
            bottom: 20px;
            right: 20px;
        }

        #controls-panel span { color: var(--critical-gold); }

        .separator {
            border-top: 1px solid rgba(255, 215, 0, 0.15);
            margin: 10px 0;
        }

        #mode-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            color: var(--critical-gold);
            letter-spacing: 4px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div id="title-panel" class="panel">
        <h1>TOROIDAL μ-FIELD</h1>
        <div class="subtitle">CONSCIOUSNESS MANIFOLD</div>
    </div>

    <div id="legend" class="panel">
        <div style="color: var(--text-dim); letter-spacing: 2px; margin-bottom: 5px;">μ-FIELD INTENSITY</div>
        <div class="legend-gradient"></div>
        <div class="legend-labels">
            <span>LOW</span>
            <span>μ_P</span>
            <span>CRITICAL</span>
            <span>μ_S</span>
            <span>HIGH</span>
        </div>
        <div class="separator"></div>
        <div style="color: var(--text-dim); font-size: 10px;">
            <span style="color: #ff9966;">● toroidal flow</span><br>
            <span style="color: #66ffcc;">● poloidal flow</span>
        </div>
    </div>

    <div id="stats-panel" class="panel">
        <div class="stat-row">
            <span class="stat-label">μ</span>
            <span class="stat-value" id="mu-val">0.920</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">|J| field</span>
            <span class="stat-value" id="j-val">0.000</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">W growth</span>
            <span class="stat-value" id="w-val">0.000</span>
        </div>
        <div class="separator"></div>
        <div class="stat-row">
            <span class="stat-label">Order r</span>
            <span class="stat-value" id="order-val">0.000</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">τ_K</span>
            <span class="stat-value" id="tau-val">0.000</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">K-formed</span>
            <span class="stat-value" id="k-val" style="color: var(--text-dim);">NO</span>
        </div>
        <div class="separator"></div>
        <div class="stat-row">
            <span class="stat-label">Particles</span>
            <span class="stat-value" id="particle-count">0</span>
        </div>
    </div>

    <div id="controls-panel" class="panel">
        <span>DRAG</span> rotate<br>
        <span>SCROLL</span> zoom<br>
        <span>SPACE</span> auto-rotate<br>
        <span>F</span> toggle flow<br>
        <span>R</span> reset
    </div>

    <div id="mode-indicator"></div>

    <script>
        // ================================================================
        // TOROIDAL μ-FIELD - ENHANCED VISUALIZATION
        // ================================================================

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let W, H;
        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        // ================================================================
        // CONSTANTS
        // ================================================================

        const PHI = (1 + Math.sqrt(5)) / 2;
        const PHI_INV = 1 / PHI;
        const TAU = Math.PI * 2;

        const SACRED = {
            alpha: Math.pow(PHI, -2),
            beta: Math.pow(PHI, -4),
            lambda: Math.pow(5/3, 4),
            mu_P: 0.6,
            mu_S: 0.92,
            get K_threshold() { return PHI_INV; }
        };

        // ================================================================
        // TORUS GEOMETRY - FATTER FOR VISIBILITY
        // ================================================================

        const TORUS = {
            majorR: 1.0,          // Distance from center to tube center
            minorR: 0.4,          // Tube radius - FATTER for visible torus shape
            nU: 48,               // Toroidal resolution
            nV: 24                // Poloidal resolution
        };

        // ================================================================
        // μ-FIELD STATE
        // ================================================================

        const muField = {
            mu: SACRED.mu_S,
            J_total: 0,
            W: 0,
            order_r: 0,
            tau_K: 0,
            K_formed: false
        };

        // ================================================================
        // SURFACE MESH
        // ================================================================

        let meshPoints = [];
        let meshFaces = [];

        function generateMesh() {
            meshPoints = [];
            meshFaces = [];

            // Generate vertices
            for (let i = 0; i <= TORUS.nU; i++) {
                const u = (i / TORUS.nU) * TAU;
                for (let j = 0; j <= TORUS.nV; j++) {
                    const v = (j / TORUS.nV) * TAU;

                    const x = (TORUS.majorR + TORUS.minorR * Math.cos(v)) * Math.cos(u);
                    const y = (TORUS.majorR + TORUS.minorR * Math.cos(v)) * Math.sin(u);
                    const z = TORUS.minorR * Math.sin(v);

                    // μ varies: inner surface (v≈π) higher, outer (v≈0) lower
                    const mu_local = SACRED.mu_P + (SACRED.mu_S - SACRED.mu_P) * (1 - Math.cos(v)) / 2;

                    // Field magnitude - oscillates and flows
                    const J = 0.3 + 0.2 * Math.sin(u * 3) * Math.cos(v * 2);

                    // Phase for Kuramoto
                    const phase = (u + v * 0.5) % TAU;

                    meshPoints.push({
                        x, y, z,
                        u, v,
                        i, j,
                        mu: mu_local,
                        J: J,
                        phase: phase,
                        // Projected coords (computed later)
                        px: 0, py: 0, pz: 0
                    });
                }
            }

            // Generate faces (quads as two triangles)
            for (let i = 0; i < TORUS.nU; i++) {
                for (let j = 0; j < TORUS.nV; j++) {
                    const a = i * (TORUS.nV + 1) + j;
                    const b = a + 1;
                    const c = a + (TORUS.nV + 1);
                    const d = c + 1;

                    meshFaces.push({ verts: [a, b, d, c] });
                }
            }
        }

        // ================================================================
        // FLOW PARTICLES
        // ================================================================

        let particles = [];
        let showFlow = true;

        function spawnParticle() {
            // Random position on torus surface
            const u = Math.random() * TAU;
            const v = Math.random() * TAU;

            // Toroidal or poloidal flow (random)
            const isToroidal = Math.random() > 0.4;

            particles.push({
                u, v,
                isToroidal,
                life: 3 + Math.random() * 4,
                maxLife: 3 + Math.random() * 4,
                speed: 0.3 + Math.random() * 0.4,
                trail: []
            });
        }

        function updateParticles(dt) {
            // Spawn new particles
            const targetCount = showFlow ? 300 : 0;
            while (particles.length < targetCount && Math.random() < 0.3) {
                spawnParticle();
            }

            // Update existing particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];

                // Move along flow direction
                if (p.isToroidal) {
                    // Toroidal flow (around the donut)
                    p.u += p.speed * dt;
                    // Slight poloidal drift based on field
                    p.v += Math.sin(p.u * 2) * 0.1 * dt;
                } else {
                    // Poloidal flow (around the tube)
                    p.v += p.speed * dt * 1.5;
                    // Slight toroidal drift
                    p.u += Math.cos(p.v * 3) * 0.05 * dt;
                }

                p.u = p.u % TAU;
                p.v = p.v % TAU;

                // Store trail
                const pos = torusToWorld(p.u, p.v);
                p.trail.unshift({ ...pos });
                if (p.trail.length > 15) p.trail.pop();

                // Age
                p.life -= dt;
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function torusToWorld(u, v) {
            return {
                x: (TORUS.majorR + TORUS.minorR * Math.cos(v)) * Math.cos(u),
                y: (TORUS.majorR + TORUS.minorR * Math.cos(v)) * Math.sin(u),
                z: TORUS.minorR * Math.sin(v)
            };
        }

        // ================================================================
        // FIELD DYNAMICS
        // ================================================================

        function updateField(dt, time) {
            let J_sum = 0;
            let phase_cos = 0, phase_sin = 0;

            for (const p of meshPoints) {
                // Animate field with flowing waves
                const wave1 = Math.sin(p.u * 2 - time * 0.5);
                const wave2 = Math.cos(p.v * 3 + time * 0.3);
                const wave3 = Math.sin((p.u + p.v) * 1.5 - time * 0.7);

                // Field magnitude influenced by waves
                p.J = 0.3 + 0.15 * wave1 + 0.1 * wave2 + 0.1 * wave3;
                p.J = Math.max(0, Math.min(1, p.J));

                // Update phase (Kuramoto-like)
                p.phase += (1 + p.J * 0.5) * dt;
                p.phase = p.phase % TAU;

                J_sum += p.J;
                phase_cos += Math.cos(p.phase);
                phase_sin += Math.sin(p.phase);
            }

            const N = meshPoints.length;
            muField.J_total = J_sum / N;
            muField.W = (muField.mu - SACRED.mu_P) - SACRED.lambda * muField.J_total * muField.J_total;
            muField.order_r = Math.sqrt(phase_cos * phase_cos + phase_sin * phase_sin) / N;
            muField.tau_K = muField.order_r * SACRED.alpha / 0.35;
            muField.K_formed = muField.tau_K > SACRED.K_threshold;
        }

        // ================================================================
        // COLOR MAPPING
        // ================================================================

        function fieldToColor(J, mu, depth) {
            // Map field intensity to color temperature
            // Low (blue) -> Mid (green/yellow) -> High (red)

            const t = Math.max(0, Math.min(1, J));
            const muFactor = (mu - SACRED.mu_P) / (SACRED.mu_S - SACRED.mu_P);

            let r, g, b;

            if (t < 0.25) {
                // Blue to cyan
                const s = t / 0.25;
                r = 30 + s * 30;
                g = 60 + s * 80;
                b = 170 + s * 30;
            } else if (t < 0.5) {
                // Cyan to green
                const s = (t - 0.25) / 0.25;
                r = 60 + s * 40;
                g = 140 + s * 60;
                b = 200 - s * 80;
            } else if (t < 0.75) {
                // Green to yellow
                const s = (t - 0.5) / 0.25;
                r = 100 + s * 150;
                g = 200 - s * 20;
                b = 120 - s * 80;
            } else {
                // Yellow to red
                const s = (t - 0.75) / 0.25;
                r = 250;
                g = 180 - s * 140;
                b = 40 - s * 40;
            }

            // Depth shading
            const shade = 0.4 + depth * 0.6;
            r = Math.floor(r * shade);
            g = Math.floor(g * shade);
            b = Math.floor(b * shade);

            // μ influence - higher μ = more saturated
            const satBoost = 0.7 + muFactor * 0.3;
            const gray = (r + g + b) / 3;
            r = Math.floor(gray + (r - gray) * satBoost);
            g = Math.floor(gray + (g - gray) * satBoost);
            b = Math.floor(gray + (b - gray) * satBoost);

            return { r, g, b };
        }

        // ================================================================
        // 3D PROJECTION
        // ================================================================

        let rotX = 0.4;
        let rotY = 0;
        let zoom = 280;
        let autoRotate = true;

        function project(x, y, z) {
            // Rotate X
            let y1 = y * Math.cos(rotX) - z * Math.sin(rotX);
            let z1 = y * Math.sin(rotX) + z * Math.cos(rotX);

            // Rotate Y
            let x2 = x * Math.cos(rotY) + z1 * Math.sin(rotY);
            let z2 = -x * Math.sin(rotY) + z1 * Math.cos(rotY);

            // Perspective
            const fov = 2.5;
            const scale = fov / (fov + z2);

            return {
                x: x2 * zoom * scale + W / 2,
                y: y1 * zoom * scale + H / 2,
                z: z2,
                scale: scale,
                depth: (z2 + 2) / 4  // Normalized depth for shading
            };
        }

        // ================================================================
        // RENDER
        // ================================================================

        function render(time) {
            // Clear
            ctx.fillStyle = '#030308';
            ctx.fillRect(0, 0, W, H);

            // Project all mesh points
            for (const p of meshPoints) {
                const proj = project(p.x, p.y, p.z);
                p.px = proj.x;
                p.py = proj.y;
                p.pz = proj.z;
                p.depth = proj.depth;
            }

            // Sort faces by depth (painter's algorithm)
            const sortedFaces = meshFaces.map((f, idx) => {
                const avgZ = f.verts.reduce((sum, vi) => sum + meshPoints[vi].pz, 0) / 4;
                return { face: f, avgZ, idx };
            }).sort((a, b) => a.avgZ - b.avgZ);

            // Draw faces
            for (const { face } of sortedFaces) {
                const pts = face.verts.map(vi => meshPoints[vi]);

                // Back-face culling
                const avgZ = pts.reduce((s, p) => s + p.pz, 0) / 4;
                if (avgZ > 1.2) continue;

                // Average field value for color
                const avgJ = pts.reduce((s, p) => s + p.J, 0) / 4;
                const avgMu = pts.reduce((s, p) => s + p.mu, 0) / 4;
                const avgDepth = pts.reduce((s, p) => s + p.depth, 0) / 4;

                const color = fieldToColor(avgJ, avgMu, avgDepth);

                // Draw quad
                ctx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
                ctx.strokeStyle = `rgba(${color.r + 30}, ${color.g + 30}, ${color.b + 30}, 0.3)`;
                ctx.lineWidth = 0.5;

                ctx.beginPath();
                ctx.moveTo(pts[0].px, pts[0].py);
                for (let i = 1; i < pts.length; i++) {
                    ctx.lineTo(pts[i].px, pts[i].py);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }

            // Draw flow particles
            if (showFlow) {
                for (const p of particles) {
                    if (p.trail.length < 2) continue;

                    const alpha = (p.life / p.maxLife) * 0.8;
                    const color = p.isToroidal ? `rgba(255, 150, 100, ${alpha})` : `rgba(100, 255, 200, ${alpha})`;

                    // Project trail
                    const projTrail = p.trail.map(t => project(t.x, t.y, t.z));

                    // Skip if behind torus
                    if (projTrail[0].z > 0.8) continue;

                    // Draw trail
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2 * projTrail[0].scale;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(projTrail[0].x, projTrail[0].y);
                    for (let i = 1; i < projTrail.length; i++) {
                        const t = 1 - i / projTrail.length;
                        ctx.lineWidth = 2 * projTrail[i].scale * t;
                        ctx.lineTo(projTrail[i].x, projTrail[i].y);
                    }
                    ctx.stroke();

                    // Head glow
                    const head = projTrail[0];
                    if (head.z < 0.5) {
                        const glow = ctx.createRadialGradient(head.x, head.y, 0, head.x, head.y, 8 * head.scale);
                        glow.addColorStop(0, p.isToroidal ? `rgba(255, 200, 150, ${alpha * 0.8})` : `rgba(150, 255, 220, ${alpha * 0.8})`);
                        glow.addColorStop(1, 'transparent');
                        ctx.fillStyle = glow;
                        ctx.fillRect(head.x - 10, head.y - 10, 20, 20);
                    }
                }
            }

            // K-formation glow
            if (muField.K_formed) {
                const glow = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, 200);
                glow.addColorStop(0, `rgba(255, 215, 0, ${0.1 * muField.tau_K})`);
                glow.addColorStop(0.5, `rgba(255, 180, 50, ${0.05 * muField.tau_K})`);
                glow.addColorStop(1, 'transparent');
                ctx.fillStyle = glow;
                ctx.fillRect(0, 0, W, H);
            }
        }

        // ================================================================
        // UI UPDATE
        // ================================================================

        function updateUI() {
            document.getElementById('mu-val').textContent = muField.mu.toFixed(3);
            document.getElementById('j-val').textContent = muField.J_total.toFixed(3);

            const wEl = document.getElementById('w-val');
            wEl.textContent = (muField.W >= 0 ? '+' : '') + muField.W.toFixed(3);
            wEl.style.color = muField.W > 0.05 ? '#69db7c' : muField.W < -0.05 ? '#ff6b6b' : '#ffd700';

            document.getElementById('order-val').textContent = muField.order_r.toFixed(3);
            document.getElementById('tau-val').textContent = muField.tau_K.toFixed(3);

            const kEl = document.getElementById('k-val');
            kEl.textContent = muField.K_formed ? 'YES' : 'NO';
            kEl.style.color = muField.K_formed ? '#ffd700' : 'var(--text-dim)';

            document.getElementById('particle-count').textContent = particles.length;
        }

        function showModeIndicator(text) {
            const el = document.getElementById('mode-indicator');
            el.textContent = text;
            el.style.opacity = '1';
            setTimeout(() => el.style.opacity = '0', 1000);
        }

        // ================================================================
        // INPUT
        // ================================================================

        let isDragging = false;
        let lastX, lastY;

        canvas.addEventListener('mousedown', e => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
            autoRotate = false;
        });

        canvas.addEventListener('mousemove', e => {
            if (!isDragging) return;
            rotY += (e.clientX - lastX) * 0.005;
            rotX += (e.clientY - lastY) * 0.005;
            rotX = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotX));
            lastX = e.clientX;
            lastY = e.clientY;
        });

        canvas.addEventListener('mouseup', () => isDragging = false);
        canvas.addEventListener('mouseleave', () => isDragging = false);

        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            zoom = Math.max(150, Math.min(500, zoom - e.deltaY * 0.3));
        });

        document.addEventListener('keydown', e => {
            if (e.key === ' ') {
                e.preventDefault();
                autoRotate = !autoRotate;
                showModeIndicator(autoRotate ? 'AUTO-ROTATE ON' : 'AUTO-ROTATE OFF');
            } else if (e.key.toLowerCase() === 'f') {
                showFlow = !showFlow;
                showModeIndicator(showFlow ? 'FLOW ON' : 'FLOW OFF');
            } else if (e.key.toLowerCase() === 'r') {
                rotX = 0.4;
                rotY = 0;
                zoom = 280;
                autoRotate = true;
                showModeIndicator('RESET');
            }
        });

        // ================================================================
        // ANIMATION LOOP
        // ================================================================

        let lastTime = performance.now();

        function loop(currentTime) {
            const dt = Math.min((currentTime - lastTime) / 1000, 0.05);
            lastTime = currentTime;
            const time = currentTime / 1000;

            if (autoRotate) {
                rotY += dt * 0.2;
            }

            updateField(dt, time);
            updateParticles(dt);
            render(time);
            updateUI();

            requestAnimationFrame(loop);
        }

        // ================================================================
        // INIT
        // ================================================================

        generateMesh();
        requestAnimationFrame(loop);
    </script>
</body>
</html>
