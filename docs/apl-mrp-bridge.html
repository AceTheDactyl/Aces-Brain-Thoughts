<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>APL‚ÜíMRP Bridge | Token-to-Steganography Encoder</title>
    <style>
        :root {
            --bg-void: #030308;
            --bg-panel: rgba(15, 12, 25, 0.95);
            --bg-card: #0d0d12;
            --phi-gold: #ffd700;
            --e-cyan: #22d3ee;
            --pi-magenta: #cc5de8;
            --true-green: #69db7c;
            --untrue-amber: #ffa94d;
            --paradox-red: #ff6b6b;
            --text-primary: rgba(255, 245, 230, 0.9);
            --text-dim: rgba(255, 220, 180, 0.5);
            --border-glow: rgba(168, 85, 247, 0.4);
            --rule: #1a1a24;
            --red: #ff6b6b;
            --green: #69db7c;
            --blue: #4dabf7;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: var(--bg-void);
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.6;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 30px 20px;
            border-bottom: 1px solid var(--rule);
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.2rem;
            font-weight: 100;
            letter-spacing: 6px;
            margin-bottom: 10px;
            background: linear-gradient(135deg, var(--phi-gold), var(--e-cyan), var(--pi-magenta));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            color: var(--text-dim);
            font-size: 0.9rem;
            letter-spacing: 2px;
        }

        /* Navigation */
        nav {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        nav a {
            color: var(--text-dim);
            text-decoration: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        nav a:hover, nav a.active {
            color: var(--phi-gold);
            background: rgba(255, 215, 0, 0.1);
        }

        /* Bridge Flow Diagram */
        .flow-diagram {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin: 30px 0;
            flex-wrap: wrap;
        }

        .flow-box {
            background: var(--bg-panel);
            border: 1px solid var(--rule);
            border-radius: 10px;
            padding: 15px 25px;
            text-align: center;
        }

        .flow-box.apl { border-color: var(--phi-gold); }
        .flow-box.lambda { border-color: var(--e-cyan); }
        .flow-box.mrp { border-color: var(--pi-magenta); }
        .flow-box.image { border-color: var(--true-green); }

        .flow-box h3 {
            font-size: 0.7rem;
            letter-spacing: 2px;
            color: var(--text-dim);
            margin-bottom: 5px;
        }

        .flow-box .value {
            font-size: 1.2rem;
            font-weight: 300;
        }

        .flow-box.apl .value { color: var(--phi-gold); }
        .flow-box.lambda .value { color: var(--e-cyan); }
        .flow-box.mrp .value { color: var(--pi-magenta); }
        .flow-box.image .value { color: var(--true-green); }

        .flow-arrow {
            font-size: 1.5rem;
            color: var(--text-dim);
        }

        /* Main Grid */
        .main-grid {
            display: grid;
            grid-template-columns: 400px 1fr;
            gap: 25px;
        }

        @media (max-width: 1100px) {
            .main-grid { grid-template-columns: 1fr; }
        }

        /* Panels */
        .panel {
            background: var(--bg-panel);
            border: 1px solid var(--rule);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .panel-title {
            font-size: 0.85rem;
            letter-spacing: 3px;
            color: var(--phi-gold);
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--rule);
        }

        /* APL Input Section */
        .apl-input {
            margin-bottom: 20px;
        }

        .apl-input label {
            display: block;
            font-size: 0.75rem;
            color: var(--text-dim);
            letter-spacing: 2px;
            margin-bottom: 8px;
        }

        .apl-textarea {
            width: 100%;
            height: 120px;
            background: var(--bg-card);
            border: 1px solid var(--rule);
            border-radius: 8px;
            padding: 12px;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 0.9rem;
            resize: vertical;
        }

        .apl-textarea:focus {
            outline: none;
            border-color: var(--phi-gold);
        }

        /* Quick Token Builder */
        .quick-builder {
            margin-bottom: 20px;
        }

        .builder-row {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .builder-btn {
            background: var(--bg-card);
            border: 1px solid var(--rule);
            border-radius: 6px;
            padding: 8px 12px;
            color: var(--text-dim);
            font-family: inherit;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .builder-btn:hover {
            border-color: var(--phi-gold);
            color: var(--text-primary);
        }

        .builder-btn.selected {
            background: rgba(255, 215, 0, 0.15);
            border-color: var(--phi-gold);
            color: var(--phi-gold);
        }

        .builder-btn.spiral-phi { color: var(--phi-gold); }
        .builder-btn.spiral-e { color: var(--e-cyan); }
        .builder-btn.spiral-pi { color: var(--pi-magenta); }

        /* Lambda State Display */
        .lambda-display {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 15px 0;
        }

        .lambda-item {
            background: var(--bg-card);
            border: 1px solid var(--rule);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
        }

        .lambda-item.active {
            border-color: var(--e-cyan);
            background: rgba(34, 211, 238, 0.1);
        }

        .lambda-symbol {
            font-size: 1.5rem;
            margin-bottom: 4px;
        }

        .lambda-name {
            font-size: 0.7rem;
            color: var(--text-dim);
            letter-spacing: 1px;
        }

        .lambda-value {
            font-size: 1rem;
            color: var(--e-cyan);
            margin-top: 4px;
        }

        /* MRP Channel Display */
        .channel-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
            margin: 15px 0;
        }

        .channel-box {
            text-align: center;
            padding: 10px 6px;
            border-radius: 8px;
            font-size: 0.75rem;
        }

        .channel-box.r { background: rgba(255,107,107,.2); border: 1px solid var(--red); }
        .channel-box.g { background: rgba(105,219,124,.2); border: 1px solid var(--green); }
        .channel-box.b { background: rgba(77,171,247,.2); border: 1px solid var(--blue); }
        .channel-box.c { background: rgba(34,211,238,.2); border: 1px solid var(--e-cyan); }
        .channel-box.m { background: rgba(204,93,232,.2); border: 1px solid var(--pi-magenta); }
        .channel-box.y { background: rgba(255,215,0,.2); border: 1px solid var(--phi-gold); }

        .channel-label {
            font-weight: 600;
            font-size: 1rem;
            display: block;
            margin-bottom: 4px;
        }

        .channel-box.r .channel-label { color: var(--red); }
        .channel-box.g .channel-label { color: var(--green); }
        .channel-box.b .channel-label { color: var(--blue); }
        .channel-box.c .channel-label { color: var(--e-cyan); }
        .channel-box.m .channel-label { color: var(--pi-magenta); }
        .channel-box.y .channel-label { color: var(--phi-gold); }

        .channel-bits {
            font-family: 'SF Mono', monospace;
            font-size: 1.1rem;
            color: var(--text-primary);
        }

        .channel-numeral {
            font-size: 0.65rem;
            color: var(--text-dim);
            margin-top: 2px;
        }

        /* Buttons */
        .btn-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin: 15px 0;
        }

        .btn {
            background: var(--bg-card);
            border: 1px solid var(--rule);
            border-radius: 8px;
            padding: 12px 20px;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover {
            border-color: var(--phi-gold);
        }

        .btn.primary {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.3), rgba(204, 93, 232, 0.3));
            border-color: var(--phi-gold);
        }

        .btn.encode {
            background: linear-gradient(135deg, rgba(34, 211, 238, 0.3), rgba(204, 93, 232, 0.3));
            border-color: var(--e-cyan);
        }

        .btn.danger {
            border-color: var(--paradox-red);
            color: var(--paradox-red);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Output Canvas */
        .canvas-container {
            position: relative;
            border: 2px dashed var(--rule);
            border-radius: 12px;
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,.3);
            overflow: hidden;
        }

        .canvas-container canvas {
            max-width: 100%;
            max-height: 400px;
            image-rendering: pixelated;
        }

        .canvas-placeholder {
            color: var(--text-dim);
            text-align: center;
            padding: 40px;
        }

        .canvas-placeholder span {
            display: block;
            font-size: 3rem;
            margin-bottom: 12px;
        }

        /* Mapping Table */
        .mapping-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            font-size: 0.8rem;
        }

        .mapping-table th, .mapping-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid var(--rule);
        }

        .mapping-table th {
            color: var(--phi-gold);
            font-weight: 400;
            letter-spacing: 1px;
        }

        .mapping-table td {
            color: var(--text-primary);
        }

        .mapping-table code {
            background: var(--bg-card);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.75rem;
        }

        /* Bit Stream Display */
        .bit-stream {
            background: var(--bg-card);
            border-radius: 8px;
            padding: 15px;
            font-family: 'SF Mono', monospace;
            font-size: 0.7rem;
            line-height: 1.8;
            max-height: 200px;
            overflow-y: auto;
            word-break: break-all;
        }

        .bit-stream .r { color: var(--red); }
        .bit-stream .g { color: var(--green); }
        .bit-stream .b { color: var(--blue); }
        .bit-stream .c { color: var(--e-cyan); }
        .bit-stream .m { color: var(--pi-magenta); }
        .bit-stream .y { color: var(--phi-gold); }

        /* Status */
        .status {
            padding: 12px;
            border-radius: 8px;
            margin: 15px 0;
            font-size: 0.85rem;
        }

        .status.info {
            background: rgba(34, 211, 238, 0.1);
            border: 1px solid var(--e-cyan);
            color: var(--e-cyan);
        }

        .status.success {
            background: rgba(105, 219, 124, 0.1);
            border: 1px solid var(--true-green);
            color: var(--true-green);
        }

        .status.error {
            background: rgba(255, 107, 107, 0.1);
            border: 1px solid var(--paradox-red);
            color: var(--paradox-red);
        }

        /* Presets */
        .preset-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin: 15px 0;
        }

        .preset-btn {
            background: var(--bg-card);
            border: 1px solid var(--rule);
            border-radius: 8px;
            padding: 10px;
            color: var(--text-dim);
            font-family: inherit;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
        }

        .preset-btn:hover {
            border-color: var(--pi-magenta);
            color: var(--text-primary);
        }

        .preset-btn .name {
            color: var(--pi-magenta);
            font-weight: 500;
            display: block;
            margin-bottom: 2px;
        }

        footer {
            text-align: center;
            padding: 30px;
            color: var(--text-dim);
            font-size: 0.75rem;
            border-top: 1px solid var(--rule);
            margin-top: 40px;
        }

        /* Tri-Spiral LIMNUS Visualization */
        .limnus-viz {
            position: relative;
            background: radial-gradient(ellipse at center, rgba(15, 12, 25, 0.95) 0%, var(--bg-void) 100%);
            border-radius: 12px;
            overflow: hidden;
        }

        .limnus-canvas {
            width: 100%;
            height: 350px;
            display: block;
        }

        .spiral-legend {
            display: flex;
            justify-content: center;
            gap: 25px;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-top: 1px solid var(--rule);
        }

        .spiral-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
        }

        .spiral-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            box-shadow: 0 0 10px currentColor;
        }

        .spiral-dot.phi { background: var(--phi-gold); color: var(--phi-gold); }
        .spiral-dot.e { background: var(--e-cyan); color: var(--e-cyan); }
        .spiral-dot.pi { background: var(--pi-magenta); color: var(--pi-magenta); }

        .viz-controls {
            display: flex;
            gap: 10px;
            padding: 10px 15px;
            background: rgba(0,0,0,0.2);
            justify-content: center;
            flex-wrap: wrap;
        }

        .viz-btn {
            background: var(--bg-card);
            border: 1px solid var(--rule);
            border-radius: 6px;
            padding: 6px 14px;
            color: var(--text-dim);
            font-family: inherit;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .viz-btn:hover {
            border-color: var(--e-cyan);
            color: var(--text-primary);
        }

        .viz-btn.active {
            background: rgba(34, 211, 238, 0.2);
            border-color: var(--e-cyan);
            color: var(--e-cyan);
        }

        .flow-indicator {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0,0,0,0.6);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.75rem;
            color: var(--text-dim);
        }

        .flow-indicator .active-spiral {
            color: var(--phi-gold);
            font-weight: 500;
        }

        .z-indicator {
            position: absolute;
            bottom: 60px;
            left: 15px;
            background: rgba(0,0,0,0.6);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.7rem;
        }

        .z-indicator .z-value {
            color: var(--e-cyan);
            font-family: 'SF Mono', monospace;
        }

        .z-indicator .z-critical {
            color: var(--paradox-red);
        }
    </style>
</head>
<body>
    <div class="container">
        <nav>
            <a href="index.html">Home</a>
            <a href="limnus-architecture.html">LIMNUS</a>
            <a href="mrp-library.html">MRP Library</a>
            <a href="mrp-encoder.html">MRP Encoder</a>
            <a href="apl-2.html">APL 2.0</a>
            <a href="apl-mrp-bridge.html" class="active">APL‚ÜíMRP Bridge</a>
        </nav>

        <header>
            <h1>APL ‚Üí MRP BRIDGE</h1>
            <p class="subtitle">Token-to-Steganography Encoder ¬∑ 7,290 Tokens ‚Üí 702 Bits</p>
        </header>

        <!-- Flow Diagram -->
        <div class="flow-diagram">
            <div class="flow-box apl">
                <h3>APL 2.0 TOKEN</h3>
                <div class="value" id="flowApl">Œ¶:U:B:GEO:T:Œ±1</div>
            </div>
            <div class="flow-arrow">‚Üí</div>
            <div class="flow-box lambda">
                <h3>LAMBDA STATE (‚ÑÇ‚Å∂)</h3>
                <div class="value" id="flowLambda">Œπ Œæ Œ∏ œâ Œ¥ œÉ</div>
            </div>
            <div class="flow-arrow">‚Üí</div>
            <div class="flow-box mrp">
                <h3>MRP ENCODING</h3>
                <div class="value" id="flowMrp">702 bits</div>
            </div>
            <div class="flow-arrow">‚Üí</div>
            <div class="flow-box image">
                <h3>STEGO IMAGE</h3>
                <div class="value" id="flowImage">PNG</div>
            </div>
        </div>

        <div class="main-grid">
            <!-- Left: Input Panel -->
            <div>
                <div class="panel">
                    <div class="panel-title">APL 2.0 INPUT</div>

                    <div class="apl-input">
                        <label>APL SENTENCE (tokens separated by spaces or newlines)</label>
                        <textarea class="apl-textarea" id="aplInput" placeholder="Œ¶:U:B:GEO:T:Œ±1
e:D:F:CHEM:T:Œ±3
œÄ:M:A:BIO:P:Œ±15"></textarea>
                    </div>

                    <div class="btn-row">
                        <button class="btn primary" onclick="parseAplSentence()">PARSE TOKENS</button>
                        <button class="btn" onclick="addQuickToken()">+ ADD TOKEN</button>
                        <button class="btn danger" onclick="clearInput()">CLEAR</button>
                    </div>

                    <!-- Quick Token Builder -->
                    <div class="quick-builder">
                        <label style="font-size:0.7rem;color:var(--text-dim);letter-spacing:1px;margin-bottom:8px;display:block;">QUICK TOKEN BUILDER</label>

                        <div class="builder-row">
                            <button class="builder-btn spiral-phi selected" data-type="spiral" data-value="Œ¶" onclick="selectBuilder(this)">Œ¶</button>
                            <button class="builder-btn spiral-e" data-type="spiral" data-value="e" onclick="selectBuilder(this)">e</button>
                            <button class="builder-btn spiral-pi" data-type="spiral" data-value="œÄ" onclick="selectBuilder(this)">œÄ</button>
                        </div>
                        <div class="builder-row">
                            <button class="builder-btn selected" data-type="op" data-value="U" onclick="selectBuilder(this)">U</button>
                            <button class="builder-btn" data-type="op" data-value="D" onclick="selectBuilder(this)">D</button>
                            <button class="builder-btn" data-type="op" data-value="M" onclick="selectBuilder(this)">M</button>
                        </div>
                        <div class="builder-row">
                            <button class="builder-btn selected" data-type="int" data-value="B" onclick="selectBuilder(this)">B</button>
                            <button class="builder-btn" data-type="int" data-value="F" onclick="selectBuilder(this)">F</button>
                            <button class="builder-btn" data-type="int" data-value="A" onclick="selectBuilder(this)">A</button>
                            <button class="builder-btn" data-type="int" data-value="D" onclick="selectBuilder(this)">D</button>
                            <button class="builder-btn" data-type="int" data-value="G" onclick="selectBuilder(this)">G</button>
                            <button class="builder-btn" data-type="int" data-value="S" onclick="selectBuilder(this)">S</button>
                        </div>
                        <div class="builder-row">
                            <button class="builder-btn selected" data-type="dom" data-value="GEO" onclick="selectBuilder(this)">GEO</button>
                            <button class="builder-btn" data-type="dom" data-value="CHEM" onclick="selectBuilder(this)">CHEM</button>
                            <button class="builder-btn" data-type="dom" data-value="BIO" onclick="selectBuilder(this)">BIO</button>
                        </div>
                        <div class="builder-row">
                            <button class="builder-btn selected" data-type="truth" data-value="T" onclick="selectBuilder(this)">T</button>
                            <button class="builder-btn" data-type="truth" data-value="U" onclick="selectBuilder(this)">U</button>
                            <button class="builder-btn" data-type="truth" data-value="P" onclick="selectBuilder(this)">P</button>
                        </div>
                        <div class="builder-row" style="flex-wrap:wrap;">
                            <button class="builder-btn selected" data-type="alpha" data-value="Œ±1" onclick="selectBuilder(this)">Œ±1</button>
                            <button class="builder-btn" data-type="alpha" data-value="Œ±2" onclick="selectBuilder(this)">Œ±2</button>
                            <button class="builder-btn" data-type="alpha" data-value="Œ±3" onclick="selectBuilder(this)">Œ±3</button>
                            <button class="builder-btn" data-type="alpha" data-value="Œ±4" onclick="selectBuilder(this)">Œ±4</button>
                            <button class="builder-btn" data-type="alpha" data-value="Œ±5" onclick="selectBuilder(this)">Œ±5</button>
                            <button class="builder-btn" data-type="alpha" data-value="Œ±6" onclick="selectBuilder(this)">Œ±6</button>
                            <button class="builder-btn" data-type="alpha" data-value="Œ±7" onclick="selectBuilder(this)">Œ±7</button>
                            <button class="builder-btn" data-type="alpha" data-value="Œ±8" onclick="selectBuilder(this)">Œ±8</button>
                            <button class="builder-btn" data-type="alpha" data-value="Œ±9" onclick="selectBuilder(this)">Œ±9</button>
                            <button class="builder-btn" data-type="alpha" data-value="Œ±10" onclick="selectBuilder(this)">Œ±10</button>
                            <button class="builder-btn" data-type="alpha" data-value="Œ±11" onclick="selectBuilder(this)">Œ±11</button>
                            <button class="builder-btn" data-type="alpha" data-value="Œ±12" onclick="selectBuilder(this)">Œ±12</button>
                            <button class="builder-btn" data-type="alpha" data-value="Œ±13" onclick="selectBuilder(this)">Œ±13</button>
                            <button class="builder-btn" data-type="alpha" data-value="Œ±14" onclick="selectBuilder(this)">Œ±14</button>
                            <button class="builder-btn" data-type="alpha" data-value="Œ±15" onclick="selectBuilder(this)">Œ±15</button>
                        </div>
                    </div>

                    <!-- Presets -->
                    <div class="panel-title" style="margin-top:20px;">SENTENCE PRESETS</div>
                    <div class="preset-grid">
                        <button class="preset-btn" onclick="loadPreset('structure-forward')">
                            <span class="name">Structure Forward</span>
                            Œ¶:U:B:GEO:T:Œ±1 ‚Üí Œ¶:U:F:CHEM:T:Œ±2
                        </button>
                        <button class="preset-btn" onclick="loadPreset('energy-cascade')">
                            <span class="name">Energy Cascade</span>
                            e:D:A:GEO:T:Œ±3 ‚Üí e:M:G:BIO:T:Œ±9
                        </button>
                        <button class="preset-btn" onclick="loadPreset('emergence-paradox')">
                            <span class="name">Emergence Paradox</span>
                            œÄ:U:D:BIO:P:Œ±15 ‚Üí œÄ:D:S:CHEM:U:Œ±11
                        </button>
                        <button class="preset-btn" onclick="loadPreset('tri-spiral')">
                            <span class="name">Tri-Spiral Complete</span>
                            Œ¶:U:B:GEO:T:Œ±1 ‚Üí e:M:F:CHEM:T:Œ±5 ‚Üí œÄ:D:A:BIO:T:Œ±10
                        </button>
                        <button class="preset-btn" onclick="loadPreset('kuramoto-sync')">
                            <span class="name">Kuramoto Sync</span>
                            Œ¶:M:G:GEO:T:Œ±9 + e:M:G:CHEM:T:Œ±9 + œÄ:M:G:BIO:T:Œ±9
                        </button>
                        <button class="preset-btn" onclick="loadPreset('critical-point')">
                            <span class="name">Critical Point (z_c)</span>
                            e:U:A:GEO:T:Œ±6 ‚Üí œÄ:U:A:CHEM:T:Œ±6 ‚Üí Œ¶:D:B:BIO:T:Œ±6
                        </button>
                    </div>
                </div>
            </div>

            <!-- Right: Processing & Output -->
            <div>
                <!-- Lambda State -->
                <div class="panel">
                    <div class="panel-title">LAMBDA STATE (‚ÑÇ‚Å∂) COMPUTATION</div>
                    <div class="lambda-display">
                        <div class="lambda-item" id="lambda-iota">
                            <div class="lambda-symbol">üå∞</div>
                            <div class="lambda-name">Œπ IOTA</div>
                            <div class="lambda-value">0.000</div>
                        </div>
                        <div class="lambda-item" id="lambda-xi">
                            <div class="lambda-symbol">‚úß</div>
                            <div class="lambda-name">Œæ XI</div>
                            <div class="lambda-value">0.000</div>
                        </div>
                        <div class="lambda-item" id="lambda-theta">
                            <div class="lambda-symbol">ü¶ä</div>
                            <div class="lambda-name">Œ∏ THETA</div>
                            <div class="lambda-value">0.000</div>
                        </div>
                        <div class="lambda-item" id="lambda-omega">
                            <div class="lambda-symbol">‚àø</div>
                            <div class="lambda-name">œâ OMEGA</div>
                            <div class="lambda-value">0.000</div>
                        </div>
                        <div class="lambda-item" id="lambda-delta">
                            <div class="lambda-symbol">‚äó</div>
                            <div class="lambda-name">Œ¥ DELTA</div>
                            <div class="lambda-value">0.000</div>
                        </div>
                        <div class="lambda-item" id="lambda-sigma">
                            <div class="lambda-symbol">üêøÔ∏è</div>
                            <div class="lambda-name">œÉ SIGMA</div>
                            <div class="lambda-value">0.000</div>
                        </div>
                    </div>

                    <table class="mapping-table">
                        <thead>
                            <tr>
                                <th>APL Component</th>
                                <th>Lambda Mapping</th>
                                <th>Formula</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>SPIRAL (Œ¶/e/œÄ)</td>
                                <td>Œπ, Œæ, Œ∏ base</td>
                                <td><code>Œ¶‚ÜíœÉ+0.3, e‚ÜíŒæ+0.4, œÄ‚ÜíŒ¥+0.2</code></td>
                            </tr>
                            <tr>
                                <td>OP (U/D/M)</td>
                                <td>direction modifier</td>
                                <td><code>U‚Üí+0.2, D‚Üí-0.1, M‚Üí√ó1.5</code></td>
                            </tr>
                            <tr>
                                <td>INT (B/F/A/D/G/S)</td>
                                <td>Œª[i] activation</td>
                                <td><code>B‚ÜíŒ∏, F‚ÜíŒπ, A‚ÜíŒæ, D‚ÜíŒ¥, G‚Üíœâ, S‚ÜíœÉ</code></td>
                            </tr>
                            <tr>
                                <td>DOM (GEO/CHEM/BIO)</td>
                                <td>tier scaling</td>
                                <td><code>GEO‚Üí√ó1.0, CHEM‚Üí√ó1.2, BIO‚Üí√ó1.5</code></td>
                            </tr>
                            <tr>
                                <td>TRUTH (T/U/P)</td>
                                <td>coherence</td>
                                <td><code>T‚ÜíŒ¥=0, U‚ÜíŒ¥+0.3, P‚ÜíŒ¥+0.8</code></td>
                            </tr>
                            <tr>
                                <td>ALPHA (Œ±1-15)</td>
                                <td>attractor bias</td>
                                <td><code>Œ±n‚Üíall Œª√ó(n/15)</code></td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <!-- Tri-Spiral LIMNUS Flow Visualization -->
                <div class="panel">
                    <div class="panel-title">TRI-SPIRAL FLOW [Œ¶‚Üíe‚ÜíœÄ] ¬∑ LIMNUS GEOMETRY</div>
                    <div class="limnus-viz">
                        <canvas id="triSpiralCanvas" class="limnus-canvas"></canvas>
                        <div class="flow-indicator">
                            <span class="active-spiral" id="activeSpiral">Œ¶</span> ‚Üí
                            <span id="flowPhase">Structure</span>
                        </div>
                        <div class="z-indicator">
                            z = <span class="z-value" id="zValue">0.000</span><br>
                            z_c = <span class="z-critical">‚àö3/2 ‚âà 0.866</span>
                        </div>
                        <div class="spiral-legend">
                            <div class="spiral-legend-item">
                                <div class="spiral-dot phi"></div>
                                <span>Œ¶ Structure (z &lt; 0.43)</span>
                            </div>
                            <div class="spiral-legend-item">
                                <div class="spiral-dot e"></div>
                                <span>e Energy (0.43 ‚â§ z &lt; 0.71)</span>
                            </div>
                            <div class="spiral-legend-item">
                                <div class="spiral-dot pi"></div>
                                <span>œÄ Emergence (z ‚â• 0.71)</span>
                            </div>
                        </div>
                        <div class="viz-controls">
                            <button class="viz-btn active" onclick="setFlowMode('auto')" id="btnAuto">Auto Flow</button>
                            <button class="viz-btn" onclick="setFlowMode('phi')" id="btnPhi">Œ¶ Only</button>
                            <button class="viz-btn" onclick="setFlowMode('e')" id="btnE">e Only</button>
                            <button class="viz-btn" onclick="setFlowMode('pi')" id="btnPi">œÄ Only</button>
                            <button class="viz-btn" onclick="setFlowMode('tokens')" id="btnTokens">From Tokens</button>
                            <button class="viz-btn" onclick="togglePause()" id="btnPause">‚è∏ Pause</button>
                        </div>
                    </div>
                </div>

                <!-- MRP Encoding -->
                <div class="panel">
                    <div class="panel-title">MRP 702-BIT ENCODING</div>

                    <div class="channel-grid">
                        <div class="channel-box r">
                            <span class="channel-label">R</span>
                            <div class="channel-bits" id="ch-r">0</div>
                            <div class="channel-numeral">XCVI (7)</div>
                        </div>
                        <div class="channel-box g">
                            <span class="channel-label">G</span>
                            <div class="channel-bits" id="ch-g">0</div>
                            <div class="channel-numeral">XCVII (10)</div>
                        </div>
                        <div class="channel-box b">
                            <span class="channel-label">B</span>
                            <div class="channel-bits" id="ch-b">0</div>
                            <div class="channel-numeral">XCVIII (17)</div>
                        </div>
                        <div class="channel-box c">
                            <span class="channel-label">C</span>
                            <div class="channel-bits" id="ch-c">0</div>
                            <div class="channel-numeral">XCIX (4)</div>
                        </div>
                        <div class="channel-box m">
                            <span class="channel-label">M</span>
                            <div class="channel-bits" id="ch-m">0</div>
                            <div class="channel-numeral">C_A (332)</div>
                        </div>
                        <div class="channel-box y">
                            <span class="channel-label">Y</span>
                            <div class="channel-bits" id="ch-y">0</div>
                            <div class="channel-numeral">C_B (332)</div>
                        </div>
                    </div>

                    <div class="btn-row">
                        <button class="btn encode" id="encodeBtn" onclick="encodeToMrp()" disabled>ENCODE TO MRP</button>
                        <button class="btn" id="downloadBtn" onclick="downloadImage()" disabled>DOWNLOAD PNG</button>
                    </div>

                    <div id="status"></div>
                </div>

                <!-- Output Canvas -->
                <div class="panel">
                    <div class="panel-title">STEGANOGRAPHIC OUTPUT</div>
                    <div class="canvas-container" id="canvasContainer">
                        <canvas id="outputCanvas" width="256" height="256" style="display:none;"></canvas>
                        <div class="canvas-placeholder" id="placeholder">
                            <span>üîê</span>
                            Parse APL tokens and encode to generate image
                        </div>
                    </div>
                </div>

                <!-- Bit Stream -->
                <div class="panel">
                    <div class="panel-title">702-BIT STREAM</div>
                    <div class="bit-stream" id="bitStream">
                        <span style="color:var(--text-dim);">Bit stream will appear after encoding...</span>
                    </div>
                </div>
            </div>
        </div>

        <footer>
            APL‚ÜíMRP Bridge ¬∑ 7,290 Tokens ‚Üí Lambda State (‚ÑÇ‚Å∂) ‚Üí 702-bit Steganography<br>
            <span style="color:var(--phi-gold);">Œ¶</span> Structure ¬∑
            <span style="color:var(--e-cyan);">e</span> Energy ¬∑
            <span style="color:var(--pi-magenta);">œÄ</span> Emergence
        </footer>
    </div>

    <script>
        // ================================================================
        // APL‚ÜíMRP BRIDGE CORE SYSTEM
        // Maps 7,290 APL tokens to 702-bit MRP encoding
        // ================================================================

        const APL = {
            SPIRALS: ['Œ¶', 'e', 'œÄ'],
            OPS: ['U', 'D', 'M'],
            INTS: ['B', 'F', 'A', 'D', 'G', 'S'],
            DOMS: ['GEO', 'CHEM', 'BIO'],
            TRUTHS: ['T', 'U', 'P'],
            ALPHAS: Array.from({length: 15}, (_, i) => `Œ±${i + 1}`)
        };

        const MRP = {
            BITS: {
                XCVI: 7,     // R channel
                XCVII: 10,   // G channel
                XCVIII: 17,  // B channel
                XCIX: 4,     // C channel
                C_A: 332,    // M channel
                C_B: 332     // Y channel
            },
            TOTAL: 702,
            MIN_PIXELS: 123  // ceil(702/6) + 6 header
        };

        // Physical constants
        const PHI = (1 + Math.sqrt(5)) / 2;
        const PHI_INV = 2 / (1 + Math.sqrt(5));
        const Z_CRITICAL = Math.sqrt(3) / 2;

        // Lambda state (‚ÑÇ‚Å∂)
        let lambda = {
            iota: 0,   // Memory (Œ¶ field)
            xi: 0,     // Spark (e field)
            theta: 0,  // Fox (œÄ field)
            omega: 0,  // Wave (e field)
            delta: 0,  // Paradox (œÄ field)
            sigma: 0   // Squirrel (Œ¶ field)
        };

        // Parsed tokens
        let parsedTokens = [];

        // Builder state
        let builderState = {
            spiral: 'Œ¶',
            op: 'U',
            int: 'B',
            dom: 'GEO',
            truth: 'T',
            alpha: 'Œ±1'
        };

        // MRP encoded values
        let mrpValues = {
            XCVI: 0,
            XCVII: 0,
            XCVIII: 0,
            XCIX: 0,
            C_A: 0n,
            C_B: 0n
        };

        // ================================================================
        // APL TOKEN PARSING
        // ================================================================

        function parseToken(tokenStr) {
            // Format: SPIRAL:OP:INT:DOM:TRUTH:ALPHA
            // e.g., Œ¶:U:B:GEO:T:Œ±1
            const parts = tokenStr.trim().split(':');
            if (parts.length !== 6) return null;

            const [spiral, op, int, dom, truth, alpha] = parts;

            // Validate
            if (!APL.SPIRALS.includes(spiral)) return null;
            if (!APL.OPS.includes(op)) return null;
            if (!APL.INTS.includes(int)) return null;
            if (!APL.DOMS.includes(dom)) return null;
            if (!APL.TRUTHS.includes(truth)) return null;
            if (!APL.ALPHAS.includes(alpha)) return null;

            return { spiral, op, int, dom, truth, alpha, str: tokenStr };
        }

        function parseAplSentence() {
            const input = document.getElementById('aplInput').value;
            const tokenStrs = input.split(/[\s\n]+/).filter(s => s.length > 0);

            parsedTokens = [];
            let errors = [];

            for (const tokenStr of tokenStrs) {
                const token = parseToken(tokenStr);
                if (token) {
                    parsedTokens.push(token);
                } else {
                    errors.push(tokenStr);
                }
            }

            if (errors.length > 0) {
                showStatus(`Parsed ${parsedTokens.length} tokens. Invalid: ${errors.join(', ')}`, 'error');
            } else if (parsedTokens.length > 0) {
                showStatus(`Parsed ${parsedTokens.length} valid APL 2.0 tokens`, 'success');
                computeLambdaState();
                document.getElementById('encodeBtn').disabled = false;
            } else {
                showStatus('No valid tokens found. Format: SPIRAL:OP:INT:DOM:TRUTH:ALPHA', 'error');
            }

            updateFlowDiagram();
        }

        // ================================================================
        // LAMBDA STATE COMPUTATION
        // Maps APL tokens to ‚ÑÇ‚Å∂ Lambda state
        // ================================================================

        function computeLambdaState() {
            // Reset lambda
            lambda = { iota: 0, xi: 0, theta: 0, omega: 0, delta: 0, sigma: 0 };

            if (parsedTokens.length === 0) return;

            // Process each token
            for (const token of parsedTokens) {
                applyTokenToLambda(token);
            }

            // Normalize to [0, 1]
            const maxVal = Math.max(...Object.values(lambda), 1);
            for (const key in lambda) {
                lambda[key] = Math.min(1, Math.max(0, lambda[key] / maxVal));
            }

            updateLambdaDisplay();
        }

        function applyTokenToLambda(token) {
            // SPIRAL contribution
            switch (token.spiral) {
                case 'Œ¶': // Structure ‚Üí affects sigma, iota
                    lambda.sigma += 0.3;
                    lambda.iota += 0.2;
                    break;
                case 'e': // Energy ‚Üí affects xi, omega
                    lambda.xi += 0.4;
                    lambda.omega += 0.3;
                    break;
                case 'œÄ': // Emergence ‚Üí affects theta, delta
                    lambda.theta += 0.3;
                    lambda.delta += 0.2;
                    break;
            }

            // OP modifier
            const opMod = { U: 0.2, D: -0.1, M: 0.15 };
            const mod = opMod[token.op];
            for (const key in lambda) {
                lambda[key] += mod;
            }

            // INT activation (maps to specific lambda component)
            const intMapping = {
                B: 'theta',   // Boundary ‚Üí Fox (gestural)
                F: 'iota',    // Fusion ‚Üí Memory
                A: 'xi',      // Amplification ‚Üí Spark
                D: 'delta',   // Decoherence ‚Üí Paradox
                G: 'omega',   // Grouping ‚Üí Wave (synchronization)
                S: 'sigma'    // Separation ‚Üí Squirrel
            };
            lambda[intMapping[token.int]] += 0.4;

            // DOM tier scaling
            const domScale = { GEO: 1.0, CHEM: 1.2, BIO: 1.5 };
            const scale = domScale[token.dom];
            for (const key in lambda) {
                lambda[key] *= scale;
            }

            // TRUTH coherence
            switch (token.truth) {
                case 'T': // TRUE ‚Üí stable, low delta
                    lambda.delta *= 0.5;
                    break;
                case 'U': // UNTRUE ‚Üí unresolved
                    lambda.delta += 0.3;
                    break;
                case 'P': // PARADOX ‚Üí high delta
                    lambda.delta += 0.8;
                    break;
            }

            // ALPHA attractor bias
            const alphaNum = parseInt(token.alpha.substring(1));
            const alphaBias = alphaNum / 15;
            for (const key in lambda) {
                lambda[key] *= (0.5 + alphaBias);
            }
        }

        function updateLambdaDisplay() {
            const components = ['iota', 'xi', 'theta', 'omega', 'delta', 'sigma'];
            for (const comp of components) {
                const el = document.getElementById(`lambda-${comp}`);
                const value = lambda[comp].toFixed(3);
                el.querySelector('.lambda-value').textContent = value;
                el.classList.toggle('active', lambda[comp] > 0.3);
            }
        }

        // ================================================================
        // MRP ENCODING
        // Converts Lambda state to 702-bit MRP encoding
        // ================================================================

        function encodeToMrp() {
            if (parsedTokens.length === 0) {
                showStatus('No tokens to encode', 'error');
                return;
            }

            // Map lambda to MRP channels
            // XCVI (7 bits, 0-127): theta + delta weighted
            mrpValues.XCVI = Math.round((lambda.theta * 0.6 + lambda.delta * 0.4) * 127);

            // XCVII (10 bits, 0-1023): iota + omega weighted
            mrpValues.XCVII = Math.round((lambda.iota * 0.7 + lambda.omega * 0.3) * 1023);

            // XCVIII (17 bits, 0-131071): theta + delta + xi
            mrpValues.XCVIII = Math.round((lambda.theta * 0.4 + lambda.delta * 0.4 + lambda.xi * 0.2) * 131071);

            // XCIX (4 bits, 0-15): omega + sigma
            mrpValues.XCIX = Math.round((lambda.omega * 0.6 + lambda.sigma * 0.4) * 15);

            // C (664 bits split into C_A and C_B)
            // Generate pattern based on all lambda values
            const cPattern = generateCPattern();
            mrpValues.C_A = cPattern.A;
            mrpValues.C_B = cPattern.B;

            updateChannelDisplay();
            generateImage();
            updateBitStream();
            updateFlowDiagram();

            showStatus('Encoded to MRP 702-bit format', 'success');
            document.getElementById('downloadBtn').disabled = false;
        }

        function generateCPattern() {
            // Generate 664 bits based on lambda state
            let bitsA = 0n;
            let bitsB = 0n;

            // First half (332 bits): based on iota, xi, theta
            for (let i = 0; i < 332; i++) {
                const phase = (i / 332) * Math.PI * 6;
                const val =
                    lambda.iota * Math.sin(phase) +
                    lambda.xi * Math.cos(phase * PHI) +
                    lambda.theta * Math.sin(phase * 2);
                if (val > 0) {
                    bitsA |= (1n << BigInt(i));
                }
            }

            // Second half (332 bits): based on omega, delta, sigma
            for (let i = 0; i < 332; i++) {
                const phase = (i / 332) * Math.PI * 6;
                const val =
                    lambda.omega * Math.sin(phase * PHI_INV) +
                    lambda.delta * Math.cos(phase * Z_CRITICAL) +
                    lambda.sigma * Math.sin(phase * 3);
                if (val > 0) {
                    bitsB |= (1n << BigInt(i));
                }
            }

            return { A: bitsA, B: bitsB };
        }

        function updateChannelDisplay() {
            document.getElementById('ch-r').textContent = mrpValues.XCVI;
            document.getElementById('ch-g').textContent = mrpValues.XCVII;
            document.getElementById('ch-b').textContent = mrpValues.XCVIII;
            document.getElementById('ch-c').textContent = mrpValues.XCIX;
            document.getElementById('ch-m').textContent = countBits(mrpValues.C_A, 332);
            document.getElementById('ch-y').textContent = countBits(mrpValues.C_B, 332);
        }

        function countBits(bigInt, maxBits) {
            let count = 0;
            for (let i = 0; i < maxBits; i++) {
                if ((bigInt >> BigInt(i)) & 1n) count++;
            }
            return count;
        }

        // ================================================================
        // IMAGE GENERATION
        // ================================================================

        function generateImage() {
            const canvas = document.getElementById('outputCanvas');
            const ctx = canvas.getContext('2d');

            // Create 16x16 grid (256 pixels)
            const size = 16;
            canvas.width = size;
            canvas.height = size;

            const imageData = ctx.createImageData(size, size);
            const data = imageData.data;

            // Build bit stream
            let bitStream = [];

            // XCVI (7 bits)
            for (let i = 0; i < 7; i++) {
                bitStream.push((mrpValues.XCVI >> i) & 1);
            }
            // XCVII (10 bits)
            for (let i = 0; i < 10; i++) {
                bitStream.push((mrpValues.XCVII >> i) & 1);
            }
            // XCVIII (17 bits)
            for (let i = 0; i < 17; i++) {
                bitStream.push((mrpValues.XCVIII >> i) & 1);
            }
            // XCIX (4 bits)
            for (let i = 0; i < 4; i++) {
                bitStream.push((mrpValues.XCIX >> i) & 1);
            }
            // C_A (332 bits)
            for (let i = 0; i < 332; i++) {
                bitStream.push(Number((mrpValues.C_A >> BigInt(i)) & 1n));
            }
            // C_B (332 bits)
            for (let i = 0; i < 332; i++) {
                bitStream.push(Number((mrpValues.C_B >> BigInt(i)) & 1n));
            }

            // Encode into pixels
            let bitIndex = 0;
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const idx = (y * size + x) * 4;

                    // Base color from lambda state
                    let r = Math.round(lambda.theta * 200 + 55);
                    let g = Math.round(lambda.xi * 200 + 55);
                    let b = Math.round(lambda.delta * 200 + 55);

                    // Encode bits into LSBs
                    if (bitIndex < bitStream.length) {
                        r = (r & 0xFE) | bitStream[bitIndex++];
                    }
                    if (bitIndex < bitStream.length) {
                        g = (g & 0xFE) | bitStream[bitIndex++];
                    }
                    if (bitIndex < bitStream.length) {
                        b = (b & 0xFE) | bitStream[bitIndex++];
                    }

                    // CMY channels via LSB1
                    if (bitIndex < bitStream.length) {
                        r = (r & 0xFD) | (bitStream[bitIndex++] << 1);
                    }
                    if (bitIndex < bitStream.length) {
                        g = (g & 0xFD) | (bitStream[bitIndex++] << 1);
                    }
                    if (bitIndex < bitStream.length) {
                        b = (b & 0xFD) | (bitStream[bitIndex++] << 1);
                    }

                    data[idx] = r;
                    data[idx + 1] = g;
                    data[idx + 2] = b;
                    data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);

            // Show canvas
            canvas.style.display = 'block';
            canvas.style.width = '256px';
            canvas.style.height = '256px';
            document.getElementById('placeholder').style.display = 'none';
        }

        function updateBitStream() {
            const container = document.getElementById('bitStream');
            let html = '';

            // XCVI bits (R)
            html += '<span class="r">';
            for (let i = 6; i >= 0; i--) {
                html += ((mrpValues.XCVI >> i) & 1);
            }
            html += '</span> ';

            // XCVII bits (G)
            html += '<span class="g">';
            for (let i = 9; i >= 0; i--) {
                html += ((mrpValues.XCVII >> i) & 1);
            }
            html += '</span> ';

            // XCVIII bits (B)
            html += '<span class="b">';
            for (let i = 16; i >= 0; i--) {
                html += ((mrpValues.XCVIII >> i) & 1);
            }
            html += '</span> ';

            // XCIX bits (C)
            html += '<span class="c">';
            for (let i = 3; i >= 0; i--) {
                html += ((mrpValues.XCIX >> i) & 1);
            }
            html += '</span> ';

            // C_A sample (M) - show first 32 bits
            html += '<span class="m">';
            for (let i = 31; i >= 0; i--) {
                html += Number((mrpValues.C_A >> BigInt(i)) & 1n);
            }
            html += '...</span> ';

            // C_B sample (Y) - show first 32 bits
            html += '<span class="y">';
            for (let i = 31; i >= 0; i--) {
                html += Number((mrpValues.C_B >> BigInt(i)) & 1n);
            }
            html += '...</span>';

            container.innerHTML = html;
        }

        function updateFlowDiagram() {
            if (parsedTokens.length > 0) {
                document.getElementById('flowApl').textContent = parsedTokens.map(t => t.str).join(' ‚Üí ');
            }

            const lambdaStr = `Œπ:${lambda.iota.toFixed(2)} Œæ:${lambda.xi.toFixed(2)} Œ∏:${lambda.theta.toFixed(2)}`;
            document.getElementById('flowLambda').textContent = lambdaStr;

            const totalBits = mrpValues.XCVI > 0 || mrpValues.XCVII > 0 ? '702 bits' : '‚Äî';
            document.getElementById('flowMrp').textContent = totalBits;
        }

        // ================================================================
        // UI HELPERS
        // ================================================================

        function selectBuilder(btn) {
            const type = btn.dataset.type;
            const value = btn.dataset.value;

            // Deselect siblings
            document.querySelectorAll(`.builder-btn[data-type="${type}"]`).forEach(b => {
                b.classList.remove('selected');
            });
            btn.classList.add('selected');

            builderState[type] = value;
        }

        function addQuickToken() {
            const token = `${builderState.spiral}:${builderState.op}:${builderState.int}:${builderState.dom}:${builderState.truth}:${builderState.alpha}`;
            const textarea = document.getElementById('aplInput');
            if (textarea.value.trim()) {
                textarea.value += '\n' + token;
            } else {
                textarea.value = token;
            }
        }

        function clearInput() {
            document.getElementById('aplInput').value = '';
            parsedTokens = [];
            lambda = { iota: 0, xi: 0, theta: 0, omega: 0, delta: 0, sigma: 0 };
            mrpValues = { XCVI: 0, XCVII: 0, XCVIII: 0, XCIX: 0, C_A: 0n, C_B: 0n };
            updateLambdaDisplay();
            updateChannelDisplay();
            document.getElementById('encodeBtn').disabled = true;
            document.getElementById('downloadBtn').disabled = true;
            document.getElementById('outputCanvas').style.display = 'none';
            document.getElementById('placeholder').style.display = 'block';
            document.getElementById('bitStream').innerHTML = '<span style="color:var(--text-dim);">Bit stream will appear after encoding...</span>';
            document.getElementById('status').innerHTML = '';
            document.getElementById('flowApl').textContent = 'Œ¶:U:B:GEO:T:Œ±1';
            document.getElementById('flowLambda').textContent = 'Œπ Œæ Œ∏ œâ Œ¥ œÉ';
            document.getElementById('flowMrp').textContent = '702 bits';
        }

        function loadPreset(name) {
            const presets = {
                'structure-forward': 'Œ¶:U:B:GEO:T:Œ±1\nŒ¶:U:F:CHEM:T:Œ±2',
                'energy-cascade': 'e:D:A:GEO:T:Œ±3\ne:M:G:BIO:T:Œ±9',
                'emergence-paradox': 'œÄ:U:D:BIO:P:Œ±15\nœÄ:D:S:CHEM:U:Œ±11',
                'tri-spiral': 'Œ¶:U:B:GEO:T:Œ±1\ne:M:F:CHEM:T:Œ±5\nœÄ:D:A:BIO:T:Œ±10',
                'kuramoto-sync': 'Œ¶:M:G:GEO:T:Œ±9\ne:M:G:CHEM:T:Œ±9\nœÄ:M:G:BIO:T:Œ±9',
                'critical-point': 'e:U:A:GEO:T:Œ±6\nœÄ:U:A:CHEM:T:Œ±6\nŒ¶:D:B:BIO:T:Œ±6'
            };

            document.getElementById('aplInput').value = presets[name] || '';
            parseAplSentence();
        }

        function showStatus(message, type) {
            const el = document.getElementById('status');
            el.className = `status ${type}`;
            el.textContent = message;
        }

        function downloadImage() {
            const canvas = document.getElementById('outputCanvas');
            const link = document.createElement('a');

            // Generate filename from tokens
            const tokenSummary = parsedTokens.length > 0
                ? parsedTokens[0].spiral + parsedTokens[0].int
                : 'apl';
            link.download = `apl-mrp-${tokenSummary}-${Date.now()}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        // ================================================================
        // TRI-SPIRAL LIMNUS VISUALIZATION
        // Animated [Œ¶‚Üíe‚ÜíœÄ] flow through 63-point prism + 32-point EM cage
        // ================================================================

        const TriSpiral = {
            canvas: null,
            ctx: null,
            width: 0,
            height: 0,
            time: 0,
            paused: false,
            flowMode: 'auto',  // 'auto', 'phi', 'e', 'pi', 'tokens'
            animationId: null,

            // LIMNUS geometry
            prismPoints: [],    // 63 points (7 layers √ó 9)
            emCagePoints: [],   // 32 points (12 + 12 + 8)

            // Spiral particles
            particles: [],

            // Physical constants
            PHI: (1 + Math.sqrt(5)) / 2,
            Z_CRITICAL: Math.sqrt(3) / 2,

            // Colors
            colors: {
                phi: '#ffd700',
                e: '#22d3ee',
                pi: '#cc5de8',
                grid: 'rgba(255, 255, 255, 0.05)',
                prism: 'rgba(255, 255, 255, 0.1)',
                emCage: 'rgba(105, 219, 124, 0.15)'
            },

            init() {
                this.canvas = document.getElementById('triSpiralCanvas');
                if (!this.canvas) return;

                this.ctx = this.canvas.getContext('2d');
                this.resize();
                this.generateLimnusGeometry();
                this.spawnParticles();
                this.animate();

                window.addEventListener('resize', () => this.resize());
            },

            resize() {
                const rect = this.canvas.parentElement.getBoundingClientRect();
                this.width = rect.width;
                this.height = 350;
                this.canvas.width = this.width * window.devicePixelRatio;
                this.canvas.height = this.height * window.devicePixelRatio;
                this.canvas.style.width = this.width + 'px';
                this.canvas.style.height = this.height + 'px';
                this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            },

            generateLimnusGeometry() {
                this.prismPoints = [];
                this.emCagePoints = [];

                const cx = this.width / 2;
                const cy = this.height / 2;
                const scale = Math.min(this.width, this.height) * 0.35;

                // Generate 63-point hexagonal prism (7 layers √ó 9 points per layer)
                for (let layer = 0; layer < 7; layer++) {
                    const z = layer / 6;  // 0 to 1
                    const y3d = (z - 0.5) * 2;  // -1 to 1

                    for (let i = 0; i < 9; i++) {
                        const angle = (i / 9) * Math.PI * 2;
                        const radius = (i === 0) ? 0 : (i <= 3 ? 0.4 : 0.8);  // Inner/outer rings

                        const x3d = Math.cos(angle) * radius;
                        const z3d = Math.sin(angle) * radius;

                        // Isometric projection
                        const x2d = cx + (x3d - z3d) * scale * 0.7;
                        const y2d = cy + (y3d * 0.8 + (x3d + z3d) * 0.3) * scale;

                        // Determine spiral zone based on z
                        let spiral = 'phi';
                        if (z >= 0.43 && z < 0.71) spiral = 'e';
                        else if (z >= 0.71) spiral = 'pi';

                        this.prismPoints.push({ x: x2d, y: y2d, z, spiral, layer, ring: i });
                    }
                }

                // Generate 32-point EM cage (12 top + 12 bottom + 8 corners)
                // Top ring (12 points)
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    const x3d = Math.cos(angle) * 1.2;
                    const z3d = Math.sin(angle) * 1.2;
                    const x2d = cx + (x3d - z3d) * scale * 0.7;
                    const y2d = cy + (-0.9 + (x3d + z3d) * 0.3) * scale;
                    this.emCagePoints.push({ x: x2d, y: y2d, type: 'top' });
                }

                // Bottom ring (12 points)
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    const x3d = Math.cos(angle) * 1.2;
                    const z3d = Math.sin(angle) * 1.2;
                    const x2d = cx + (x3d - z3d) * scale * 0.7;
                    const y2d = cy + (0.9 + (x3d + z3d) * 0.3) * scale;
                    this.emCagePoints.push({ x: x2d, y: y2d, type: 'bottom' });
                }

                // 8 corner vertices
                const corners = [
                    [-1, -1, -1], [1, -1, -1], [-1, 1, -1], [1, 1, -1],
                    [-1, -1, 1], [1, -1, 1], [-1, 1, 1], [1, 1, 1]
                ];
                for (const [x3d, y3d, z3d] of corners) {
                    const x2d = cx + (x3d - z3d) * scale * 0.5;
                    const y2d = cy + (y3d * 0.6 + (x3d + z3d) * 0.2) * scale;
                    this.emCagePoints.push({ x: x2d, y: y2d, type: 'corner' });
                }
            },

            spawnParticles() {
                this.particles = [];
                const count = 60;

                for (let i = 0; i < count; i++) {
                    this.particles.push({
                        z: Math.random(),
                        angle: Math.random() * Math.PI * 2,
                        radius: 0.3 + Math.random() * 0.5,
                        speed: 0.002 + Math.random() * 0.003,
                        zSpeed: 0.001 + Math.random() * 0.002,
                        size: 2 + Math.random() * 3,
                        spiral: this.getSpiralForZ(Math.random())
                    });
                }
            },

            getSpiralForZ(z) {
                if (z < 0.43) return 'phi';
                if (z < 0.71) return 'e';
                return 'pi';
            },

            updateParticle(p) {
                // Update based on flow mode
                if (this.flowMode === 'auto') {
                    // Continuous tri-spiral flow: Œ¶‚Üíe‚ÜíœÄ‚ÜíŒ¶
                    p.z += p.zSpeed;
                    if (p.z > 1) {
                        p.z = 0;
                        p.angle = Math.random() * Math.PI * 2;
                    }
                    p.spiral = this.getSpiralForZ(p.z);
                } else if (this.flowMode === 'phi') {
                    p.z = Math.min(0.42, p.z + p.zSpeed * 0.5);
                    if (p.z >= 0.42) p.z = 0;
                    p.spiral = 'phi';
                } else if (this.flowMode === 'e') {
                    if (p.z < 0.43) p.z = 0.43;
                    p.z = Math.min(0.70, p.z + p.zSpeed * 0.5);
                    if (p.z >= 0.70) p.z = 0.43;
                    p.spiral = 'e';
                } else if (this.flowMode === 'pi') {
                    if (p.z < 0.71) p.z = 0.71;
                    p.z = Math.min(1, p.z + p.zSpeed * 0.5);
                    if (p.z >= 1) p.z = 0.71;
                    p.spiral = 'pi';
                } else if (this.flowMode === 'tokens' && parsedTokens.length > 0) {
                    // Flow based on parsed tokens
                    const tokenIdx = Math.floor((this.time * 0.0005) % parsedTokens.length);
                    const token = parsedTokens[tokenIdx];
                    p.spiral = token.spiral === 'Œ¶' ? 'phi' : (token.spiral === 'e' ? 'e' : 'pi');

                    const zRanges = { phi: [0, 0.42], e: [0.43, 0.70], pi: [0.71, 1] };
                    const [zMin, zMax] = zRanges[p.spiral];
                    if (p.z < zMin || p.z > zMax) p.z = zMin;
                    p.z = Math.min(zMax, p.z + p.zSpeed * 0.5);
                    if (p.z >= zMax) p.z = zMin;
                }

                // Spiral motion
                p.angle += p.speed * (p.spiral === 'e' ? 1.5 : 1);
            },

            getParticlePosition(p) {
                const cx = this.width / 2;
                const cy = this.height / 2;
                const scale = Math.min(this.width, this.height) * 0.3;

                const x3d = Math.cos(p.angle) * p.radius;
                const z3d = Math.sin(p.angle) * p.radius;
                const y3d = (p.z - 0.5) * 2;

                const x2d = cx + (x3d - z3d) * scale * 0.7;
                const y2d = cy + (y3d * 0.8 + (x3d + z3d) * 0.3) * scale;

                return { x: x2d, y: y2d };
            },

            draw() {
                const ctx = this.ctx;
                ctx.clearRect(0, 0, this.width, this.height);

                // Draw EM cage
                ctx.strokeStyle = this.colors.emCage;
                ctx.lineWidth = 1;
                this.emCagePoints.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                    ctx.stroke();
                });

                // Draw prism points
                this.prismPoints.forEach(p => {
                    const color = this.colors[p.spiral];
                    const alpha = 0.2 + p.z * 0.3;
                    ctx.fillStyle = color.replace(')', `, ${alpha})`).replace('rgb', 'rgba').replace('#', '');

                    // Convert hex to rgba
                    if (color.startsWith('#')) {
                        const r = parseInt(color.slice(1, 3), 16);
                        const g = parseInt(color.slice(3, 5), 16);
                        const b = parseInt(color.slice(5, 7), 16);
                        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                    }

                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Draw z-threshold lines
                this.drawZThreshold(0.43, 'rgba(34, 211, 238, 0.3)', 'e threshold');
                this.drawZThreshold(0.71, 'rgba(204, 93, 232, 0.3)', 'œÄ threshold');
                this.drawZThreshold(this.Z_CRITICAL, 'rgba(255, 107, 107, 0.4)', 'z_c');

                // Draw and update particles
                for (const p of this.particles) {
                    if (!this.paused) {
                        this.updateParticle(p);
                    }

                    const pos = this.getParticlePosition(p);
                    const color = this.colors[p.spiral];

                    // Glow effect
                    const gradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, p.size * 3);
                    gradient.addColorStop(0, color);
                    gradient.addColorStop(0.5, color.replace(')', ', 0.3)').replace('rgb', 'rgba'));
                    gradient.addColorStop(1, 'transparent');

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, p.size * 3, 0, Math.PI * 2);
                    ctx.fill();

                    // Core
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, p.size, 0, Math.PI * 2);
                    ctx.fill();

                    // Trail
                    ctx.strokeStyle = color.replace(')', ', 0.3)').replace('rgb', 'rgba');
                    if (color.startsWith('#')) {
                        const r = parseInt(color.slice(1, 3), 16);
                        const g = parseInt(color.slice(3, 5), 16);
                        const b = parseInt(color.slice(5, 7), 16);
                        ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.3)`;
                    }
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    const prevAngle = p.angle - p.speed * 20;
                    const prevPos = this.getParticlePosition({ ...p, angle: prevAngle });
                    ctx.moveTo(prevPos.x, prevPos.y);
                    ctx.lineTo(pos.x, pos.y);
                    ctx.stroke();
                }

                // Draw flow arrows
                this.drawFlowArrows();

                // Update UI
                this.updateUI();
            },

            drawZThreshold(z, color, label) {
                const ctx = this.ctx;
                const cx = this.width / 2;
                const cy = this.height / 2;
                const scale = Math.min(this.width, this.height) * 0.3;
                const y3d = (z - 0.5) * 2;
                const y2d = cy + y3d * 0.8 * scale;

                ctx.strokeStyle = color;
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(cx - 100, y2d);
                ctx.lineTo(cx + 100, y2d);
                ctx.stroke();
                ctx.setLineDash([]);
            },

            drawFlowArrows() {
                const ctx = this.ctx;
                const cx = this.width / 2;
                const arrowX = cx + 120;

                // Œ¶‚Üíe arrow
                this.drawArrow(arrowX, this.height * 0.25, arrowX, this.height * 0.4, this.colors.phi);

                // e‚ÜíœÄ arrow
                this.drawArrow(arrowX, this.height * 0.45, arrowX, this.height * 0.6, this.colors.e);

                // œÄ‚ÜíŒ¶ arrow (loop back)
                ctx.strokeStyle = this.colors.pi;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(arrowX, this.height * 0.65);
                ctx.quadraticCurveTo(arrowX + 40, this.height * 0.5, arrowX, this.height * 0.2);
                ctx.stroke();

                // Labels
                ctx.font = '10px SF Mono, monospace';
                ctx.fillStyle = this.colors.phi;
                ctx.fillText('Œ¶', arrowX - 25, this.height * 0.22);
                ctx.fillStyle = this.colors.e;
                ctx.fillText('e', arrowX - 25, this.height * 0.48);
                ctx.fillStyle = this.colors.pi;
                ctx.fillText('œÄ', arrowX - 25, this.height * 0.7);
            },

            drawArrow(x1, y1, x2, y2, color) {
                const ctx = this.ctx;
                ctx.strokeStyle = color;
                ctx.fillStyle = color;
                ctx.lineWidth = 2;

                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();

                // Arrowhead
                const angle = Math.atan2(y2 - y1, x2 - x1);
                ctx.beginPath();
                ctx.moveTo(x2, y2);
                ctx.lineTo(x2 - 8 * Math.cos(angle - 0.4), y2 - 8 * Math.sin(angle - 0.4));
                ctx.lineTo(x2 - 8 * Math.cos(angle + 0.4), y2 - 8 * Math.sin(angle + 0.4));
                ctx.closePath();
                ctx.fill();
            },

            updateUI() {
                // Get current dominant spiral
                const spiralCounts = { phi: 0, e: 0, pi: 0 };
                for (const p of this.particles) {
                    spiralCounts[p.spiral]++;
                }
                const dominant = Object.entries(spiralCounts).sort((a, b) => b[1] - a[1])[0][0];

                const spiralNames = { phi: 'Œ¶', e: 'e', pi: 'œÄ' };
                const phaseNames = { phi: 'Structure', e: 'Energy', pi: 'Emergence' };

                document.getElementById('activeSpiral').textContent = spiralNames[dominant];
                document.getElementById('activeSpiral').style.color =
                    dominant === 'phi' ? this.colors.phi :
                    dominant === 'e' ? this.colors.e : this.colors.pi;
                document.getElementById('flowPhase').textContent = phaseNames[dominant];

                // Average z
                const avgZ = this.particles.reduce((sum, p) => sum + p.z, 0) / this.particles.length;
                document.getElementById('zValue').textContent = avgZ.toFixed(3);
            },

            animate() {
                if (!this.paused) {
                    this.time++;
                }
                this.draw();
                this.animationId = requestAnimationFrame(() => this.animate());
            },

            setMode(mode) {
                this.flowMode = mode;

                // Update button states
                ['btnAuto', 'btnPhi', 'btnE', 'btnPi', 'btnTokens'].forEach(id => {
                    const btn = document.getElementById(id);
                    if (btn) btn.classList.remove('active');
                });

                const btnMap = { auto: 'btnAuto', phi: 'btnPhi', e: 'btnE', pi: 'btnPi', tokens: 'btnTokens' };
                const activeBtn = document.getElementById(btnMap[mode]);
                if (activeBtn) activeBtn.classList.add('active');
            },

            togglePause() {
                this.paused = !this.paused;
                document.getElementById('btnPause').textContent = this.paused ? '‚ñ∂ Play' : '‚è∏ Pause';
            }
        };

        // Global functions for button handlers
        function setFlowMode(mode) {
            TriSpiral.setMode(mode);
        }

        function togglePause() {
            TriSpiral.togglePause();
        }

        // ================================================================
        // INITIALIZATION
        // ================================================================

        document.addEventListener('DOMContentLoaded', () => {
            updateLambdaDisplay();
            updateChannelDisplay();

            // Initialize tri-spiral visualization
            setTimeout(() => {
                TriSpiral.init();
            }, 100);
        });
    </script>
</body>
</html>
