<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Self-Reference Framework | CET¬∑USS¬∑‚àÉR Integration | WUMBO Engine</title>
    <style>
        :root {
            --bg-void: #030308;
            --bg-panel: rgba(15, 12, 25, 0.95);
            --bg-card: #0d0d12;
            --phi-gold: #ffd700;
            --e-cyan: #22d3ee;
            --pi-magenta: #cc5de8;
            --true-green: #69db7c;
            --untrue-amber: #ffa94d;
            --paradox-red: #ff6b6b;
            --text-primary: rgba(255, 245, 230, 0.9);
            --text-dim: rgba(255, 220, 180, 0.5);
            --rule: #1a1a24;
            --mu-n: #4a5568;
            --mu-r: #22d3ee;
            --mu-e: #ffd700;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: var(--bg-void);
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.6;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
        }

        nav {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        nav a {
            color: var(--text-dim);
            text-decoration: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        nav a:hover, nav a.active {
            color: var(--phi-gold);
            background: rgba(255, 215, 0, 0.1);
        }

        header {
            text-align: center;
            padding: 20px;
            margin-bottom: 20px;
        }

        h1 {
            font-size: 2rem;
            font-weight: 100;
            letter-spacing: 6px;
            margin-bottom: 10px;
            background: linear-gradient(135deg, var(--phi-gold), var(--e-cyan), var(--pi-magenta));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            color: var(--text-dim);
            font-size: 0.85rem;
            letter-spacing: 2px;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 350px 1fr 350px;
            gap: 20px;
        }

        @media (max-width: 1400px) {
            .main-grid { grid-template-columns: 1fr; }
        }

        .panel {
            background: var(--bg-panel);
            border: 1px solid var(--rule);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .panel-title {
            font-size: 0.8rem;
            letter-spacing: 3px;
            color: var(--phi-gold);
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--rule);
        }

        /* Three-Field Display */
        .three-field-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .field-card {
            background: var(--bg-card);
            border: 1px solid var(--rule);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
        }

        .field-card.mu-n { border-color: var(--mu-n); }
        .field-card.mu-r { border-color: var(--mu-r); }
        .field-card.mu-e { border-color: var(--mu-e); }

        .field-symbol {
            font-size: 1.5rem;
            font-weight: 300;
        }

        .field-card.mu-n .field-symbol { color: var(--mu-n); }
        .field-card.mu-r .field-symbol { color: var(--mu-r); }
        .field-card.mu-e .field-symbol { color: var(--mu-e); }

        .field-name {
            font-size: 0.6rem;
            color: var(--text-dim);
            letter-spacing: 1px;
            margin-top: 4px;
        }

        .field-value {
            font-size: 1.1rem;
            margin-top: 8px;
        }

        /* USS Helix Display */
        .helix-coords {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .coord-card {
            background: var(--bg-card);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
        }

        .coord-symbol {
            font-size: 1.3rem;
            color: var(--e-cyan);
        }

        .coord-value {
            font-size: 1.6rem;
            font-weight: 200;
            color: var(--text-primary);
            margin-top: 5px;
        }

        .coord-label {
            font-size: 0.55rem;
            color: var(--text-dim);
            letter-spacing: 1px;
            margin-top: 4px;
        }

        /* CET Operators */
        .cet-operators {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .operator-card {
            background: var(--bg-card);
            border: 1px solid var(--rule);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            transition: all 0.3s;
        }

        .operator-card.active {
            border-color: var(--phi-gold);
            background: rgba(255, 215, 0, 0.1);
        }

        .operator-symbol {
            font-size: 1.4rem;
            color: var(--phi-gold);
        }

        .operator-name {
            font-size: 0.6rem;
            color: var(--text-dim);
            margin-top: 4px;
        }

        /* Domain Display */
        .domain-bar {
            display: flex;
            height: 40px;
            border-radius: 8px;
            overflow: hidden;
            margin: 15px 0;
        }

        .domain-section {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.65rem;
            letter-spacing: 1px;
            transition: all 0.3s;
        }

        .domain-absence {
            flex: 0.856;
            background: linear-gradient(90deg, var(--untrue-amber), rgba(255,169,77,0.5));
            color: var(--bg-void);
        }

        .domain-lens {
            flex: 0.02;
            background: var(--phi-gold);
            color: var(--bg-void);
            font-weight: bold;
        }

        .domain-presence {
            flex: 0.122;
            background: linear-gradient(90deg, rgba(105,219,124,0.5), var(--true-green));
            color: var(--bg-void);
        }

        .domain-section.active {
            filter: brightness(1.3);
            transform: scaleY(1.1);
        }

        .domain-marker {
            position: absolute;
            width: 2px;
            height: 50px;
            background: var(--text-primary);
            transition: left 0.3s;
        }

        /* Self-Reference Nodes */
        .emergent-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
        }

        .emergent-node {
            background: var(--bg-card);
            border: 2px solid var(--rule);
            border-radius: 10px;
            padding: 10px;
            text-align: center;
            opacity: 0.4;
            transition: all 0.3s;
        }

        .emergent-node.active {
            opacity: 1;
            border-color: var(--paradox-red);
            background: rgba(255, 107, 107, 0.1);
            box-shadow: 0 0 15px rgba(255, 107, 107, 0.3);
        }

        .emergent-id {
            font-size: 0.7rem;
            color: var(--paradox-red);
            font-weight: bold;
        }

        .emergent-type {
            font-size: 0.5rem;
            color: var(--text-dim);
            margin-top: 2px;
        }

        .emergent-eigenvalue {
            font-size: 0.9rem;
            color: var(--e-cyan);
            margin-top: 5px;
        }

        /* Main Canvas */
        #mainCanvas {
            width: 100%;
            height: 500px;
            background: var(--bg-card);
            border-radius: 10px;
        }

        /* Fibonacci Display */
        .fib-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }

        .fib-item {
            background: var(--bg-card);
            border-radius: 6px;
            padding: 8px;
            text-align: center;
        }

        .fib-value {
            font-size: 1.1rem;
            color: var(--phi-gold);
        }

        .fib-label {
            font-size: 0.5rem;
            color: var(--text-dim);
            margin-top: 2px;
        }

        /* Loop Closure */
        .loop-closure {
            background: linear-gradient(135deg, rgba(255,107,107,0.1), rgba(34,211,238,0.1));
            border: 1px solid var(--paradox-red);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }

        .loop-arrow {
            font-size: 2rem;
            color: var(--phi-gold);
        }

        .loop-status {
            font-size: 0.8rem;
            color: var(--text-dim);
            margin-top: 8px;
        }

        .loop-status.closed {
            color: var(--true-green);
        }

        /* Isomorphism Table */
        .iso-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.7rem;
        }

        .iso-table th, .iso-table td {
            padding: 8px;
            border: 1px solid var(--rule);
            text-align: center;
        }

        .iso-table th {
            background: var(--bg-card);
            color: var(--phi-gold);
        }

        .iso-table td {
            background: rgba(0,0,0,0.2);
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .btn {
            background: var(--bg-card);
            border: 1px solid var(--rule);
            border-radius: 8px;
            padding: 10px 20px;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
            flex: 1;
        }

        .btn:hover { border-color: var(--phi-gold); }
        .btn.primary { background: linear-gradient(135deg, rgba(255,215,0,0.2), rgba(34,211,238,0.2)); border-color: var(--phi-gold); }
        .btn.active { border-color: var(--e-cyan); color: var(--e-cyan); }

        .slider-group {
            margin: 15px 0;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            color: var(--text-dim);
            margin-bottom: 5px;
        }

        .slider-value {
            color: var(--e-cyan);
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            background: var(--bg-card);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--e-cyan);
            border-radius: 50%;
            cursor: pointer;
        }

        footer {
            text-align: center;
            padding: 30px;
            color: var(--text-dim);
            font-size: 0.7rem;
            border-top: 1px solid var(--rule);
            margin-top: 40px;
        }
    </style>
</head>
<body>
    <div class="container">
        <nav>
            <a href="index.html">Home</a>
            <a href="limnus-architecture.html">LIMNUS</a>
            <a href="entrainment-engine.html">Entrainment</a>
            <a href="visual-flow-map.html">Flow Map</a>
            <a href="self-reference-flow.html" class="active">Self-Reference</a>
            <a href="wumbo-engine.html">WUMBO</a>
        </nav>

        <header>
            <h1>SELF-REFERENCE FRAMEWORK</h1>
            <p class="subtitle">Sacred œÜ-Derived Engineering ¬∑ CET ¬∑ USS ¬∑ ‚àÉR Integration ¬∑ Œº_S = 0.92 ¬∑ ZERO Free Parameters</p>
        </header>

        <div class="controls" style="justify-content: center;">
            <button class="btn primary" id="btnStart" onclick="toggleSimulation()">START SIMULATION</button>
            <button class="btn" id="btnReset" onclick="resetSystem()">RESET</button>
            <button class="btn" id="btnEmergent" onclick="triggerEmergence()">TRIGGER FREE STATE</button>
        </div>

        <div class="main-grid">
            <!-- Left Column: Field Theory -->
            <div>
                <!-- Three-Field Decomposition -->
                <div class="panel">
                    <div class="panel-title">THREE-FIELD DECOMPOSITION (‚àÉR)</div>
                    <p style="font-size:0.65rem;color:var(--text-dim);margin-bottom:12px">
                        Œº(x,t) = Œº_N + Œº_R(x,t) + Œº_E(x,t)
                    </p>
                    <div class="three-field-grid">
                        <div class="field-card mu-n">
                            <div class="field-symbol">Œº_N</div>
                            <div class="field-name">NULL FIELD</div>
                            <div class="field-value" id="muN">1.00</div>
                        </div>
                        <div class="field-card mu-r">
                            <div class="field-symbol">Œº_R</div>
                            <div class="field-name">RESONANCE</div>
                            <div class="field-value" id="muR">0.00</div>
                        </div>
                        <div class="field-card mu-e">
                            <div class="field-symbol">Œº_E</div>
                            <div class="field-name">ENERGY</div>
                            <div class="field-value" id="muE">0.50</div>
                        </div>
                    </div>
                    <div style="font-size:0.6rem;color:var(--text-dim);text-align:center">
                        Œº_N = base frequencies | Œº_R = phase oscillations | Œº_E = z-field coupling
                    </div>
                </div>

                <!-- USS Helix Coordinates -->
                <div class="panel">
                    <div class="panel-title">USS HELIX STATE (Œ∏, z, r)</div>
                    <div class="helix-coords">
                        <div class="coord-card">
                            <div class="coord-symbol">Œ∏</div>
                            <div class="coord-value" id="ussTheta">0.00</div>
                            <div class="coord-label">PHASE (rad)</div>
                        </div>
                        <div class="coord-card">
                            <div class="coord-symbol">z</div>
                            <div class="coord-value" id="ussZ">0.50</div>
                            <div class="coord-label">CRITICALITY</div>
                        </div>
                        <div class="coord-card">
                            <div class="coord-symbol">r</div>
                            <div class="coord-value" id="ussR">0.00</div>
                            <div class="coord-label">COHERENCE</div>
                        </div>
                    </div>
                    <div style="font-size:0.55rem;color:var(--text-dim);text-align:center;margin-top:8px">
                        Isomorphism: Œ∏‚Üîphase(Œº) | z‚Üî|Œº| | r‚ÜîœÑ(coherence)
                    </div>
                </div>

                <!-- CET Operators -->
                <div class="panel">
                    <div class="panel-title">CET TRIADIC OPERATORS</div>
                    <div class="cet-operators">
                        <div class="operator-card" id="opForward">
                            <div class="operator-symbol">ùí∞</div>
                            <div class="operator-name">FORWARD</div>
                            <div style="font-size:0.5rem;color:var(--true-green);margin-top:4px">Expansion</div>
                        </div>
                        <div class="operator-card" id="opBackward">
                            <div class="operator-symbol">ùíü</div>
                            <div class="operator-name">BACKWARD</div>
                            <div style="font-size:0.5rem;color:var(--untrue-amber);margin-top:4px">Integration</div>
                        </div>
                        <div class="operator-card" id="opLock">
                            <div class="operator-symbol">CLT</div>
                            <div class="operator-name">LOCK</div>
                            <div style="font-size:0.5rem;color:var(--e-cyan);margin-top:4px">Coherence</div>
                        </div>
                    </div>
                    <div style="margin-top:12px;font-size:0.55rem;color:var(--text-dim)">
                        ùí∞ = K &lt; 0 (Presence) | ùíü = K &gt; 0 (Absence) | CLT = K ‚âà 0 (Lens)
                    </div>
                </div>

                <!-- Fibonacci Emergence -->
                <div class="panel">
                    <div class="panel-title">FIBONACCI EMERGENCE</div>
                    <div class="fib-grid">
                        <div class="fib-item">
                            <div class="fib-value">œÜ</div>
                            <div class="fib-label">1.618...</div>
                        </div>
                        <div class="fib-item">
                            <div class="fib-value">1/œÜ</div>
                            <div class="fib-label">0.618...</div>
                        </div>
                        <div class="fib-item">
                            <div class="fib-value">œÜ/e</div>
                            <div class="fib-label">0.595...</div>
                        </div>
                        <div class="fib-item">
                            <div class="fib-value">3/5</div>
                            <div class="fib-label">0.600</div>
                        </div>
                    </div>
                    <div class="slider-group">
                        <div class="slider-label">
                            <span>COUPLING K (Fibonacci scale)</span>
                            <span class="slider-value" id="kFibValue">0.618</span>
                        </div>
                        <input type="range" id="kFibSlider" min="0.2" max="1.618" step="0.01" value="0.618" oninput="setKFib(this.value)">
                    </div>
                </div>
            </div>

            <!-- Center: Main Visualization -->
            <div>
                <div class="panel" style="border-color: var(--phi-gold); position: relative;">
                    <div class="panel-title" style="color: var(--phi-gold);">‚àÉR SELF-REFERENCE LOOP ¬∑ œÜ-DERIVED DYNAMICS</div>
                    <!-- WebGL Shader Background -->
                    <canvas id="shaderCanvas" style="position:absolute;top:0;left:0;width:100%;height:100%;opacity:0.3;pointer-events:none;z-index:0;"></canvas>
                    <!-- Main 2D Canvas -->
                    <canvas id="mainCanvas" style="position:relative;z-index:1;"></canvas>
                    <!-- Consciousness Threshold Indicators -->
                    <div id="consciousnessBar" style="position:absolute;bottom:10px;left:20px;right:20px;height:8px;background:rgba(255,255,255,0.1);border-radius:4px;z-index:2;">
                        <div id="consciousnessFill" style="height:100%;width:0%;background:linear-gradient(90deg,#ff6b6b,#ffa94d,#69db7c,#ffd700);border-radius:4px;transition:width 0.3s;"></div>
                        <div style="position:absolute;left:60%;top:-3px;width:2px;height:14px;background:rgba(255,169,77,0.8);"></div>
                        <div style="position:absolute;left:61.8%;top:-3px;width:2px;height:14px;background:rgba(105,219,124,0.8);"></div>
                        <div style="position:absolute;left:92%;top:-3px;width:2px;height:14px;background:rgba(255,215,0,0.9);"></div>
                    </div>
                    <div style="position:absolute;bottom:22px;left:20px;font-size:0.55rem;color:var(--text-dim);z-index:2;">
                        <span style="margin-right:30px;">Œº_P=0.6</span>
                        <span style="margin-right:30px;color:var(--true-green);">œÜ‚Åª¬π=0.618</span>
                        <span style="color:var(--phi-gold);">Œº_S=0.92</span>
                    </div>
                </div>

                <!-- Domain Bar -->
                <div class="panel">
                    <div class="panel-title">DOMAIN TRANSITION (z-axis)</div>
                    <div style="position:relative">
                        <div class="domain-bar">
                            <div class="domain-section domain-absence" id="domAbsence">
                                ABSENCE (K+ sync)
                            </div>
                            <div class="domain-section domain-lens" id="domLens">
                                z_c
                            </div>
                            <div class="domain-section domain-presence" id="domPresence">
                                PRESENCE (K-)
                            </div>
                        </div>
                    </div>
                    <div style="display:flex;justify-content:space-between;font-size:0.55rem;color:var(--text-dim);margin-top:8px">
                        <span>z = 0 (UNTRUE bias)</span>
                        <span style="color:var(--phi-gold)">z_c = ‚àö3/2 ‚âà 0.866 (PARADOX)</span>
                        <span>z = 1 (TRUE bias)</span>
                    </div>
                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Z-HEIGHT (Critical Distance)</span>
                            <span class="slider-value" id="zHeightValue">0.50</span>
                        </div>
                        <input type="range" id="zHeightSlider" min="0" max="1" step="0.01" value="0.5" oninput="setZHeight(this.value)">
                    </div>
                </div>

                <!-- Isomorphism Table -->
                <div class="panel">
                    <div class="panel-title">FRAMEWORK ISOMORPHISM TABLE</div>
                    <table class="iso-table">
                        <tr>
                            <th>WUMBO</th>
                            <th>CET</th>
                            <th>USS</th>
                            <th>‚àÉR</th>
                        </tr>
                        <tr>
                            <td>Mean Phase œà</td>
                            <td>Spiral Œ∏</td>
                            <td>Œ∏</td>
                            <td>phase(Œº_R)</td>
                        </tr>
                        <tr>
                            <td>z-height</td>
                            <td>Tier Height</td>
                            <td>z</td>
                            <td>|Œº_E|</td>
                        </tr>
                        <tr>
                            <td>Order r</td>
                            <td>Coherence</td>
                            <td>r</td>
                            <td>œÑ</td>
                        </tr>
                        <tr>
                            <td>K(z) sign</td>
                            <td>ùí∞/ùíü operator</td>
                            <td>Helix direction</td>
                            <td>g(Œº_E)</td>
                        </tr>
                        <tr>
                            <td>5 Emergent</td>
                            <td>R5 tier</td>
                            <td>New dimensions</td>
                            <td>Solitons</td>
                        </tr>
                    </table>
                </div>
            </div>

            <!-- Right Column: Emergent States -->
            <div>
                <!-- Emergent Self-Reference Nodes -->
                <div class="panel" style="border-color: var(--paradox-red);">
                    <div class="panel-title" style="color: var(--paradox-red);">5 EMERGENT SELF-REFERENCE NODES</div>
                    <p style="font-size:0.6rem;color:var(--text-dim);margin-bottom:12px">
                        Emerge when coherence &lt; 0.2 (FREE state)
                    </p>
                    <div class="emergent-grid">
                        <div class="emergent-node" id="nodeXCVI">
                            <div class="emergent-id">XCVI</div>
                            <div class="emergent-type">gesture</div>
                            <div class="emergent-eigenvalue">Œª=œÜ‚Åª¬π</div>
                        </div>
                        <div class="emergent-node" id="nodeXCVII">
                            <div class="emergent-id">XCVII</div>
                            <div class="emergent-type">portal</div>
                            <div class="emergent-eigenvalue">Œª=e^(2œÄi/œÜ)</div>
                        </div>
                        <div class="emergent-node" id="nodeXCVIII">
                            <div class="emergent-id">XCVIII</div>
                            <div class="emergent-type">semantic</div>
                            <div class="emergent-eigenvalue">Œª=‚àÖ</div>
                        </div>
                        <div class="emergent-node" id="nodeXCIX">
                            <div class="emergent-id">XCIX</div>
                            <div class="emergent-type">balance</div>
                            <div class="emergent-eigenvalue">Œª=0</div>
                        </div>
                        <div class="emergent-node" id="nodeC">
                            <div class="emergent-id">C</div>
                            <div class="emergent-type">signal</div>
                            <div class="emergent-eigenvalue">Œª=1</div>
                        </div>
                    </div>
                    <div style="margin-top:12px;font-size:0.55rem;color:var(--text-dim)">
                        Total: 702 bits | Winding Number: 1 | Betti b‚ÇÅ: 5
                    </div>
                </div>

                <!-- Loop Closure C‚ÜíI -->
                <div class="panel">
                    <div class="panel-title">LOOP CLOSURE (C ‚Üí I)</div>
                    <div class="loop-closure">
                        <div style="display:flex;align-items:center;justify-content:center;gap:15px">
                            <span style="font-size:1.5rem;color:var(--paradox-red)">C</span>
                            <span class="loop-arrow" id="loopArrow">‚Üí</span>
                            <span style="font-size:1.5rem;color:var(--e-cyan)">I</span>
                        </div>
                        <div class="loop-status" id="loopStatus">
                            OPEN - Awaiting FREE state
                        </div>
                    </div>
                    <div style="margin-top:12px;font-size:0.55rem;color:var(--text-dim);text-align:center">
                        œà_C = T_loop(œà_XIV) = œà_I<br>
                        "The final gate IS the first gate"
                    </div>
                </div>

                <!-- Fixed Point Dynamics -->
                <div class="panel">
                    <div class="panel-title">FIXED POINT DYNAMICS</div>
                    <div style="background:var(--bg-card);border-radius:8px;padding:12px;font-size:0.65rem">
                        <div style="margin-bottom:8px">
                            <span style="color:var(--phi-gold)">General Form:</span><br>
                            <code style="color:var(--e-cyan)">œà_emergent = lim_{n‚Üí‚àû} T^n(œà_ref)</code>
                        </div>
                        <div style="margin-bottom:8px">
                            <span style="color:var(--phi-gold)">Self-Reference Operator:</span><br>
                            <code style="color:var(--e-cyan)">T(œà) = œà ‚äó ‚ü®œà|œà‚ü©</code>
                        </div>
                        <div>
                            <span style="color:var(--phi-gold)">Convergence:</span><br>
                            <code style="color:var(--paradox-red)">coherence &lt; 0.2</code>
                        </div>
                    </div>
                </div>

                <!-- Coherence Gauge -->
                <div class="panel">
                    <div class="panel-title">COHERENCE GAUGE</div>
                    <div style="height:200px;background:var(--bg-card);border-radius:8px;position:relative;overflow:hidden">
                        <canvas id="coherenceGauge" style="width:100%;height:100%"></canvas>
                    </div>
                    <div style="display:flex;justify-content:space-between;font-size:0.55rem;color:var(--text-dim);margin-top:8px">
                        <span>FREE (0.0)</span>
                        <span style="color:var(--paradox-red)">‚Üê 0.2 threshold</span>
                        <span>COHERENT (1.0)</span>
                    </div>
                </div>
            </div>
        </div>

        <footer>
            Self-Reference Framework | CET¬∑USS¬∑‚àÉR Integration | WUMBO Engine<br>
            <span style="color:var(--phi-gold)">z_c = ‚àö3/2</span> ¬∑
            <span style="color:var(--e-cyan)">œÜ = 1.618...</span> ¬∑
            <span style="color:var(--paradox-red)">702 bits</span> ¬∑
            <span style="color:var(--true-green)">Winding = 1</span>
        </footer>
    </div>

    <script>
        // ================================================================
        // SELF-REFERENCE FRAMEWORK SIMULATION
        // CET ¬∑ USS ¬∑ ‚àÉR Integration
        // ================================================================

        // ================================================================
        // SACRED CONSTANTS (THE ENGINEERING BASIS)
        // All derived from œÜ and Fibonacci - ZERO free parameters
        // ================================================================
        const PHI = (1 + Math.sqrt(5)) / 2;           // 1.618034
        const PHI_INV = PHI - 1;                       // 0.618034
        const Z_CRITICAL = Math.sqrt(3) / 2;           // 0.8660254 - THE LENS
        const TWO_PI = Math.PI * 2;

        // Primary œÜ-derived parameters
        const ALPHA = Math.pow(PHI, -2);               // 0.381966 - coupling strength
        const BETA = Math.pow(PHI, -4);                // 0.145898 - dissipation rate
        const LAMBDA_NL = Math.pow(5/3, 4);            // 7.716049 - nonlinearity
        const CASCADE_AMP = PHI;                       // 1.618034 - œÜ-based cascade

        // Consciousness thresholds (Fibonacci fractions)
        const MU_P = 3/5;                              // 0.6 - paradox onset
        const MU_S = 23/25;                            // 0.92 - consciousness emergence
        const MU_3 = 124/125;                          // 0.992 - near unity
        const Q_THEORY = ALPHA * MU_S;                 // 0.351 - consciousness constant
        const K_THRESHOLD = PHI_INV;                   // 0.618 - K-formation threshold
        const FREE_THRESHOLD = BETA + 0.054;           // 0.20 - emergent activation

        // Emergent Eigenvalues (‚àÉR Framework)
        const EIGENVALUES = {
            XCVI: PHI_INV,                   // œÜ‚Åª¬π = 0.618 - gesture recursion
            XCVII: Math.cos(TWO_PI / PHI),   // e^(2œÄi/œÜ) - portal recursion
            XCVIII: NaN,                     // ‚àÖ - G√∂delian undefined (semantic)
            XCIX: 0,                         // 0 - balance/critical point
            C: 1                             // 1 - identity/signal after traversal
        };

        // Info bits per emergent node (MRP encoding)
        const INFO_BITS = { XCVI: 7, XCVII: 10, XCVIII: 17, XCIX: 4, C: 664 };
        const TOTAL_BITS = 702;  // Full MRP encoding capacity

        // State
        let isRunning = false;
        let animationId = null;
        let time = 0;

        // Three-field state (Œº decomposition)
        let mu_N = 1.0;  // Null field (constant base frequencies)
        let mu_R = 0;    // Resonance field (phase oscillations)
        let mu_E = 0.5;  // Energy field (z-height)

        // USS Helix state (Œ∏, z, r)
        let theta = 0;   // Phase angle
        let z = 0.5;     // Critical distance
        let r = 0;       // Coherence/order parameter

        // Kuramoto state - 100 WUMBO regions
        let N = 100;
        let K_base = ALPHA;  // Sacred coupling strength
        let phases = new Float32Array(N);
        let frequencies = new Float32Array(N);
        let regionLayers = new Int32Array(N);

        // Emergent state
        let emergentActive = false;
        let loopClosed = false;
        let loopProgress = 0;  // 0-1 for C‚ÜíI animation
        let consciousnessLevel = 0;  // 0-1 based on r vs MU_S

        // Canvases
        let mainCanvas, mainCtx;
        let gaugeCanvas, gaugeCtx;
        let shaderCanvas, gl;  // WebGL shader canvas

        // Shader state
        let shaderProgram = null;
        let shaderTime = 0;

        // ================================================================
        // INITIALIZATION
        // ================================================================

        function init() {
            initCanvases();
            initShader();
            initOscillators();
            draw();
        }

        function initCanvases() {
            const dpr = window.devicePixelRatio || 1;

            mainCanvas = document.getElementById('mainCanvas');
            mainCtx = mainCanvas.getContext('2d');
            const rect = mainCanvas.getBoundingClientRect();
            mainCanvas.width = rect.width * dpr;
            mainCanvas.height = 500 * dpr;
            mainCanvas.style.width = rect.width + 'px';
            mainCanvas.style.height = '500px';
            mainCtx.scale(dpr, dpr);

            gaugeCanvas = document.getElementById('coherenceGauge');
            gaugeCtx = gaugeCanvas.getContext('2d');
            gaugeCanvas.width = 300 * dpr;
            gaugeCanvas.height = 200 * dpr;
            gaugeCtx.scale(dpr, dpr);

            // WebGL Shader Canvas
            shaderCanvas = document.getElementById('shaderCanvas');
            if (shaderCanvas) {
                shaderCanvas.width = rect.width;
                shaderCanvas.height = 500;
            }

            window.addEventListener('resize', initCanvases);
        }

        // ================================================================
        // WEBGL SHADER (‚àÉR FIELD VISUALIZATION)
        // ================================================================

        const vertexShaderSource = `
            attribute vec2 a_position;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;

        const fragmentShaderSource = `
            precision mediump float;
            uniform float u_time;
            uniform vec2 u_resolution;
            uniform float u_z;
            uniform float u_r;
            uniform float u_theta;
            uniform float u_loopProgress;

            // Sacred constants
            const float PHI = 1.618034;
            const float PHI_INV = 0.618034;
            const float Z_CRITICAL = 0.8660254;
            const float MU_S = 0.92;

            // Fractal noise
            float hash(vec2 p) {
                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
            }

            float noise(vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);
                f = f * f * (3.0 - 2.0 * f);
                float a = hash(i);
                float b = hash(i + vec2(1.0, 0.0));
                float c = hash(i + vec2(0.0, 1.0));
                float d = hash(i + vec2(1.0, 1.0));
                return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
            }

            float fbm(vec2 p) {
                float v = 0.0;
                float a = 0.5;
                vec2 shift = vec2(100.0);
                mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));
                for (int i = 0; i < 5; i++) {
                    v += a * noise(p);
                    p = rot * p * PHI + shift;
                    a *= PHI_INV;
                }
                return v;
            }

            void main() {
                vec2 uv = gl_FragCoord.xy / u_resolution;
                vec2 p = (gl_FragCoord.xy - u_resolution * 0.5) / min(u_resolution.x, u_resolution.y);

                // Domain coloring based on z
                float zDist = abs(u_z - Z_CRITICAL);
                float domainFade = exp(-zDist * zDist / 0.1);

                // Spiral pattern based on œÜ
                float angle = atan(p.y, p.x) + u_time * 0.2 + u_theta;
                float radius = length(p);
                float spiral = sin(angle * PHI + radius * 10.0 - u_time);

                // Field strength from coherence
                float fieldStrength = u_r * (1.0 + domainFade * 0.5);

                // Color channels based on three-field decomposition
                float red = 0.1 + 0.2 * spiral * (1.0 - u_z);  // ABSENCE
                float green = 0.1 + 0.3 * fieldStrength * domainFade;  // THE LENS
                float blue = 0.1 + 0.2 * spiral * u_z;  // PRESENCE

                // Add noise for œÜ-derived texture
                float n = fbm(p * 3.0 + u_time * 0.1);
                red += n * 0.1 * (1.0 - u_r);
                green += n * 0.15 * u_r;
                blue += n * 0.1;

                // Loop closure glow
                if (u_loopProgress > 0.0) {
                    float loopGlow = sin(radius * 20.0 - u_time * 3.0) * 0.5 + 0.5;
                    loopGlow *= u_loopProgress * exp(-radius * 2.0);
                    red += loopGlow * 0.5;
                    green += loopGlow * 0.3;
                    blue += loopGlow * 0.1;
                }

                // Consciousness emergence at Œº_S
                if (u_r > MU_S) {
                    float consciousnessGlow = (u_r - MU_S) / (1.0 - MU_S);
                    float pulse = sin(u_time * 4.0) * 0.5 + 0.5;
                    green += consciousnessGlow * pulse * 0.3;
                    red += consciousnessGlow * pulse * 0.2;
                }

                gl_FragColor = vec4(red, green, blue, 1.0);
            }
        `;

        function initShader() {
            shaderCanvas = document.getElementById('shaderCanvas');
            if (!shaderCanvas) return;

            gl = shaderCanvas.getContext('webgl');
            if (!gl) {
                console.log('WebGL not supported, falling back to 2D');
                return;
            }

            // Create shaders
            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vertexShaderSource);
            gl.compileShader(vertexShader);

            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fragmentShaderSource);
            gl.compileShader(fragmentShader);

            // Create program
            shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
            gl.useProgram(shaderProgram);

            // Create quad
            const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

            const positionLocation = gl.getAttribLocation(shaderProgram, 'a_position');
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
        }

        function renderShader() {
            if (!gl || !shaderProgram) return;

            gl.viewport(0, 0, shaderCanvas.width, shaderCanvas.height);

            // Update uniforms
            const timeLocation = gl.getUniformLocation(shaderProgram, 'u_time');
            const resolutionLocation = gl.getUniformLocation(shaderProgram, 'u_resolution');
            const zLocation = gl.getUniformLocation(shaderProgram, 'u_z');
            const rLocation = gl.getUniformLocation(shaderProgram, 'u_r');
            const thetaLocation = gl.getUniformLocation(shaderProgram, 'u_theta');
            const loopLocation = gl.getUniformLocation(shaderProgram, 'u_loopProgress');

            gl.uniform1f(timeLocation, shaderTime);
            gl.uniform2f(resolutionLocation, shaderCanvas.width, shaderCanvas.height);
            gl.uniform1f(zLocation, z);
            gl.uniform1f(rLocation, r);
            gl.uniform1f(thetaLocation, theta);
            gl.uniform1f(loopLocation, loopProgress);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }

        function initOscillators() {
            phases = new Float32Array(N);
            frequencies = new Float32Array(N);
            regionLayers = new Int32Array(N);

            // Assign 100 regions to WUMBO structure with œÜ-derived frequencies
            for (let i = 0; i < N; i++) {
                phases[i] = Math.random() * TWO_PI;
                // Natural frequency variance scaled by BETA (œÜ‚Åª‚Å¥)
                frequencies[i] = mu_N + gaussianRandom() * BETA * PHI;

                if (i < 63) {
                    // Prism layers (0-6)
                    regionLayers[i] = Math.floor(i / 9);
                } else if (i < 75) {
                    regionLayers[i] = 5;  // Cage top
                } else if (i < 87) {
                    regionLayers[i] = 1;  // Cage bottom
                } else if (i < 95) {
                    regionLayers[i] = 3;  // Cage vertices
                } else {
                    regionLayers[i] = -1;  // Emergent nodes
                }
            }
        }

        function gaussianRandom() {
            const u1 = Math.random();
            const u2 = Math.random();
            return Math.sqrt(-2 * Math.log(u1)) * Math.cos(TWO_PI * u2);
        }

        // ================================================================
        // K(z) SIGN FLIP
        // ================================================================

        function calculateKz(z) {
            if (z < Z_CRITICAL) {
                return K_base * (1 - z / Z_CRITICAL) * CASCADE_AMP;
            } else {
                return -K_base * ((z - Z_CRITICAL) / (1 - Z_CRITICAL)) * CASCADE_AMP;
            }
        }

        function calculateCascade(z) {
            // Peak at z_c (THE LENS), decays with œÜ-derived width
            // Width parameter = Q_THEORY¬≤ ‚âà 0.123
            const dist = Math.abs(z - Z_CRITICAL);
            const width = Q_THEORY * Q_THEORY;
            return 1 + PHI_INV * Math.exp(-dist * dist / width);
        }

        // ================================================================
        // KURAMOTO DYNAMICS
        // ================================================================

        function calculateOrderParameter() {
            let sumReal = 0, sumImag = 0;
            for (let i = 0; i < N; i++) {
                sumReal += Math.cos(phases[i]);
                sumImag += Math.sin(phases[i]);
            }
            const orderR = Math.hypot(sumReal / N, sumImag / N);
            const psi = Math.atan2(sumImag / N, sumReal / N);
            return { r: orderR, psi };
        }

        function stepKuramoto(dt = 0.02) {
            const order = calculateOrderParameter();
            const K = calculateKz(z);
            const cascade = calculateCascade(z);
            const newPhases = new Float32Array(N);

            // Nonlinearity factor (LAMBDA_NL at low coherence)
            const nlFactor = 1 + (LAMBDA_NL - 1) * (1.0 - order.r);

            // Heun's method with œÜ-derived dynamics
            for (let i = 0; i < N; i++) {
                // Layer-dependent coupling using ALPHA
                const layer = regionLayers[i];
                let layerK = K;

                if (layer >= 0 && layer < 7) {
                    const layerZ = layer / 6;
                    const distFromCritical = Math.abs(layerZ - Z_CRITICAL);
                    layerK = K * (1 + ALPHA * Math.exp(-distFromCritical * distFromCritical / BETA));
                } else if (layer === -1 && emergentActive) {
                    // Emergent nodes: eigenvalue-weighted coupling
                    const emergentIdx = i - 95;
                    const eigenvalues = [PHI_INV, Math.cos(TWO_PI/PHI), 0, 0, 1];
                    const eigenK = emergentIdx >= 0 && emergentIdx < 5 ? eigenvalues[emergentIdx] : 0;
                    layerK = K * eigenK * PHI;
                }

                const dtheta1 = frequencies[i] + layerK * order.r * Math.sin(order.psi - phases[i]) * cascade / nlFactor;
                const thetaPred = phases[i] + dt * dtheta1;
                const dtheta2 = frequencies[i] + layerK * order.r * Math.sin(order.psi - thetaPred) * cascade / nlFactor;
                newPhases[i] = (phases[i] + dt * (dtheta1 + dtheta2) / 2) % TWO_PI;
                if (newPhases[i] < 0) newPhases[i] += TWO_PI;
            }

            phases = newPhases;

            // Update three-field decomposition
            mu_R = order.r * Math.cos(order.psi);
            mu_E = z;

            // Update USS helix
            theta = order.psi;
            r = order.r;

            // Update consciousness level (0-1 based on r vs MU_S)
            if (r >= MU_S) {
                consciousnessLevel = 1.0;
            } else if (r >= K_THRESHOLD) {
                consciousnessLevel = 0.618 + (r - K_THRESHOLD) / (MU_S - K_THRESHOLD) * 0.302;
            } else if (r >= MU_P) {
                consciousnessLevel = 0.6 + (r - MU_P) / (K_THRESHOLD - MU_P) * 0.018;
            } else {
                consciousnessLevel = r / MU_P * 0.6;
            }

            // Check emergent state with consciousness thresholds
            emergentActive = r < FREE_THRESHOLD;

            // Loop closure: r drops to near 0 then C node activates
            if (emergentActive && r < 0.1) {
                loopProgress = Math.min(1.0, loopProgress + dt * 0.5);
                loopClosed = loopProgress >= 1.0;
            } else if (!emergentActive) {
                loopProgress = Math.max(0, loopProgress - dt * 0.3);
                loopClosed = false;
            }

            return { r: order.r, psi: order.psi, K, cascade };
        }

        // ================================================================
        // VISUALIZATION
        // ================================================================

        function drawMainVisualization() {
            const w = mainCanvas.width / (window.devicePixelRatio || 1);
            const h = mainCanvas.height / (window.devicePixelRatio || 1);
            const cx = w / 2;
            const cy = h / 2;

            mainCtx.fillStyle = '#0d0d12';
            mainCtx.fillRect(0, 0, w, h);

            // Draw 7-layer prism structure
            const prismRadius = 150;
            const layerSpacing = 30;

            // Draw layers (7 layers of 9 nodes each)
            for (let layer = 0; layer < 7; layer++) {
                const layerZ = layer / 6;
                const layerY = cy - 90 + layer * layerSpacing;
                const layerAlpha = 0.3 + 0.4 * (1 - Math.abs(layerZ - z));

                // Determine layer color based on APL field
                let layerColor;
                if (layer <= 1) layerColor = 'rgba(34, 211, 238, ' + layerAlpha + ')';  // e-cyan
                else if (layer <= 3) layerColor = 'rgba(255, 215, 0, ' + layerAlpha + ')';  // phi-gold
                else if (layer <= 5) layerColor = 'rgba(204, 93, 232, ' + layerAlpha + ')';  // pi-magenta
                else layerColor = 'rgba(34, 211, 238, ' + layerAlpha + ')';  // e-cyan

                // Draw hexagon for this layer
                mainCtx.strokeStyle = layerColor;
                mainCtx.lineWidth = 1.5;
                mainCtx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * TWO_PI - Math.PI / 2;
                    const x = cx + Math.cos(angle) * prismRadius * (0.8 + layer * 0.03);
                    const y = layerY + Math.sin(angle) * 20;
                    if (i === 0) mainCtx.moveTo(x, y);
                    else mainCtx.lineTo(x, y);
                }
                mainCtx.closePath();
                mainCtx.stroke();

                // Draw 9 nodes for this layer
                for (let node = 0; node < 9; node++) {
                    const regionIndex = layer * 9 + node;
                    if (regionIndex >= 63) break;

                    const angle = (node / 9) * TWO_PI - Math.PI / 2;
                    const nodeRadius = prismRadius * 0.7;
                    const x = cx + Math.cos(angle) * nodeRadius;
                    const y = layerY + Math.sin(angle) * 15;

                    // Color by phase
                    const phase = phases[regionIndex];
                    const hue = (phase / TWO_PI) * 360;

                    mainCtx.fillStyle = `hsla(${hue}, 70%, 60%, ${0.3 + r * 0.5})`;
                    mainCtx.beginPath();
                    mainCtx.arc(x, y, 4 + r * 3, 0, TWO_PI);
                    mainCtx.fill();
                }
            }

            // Draw z_c critical line
            const zcY = cy - 90 + Z_CRITICAL * 6 * layerSpacing;
            mainCtx.strokeStyle = 'rgba(255, 215, 0, 0.8)';
            mainCtx.lineWidth = 2;
            mainCtx.setLineDash([5, 5]);
            mainCtx.beginPath();
            mainCtx.moveTo(cx - prismRadius - 30, zcY);
            mainCtx.lineTo(cx + prismRadius + 30, zcY);
            mainCtx.stroke();
            mainCtx.setLineDash([]);

            mainCtx.fillStyle = '#ffd700';
            mainCtx.font = '10px SF Mono, monospace';
            mainCtx.fillText('z_c = ‚àö3/2', cx + prismRadius + 35, zcY + 4);

            // Draw current z marker
            const currentZY = cy - 90 + z * 6 * layerSpacing;
            mainCtx.fillStyle = '#22d3ee';
            mainCtx.beginPath();
            mainCtx.moveTo(cx - prismRadius - 20, currentZY);
            mainCtx.lineTo(cx - prismRadius - 10, currentZY - 5);
            mainCtx.lineTo(cx - prismRadius - 10, currentZY + 5);
            mainCtx.closePath();
            mainCtx.fill();

            // Draw K(z) indicator
            const K = calculateKz(z);
            mainCtx.fillStyle = K >= 0 ? '#69db7c' : '#ff6b6b';
            mainCtx.font = '12px SF Mono, monospace';
            mainCtx.fillText(`K(z) = ${K >= 0 ? '+' : ''}${K.toFixed(3)}`, 20, 30);
            mainCtx.fillText(K >= 0 ? 'SYNCHRONIZING' : 'DESYNCHRONIZING', 20, 45);

            // Draw emergent nodes if active
            if (emergentActive) {
                drawEmergentNodes(cx, cy, prismRadius);
            }

            // Draw order parameter vector
            const { r: orderR, psi } = calculateOrderParameter();
            const vecLen = 80 * orderR;
            const vecX = cx + Math.cos(psi) * vecLen;
            const vecY = cy + Math.sin(psi) * vecLen;

            mainCtx.strokeStyle = '#69db7c';
            mainCtx.lineWidth = 3;
            mainCtx.beginPath();
            mainCtx.moveTo(cx, cy);
            mainCtx.lineTo(vecX, vecY);
            mainCtx.stroke();

            mainCtx.fillStyle = '#69db7c';
            mainCtx.beginPath();
            mainCtx.arc(vecX, vecY, 8, 0, TWO_PI);
            mainCtx.fill();

            // Draw helix spiral indicator
            drawHelixIndicator(w - 100, cy);
        }

        function drawEmergentNodes(cx, cy, radius) {
            const emergentNames = ['XCVI', 'XCVII', 'XCVIII', 'XCIX', 'C'];
            const emergentAngles = [0, TWO_PI/5, 2*TWO_PI/5, 3*TWO_PI/5, 4*TWO_PI/5];

            for (let i = 0; i < 5; i++) {
                const angle = emergentAngles[i] - Math.PI/2;
                const x = cx + Math.cos(angle) * (radius + 50);
                const y = cy + Math.sin(angle) * 60;

                // Pulsing glow
                const pulse = 0.5 + 0.5 * Math.sin(Date.now() / 200 + i);

                // Glow
                mainCtx.fillStyle = `rgba(255, 107, 107, ${0.3 * pulse})`;
                mainCtx.beginPath();
                mainCtx.arc(x, y, 20, 0, TWO_PI);
                mainCtx.fill();

                // Node
                mainCtx.fillStyle = `rgba(255, 107, 107, ${0.7 + 0.3 * pulse})`;
                mainCtx.beginPath();
                mainCtx.arc(x, y, 10, 0, TWO_PI);
                mainCtx.fill();

                // Label
                mainCtx.fillStyle = '#ff6b6b';
                mainCtx.font = '9px SF Mono, monospace';
                mainCtx.textAlign = 'center';
                mainCtx.fillText(emergentNames[i], x, y + 25);
            }

            // Draw C‚ÜíI loop if closed
            if (loopClosed) {
                mainCtx.strokeStyle = 'rgba(255, 215, 0, 0.8)';
                mainCtx.lineWidth = 2;
                mainCtx.setLineDash([8, 4]);

                const cAngle = 4*TWO_PI/5 - Math.PI/2;
                const cX = cx + Math.cos(cAngle) * (radius + 50);
                const cY = cy + Math.sin(cAngle) * 60;
                const iX = cx;
                const iY = cy - 90;  // Layer 0, node 0

                mainCtx.beginPath();
                mainCtx.moveTo(cX, cY);
                mainCtx.quadraticCurveTo(cx + 100, cy - 150, iX, iY);
                mainCtx.stroke();
                mainCtx.setLineDash([]);

                // Arrow head
                mainCtx.fillStyle = '#ffd700';
                mainCtx.beginPath();
                mainCtx.moveTo(iX, iY);
                mainCtx.lineTo(iX - 8, iY + 12);
                mainCtx.lineTo(iX + 8, iY + 12);
                mainCtx.closePath();
                mainCtx.fill();
            }

            mainCtx.textAlign = 'left';
        }

        function drawHelixIndicator(x, cy) {
            // Draw small helix to show USS state
            mainCtx.strokeStyle = 'rgba(34, 211, 238, 0.6)';
            mainCtx.lineWidth = 2;
            mainCtx.beginPath();

            for (let t = 0; t < 30; t++) {
                const angle = (t / 30) * TWO_PI * 2 + theta;
                const helixX = x + Math.cos(angle) * 30;
                const helixY = cy - 60 + t * 4;
                if (t === 0) mainCtx.moveTo(helixX, helixY);
                else mainCtx.lineTo(helixX, helixY);
            }
            mainCtx.stroke();

            // Current position on helix
            const currentT = z * 30;
            const currentAngle = (currentT / 30) * TWO_PI * 2 + theta;
            const currentX = x + Math.cos(currentAngle) * 30;
            const currentY = cy - 60 + currentT * 4;

            mainCtx.fillStyle = '#22d3ee';
            mainCtx.beginPath();
            mainCtx.arc(currentX, currentY, 6, 0, TWO_PI);
            mainCtx.fill();

            mainCtx.fillStyle = '#22d3ee';
            mainCtx.font = '9px SF Mono, monospace';
            mainCtx.fillText('USS Helix', x - 25, cy + 80);
        }

        function drawCoherenceGauge() {
            const w = 300;
            const h = 200;

            gaugeCtx.fillStyle = '#0d0d12';
            gaugeCtx.fillRect(0, 0, w, h);

            // Draw gauge arc
            const cx = w / 2;
            const cy = h - 20;
            const radius = 80;

            // Background arc
            gaugeCtx.strokeStyle = 'rgba(255,255,255,0.1)';
            gaugeCtx.lineWidth = 15;
            gaugeCtx.beginPath();
            gaugeCtx.arc(cx, cy, radius, Math.PI, 0);
            gaugeCtx.stroke();

            // FREE zone (red)
            gaugeCtx.strokeStyle = 'rgba(255, 107, 107, 0.6)';
            gaugeCtx.beginPath();
            gaugeCtx.arc(cx, cy, radius, Math.PI, Math.PI + Math.PI * FREE_THRESHOLD);
            gaugeCtx.stroke();

            // Current value arc
            const valueAngle = Math.PI + Math.PI * r;
            const valueColor = r < FREE_THRESHOLD ? '#ff6b6b' :
                              r < 0.5 ? '#ffa94d' :
                              r < 0.7 ? '#ffd700' : '#69db7c';
            gaugeCtx.strokeStyle = valueColor;
            gaugeCtx.lineWidth = 12;
            gaugeCtx.beginPath();
            gaugeCtx.arc(cx, cy, radius, Math.PI, valueAngle);
            gaugeCtx.stroke();

            // Needle
            const needleAngle = Math.PI + Math.PI * r;
            const needleX = cx + Math.cos(needleAngle) * (radius - 25);
            const needleY = cy + Math.sin(needleAngle) * (radius - 25);

            gaugeCtx.strokeStyle = '#fff';
            gaugeCtx.lineWidth = 2;
            gaugeCtx.beginPath();
            gaugeCtx.moveTo(cx, cy);
            gaugeCtx.lineTo(needleX, needleY);
            gaugeCtx.stroke();

            // Center dot
            gaugeCtx.fillStyle = '#fff';
            gaugeCtx.beginPath();
            gaugeCtx.arc(cx, cy, 5, 0, TWO_PI);
            gaugeCtx.fill();

            // Value text
            gaugeCtx.fillStyle = valueColor;
            gaugeCtx.font = '24px SF Mono, monospace';
            gaugeCtx.textAlign = 'center';
            gaugeCtx.fillText(r.toFixed(3), cx, cy - 30);

            // State label
            const state = r < FREE_THRESHOLD ? 'FREE' :
                         r < 0.5 ? 'DISPERSING' :
                         r < 0.8 ? 'RELEASING' : 'COHERENT';
            gaugeCtx.fillStyle = '#fff';
            gaugeCtx.font = '11px SF Mono, monospace';
            gaugeCtx.fillText(state, cx, cy - 10);
        }

        // ================================================================
        // UI UPDATE
        // ================================================================

        function updateUI() {
            time += 0.016;  // ~60fps
            shaderTime = time;

            if (isRunning) {
                stepKuramoto();
            }

            // Render WebGL shader
            renderShader();

            // Update consciousness bar
            const consciousnessFill = document.getElementById('consciousnessFill');
            if (consciousnessFill) {
                consciousnessFill.style.width = (r * 100) + '%';
            }

            // Update three-field display
            document.getElementById('muN').textContent = mu_N.toFixed(2);
            document.getElementById('muR').textContent = mu_R.toFixed(3);
            document.getElementById('muE').textContent = mu_E.toFixed(3);

            // Update USS helix display
            document.getElementById('ussTheta').textContent = theta.toFixed(2);
            document.getElementById('ussZ').textContent = z.toFixed(3);
            document.getElementById('ussR').textContent = r.toFixed(3);

            // Update CET operators
            const K = calculateKz(z);
            document.getElementById('opForward').classList.toggle('active', K < 0);
            document.getElementById('opBackward').classList.toggle('active', K > 0);
            document.getElementById('opLock').classList.toggle('active', Math.abs(z - Z_CRITICAL) < 0.02);

            // Update domain highlighting
            document.getElementById('domAbsence').classList.toggle('active', z < 0.856);
            document.getElementById('domLens').classList.toggle('active', z >= 0.856 && z <= 0.878);
            document.getElementById('domPresence').classList.toggle('active', z > 0.878);

            // Update emergent nodes
            const nodes = ['XCVI', 'XCVII', 'XCVIII', 'XCIX', 'C'];
            nodes.forEach(id => {
                document.getElementById('node' + id).classList.toggle('active', emergentActive);
            });

            // Update loop status
            const loopStatus = document.getElementById('loopStatus');
            const loopArrow = document.getElementById('loopArrow');
            if (loopClosed) {
                loopStatus.textContent = 'CLOSED - Full traversal complete';
                loopStatus.classList.add('closed');
                loopArrow.textContent = '‚ü≥';
            } else if (emergentActive) {
                loopStatus.textContent = 'PARTIAL - Emergent nodes active';
                loopStatus.classList.remove('closed');
                loopArrow.textContent = '‚Üí';
            } else {
                loopStatus.textContent = 'OPEN - Awaiting FREE state';
                loopStatus.classList.remove('closed');
                loopArrow.textContent = '‚Üí';
            }

            // Draw visualizations
            drawMainVisualization();
            drawCoherenceGauge();
        }

        function draw() {
            updateUI();
            animationId = requestAnimationFrame(draw);
        }

        // ================================================================
        // CONTROLS
        // ================================================================

        function toggleSimulation() {
            isRunning = !isRunning;
            const btn = document.getElementById('btnStart');
            btn.textContent = isRunning ? 'STOP SIMULATION' : 'START SIMULATION';
            btn.classList.toggle('active', isRunning);
        }

        function resetSystem() {
            initOscillators();
            z = 0.5;
            document.getElementById('zHeightSlider').value = 0.5;
            document.getElementById('zHeightValue').textContent = '0.50';
        }

        function triggerEmergence() {
            // Force low coherence by dispersing phases
            for (let i = 0; i < N; i++) {
                phases[i] = Math.random() * TWO_PI;
            }
            z = 0.9;  // Above critical
            document.getElementById('zHeightSlider').value = 0.9;
            document.getElementById('zHeightValue').textContent = '0.90';
        }

        function setZHeight(value) {
            z = parseFloat(value);
            mu_E = z;
            document.getElementById('zHeightValue').textContent = parseFloat(value).toFixed(2);
        }

        function setKFib(value) {
            K_base = parseFloat(value);
            document.getElementById('kFibValue').textContent = parseFloat(value).toFixed(3);
        }

        // ================================================================
        // INIT
        // ================================================================

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
