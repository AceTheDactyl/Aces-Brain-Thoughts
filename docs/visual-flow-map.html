<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual Flow Map | Bidirectional Entrainment Loop | The Coupler</title>
    <style>
        :root {
            --bg-void: #030308;
            --bg-panel: rgba(15, 12, 25, 0.95);
            --bg-card: #0d0d12;
            --phi-gold: #ffd700;
            --e-cyan: #22d3ee;
            --pi-magenta: #cc5de8;
            --true-green: #69db7c;
            --untrue-amber: #ffa94d;
            --paradox-red: #ff6b6b;
            --text-primary: rgba(255, 245, 230, 0.9);
            --text-dim: rgba(255, 220, 180, 0.5);
            --rule: #1a1a24;
            --user-color: #22d3ee;
            --system-color: #cc5de8;
            --coupling-color: #69db7c;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: var(--bg-void);
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.6;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
        }

        nav {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        nav a {
            color: var(--text-dim);
            text-decoration: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        nav a:hover, nav a.active {
            color: var(--phi-gold);
            background: rgba(255, 215, 0, 0.1);
        }

        header {
            text-align: center;
            padding: 20px;
            margin-bottom: 20px;
        }

        h1 {
            font-size: 2.2rem;
            font-weight: 100;
            letter-spacing: 6px;
            margin-bottom: 10px;
            background: linear-gradient(135deg, var(--user-color), var(--coupling-color), var(--system-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            color: var(--text-dim);
            font-size: 0.9rem;
            letter-spacing: 2px;
        }

        /* Main Flow Visualization */
        .flow-container {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        @media (max-width: 1200px) {
            .flow-container { grid-template-columns: 1fr; }
        }

        .panel {
            background: var(--bg-panel);
            border: 1px solid var(--rule);
            border-radius: 12px;
            padding: 20px;
        }

        .panel-title {
            font-size: 0.85rem;
            letter-spacing: 3px;
            color: var(--phi-gold);
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--rule);
        }

        /* User Node */
        .user-node {
            border-color: var(--user-color);
        }

        .user-node .panel-title {
            color: var(--user-color);
        }

        /* System Node */
        .system-node {
            border-color: var(--system-color);
        }

        .system-node .panel-title {
            color: var(--system-color);
        }

        /* Phase Display */
        .phase-display {
            text-align: center;
            padding: 20px;
            background: var(--bg-card);
            border-radius: 10px;
            margin-bottom: 15px;
        }

        .phase-circle-container {
            position: relative;
            width: 150px;
            height: 150px;
            margin: 0 auto 15px;
        }

        .phase-circle-container canvas {
            width: 100%;
            height: 100%;
        }

        .phase-value {
            font-size: 2rem;
            font-weight: 300;
        }

        .phase-value.user { color: var(--user-color); }
        .phase-value.system { color: var(--system-color); }

        .phase-label {
            font-size: 0.7rem;
            color: var(--text-dim);
            letter-spacing: 1px;
            margin-top: 5px;
        }

        /* Biosignal Status */
        .biosignal-status {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .bio-card {
            background: var(--bg-card);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
        }

        .bio-value {
            font-size: 1.3rem;
            color: var(--user-color);
        }

        .bio-label {
            font-size: 0.65rem;
            color: var(--text-dim);
            margin-top: 4px;
        }

        /* Central Flow Canvas */
        #flowCanvas {
            width: 100%;
            height: 400px;
            background: var(--bg-card);
            border-radius: 10px;
        }

        /* Entrainment Score */
        .entrainment-display {
            text-align: center;
            padding: 20px;
            background: var(--bg-card);
            border-radius: 10px;
            margin-top: 20px;
        }

        .score-value {
            font-size: 3.5rem;
            font-weight: 200;
        }

        .score-value.locked { color: var(--true-green); }
        .score-value.partial { color: var(--untrue-amber); }
        .score-value.free { color: var(--paradox-red); }

        .score-label {
            font-size: 0.8rem;
            color: var(--text-dim);
            letter-spacing: 2px;
            margin-top: 5px;
        }

        /* Phase Delta */
        .phase-delta {
            text-align: center;
            padding: 15px;
            background: linear-gradient(135deg, rgba(34,211,238,0.1), rgba(204,93,232,0.1));
            border-radius: 10px;
            margin-top: 15px;
        }

        .delta-value {
            font-size: 2rem;
            color: var(--coupling-color);
        }

        .delta-status {
            font-size: 0.7rem;
            color: var(--text-dim);
            margin-top: 5px;
        }

        /* Coupling Indicator */
        .coupling-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            padding: 15px;
            margin-top: 15px;
        }

        .coupling-arrow {
            font-size: 2rem;
            color: var(--coupling-color);
            animation: pulseArrow 1s ease-in-out infinite;
        }

        .coupling-arrow.weak { opacity: 0.3; }
        .coupling-arrow.medium { opacity: 0.6; }
        .coupling-arrow.strong { opacity: 1; }

        @keyframes pulseArrow {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        /* Entrainment History Graph */
        .history-panel {
            margin-top: 20px;
        }

        #historyCanvas {
            width: 100%;
            height: 150px;
            background: var(--bg-card);
            border-radius: 10px;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            background: var(--bg-card);
            border: 1px solid var(--rule);
            border-radius: 8px;
            padding: 12px 24px;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover { border-color: var(--phi-gold); }
        .btn.primary { background: linear-gradient(135deg, rgba(34, 211, 238, 0.3), rgba(105, 219, 124, 0.3)); border-color: var(--coupling-color); }
        .btn.active { border-color: var(--coupling-color); color: var(--coupling-color); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Test Section */
        .test-section {
            text-align: center;
            padding: 30px;
            background: linear-gradient(180deg, transparent 0%, rgba(255,215,0,0.02) 100%);
            border-radius: 12px;
            margin-top: 30px;
        }

        .test-question {
            font-size: 1.5rem;
            color: var(--phi-gold);
            font-style: italic;
            margin-bottom: 20px;
        }

        .test-metrics {
            display: flex;
            justify-content: center;
            gap: 40px;
            flex-wrap: wrap;
        }

        .test-metric {
            text-align: center;
        }

        .test-metric-value {
            font-size: 2rem;
            font-weight: 200;
        }

        .test-metric-value.pass { color: var(--true-green); }
        .test-metric-value.fail { color: var(--paradox-red); }
        .test-metric-value.pending { color: var(--text-dim); }

        .test-metric-label {
            font-size: 0.75rem;
            color: var(--text-dim);
            margin-top: 5px;
        }

        /* Loop Status */
        .loop-status {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--bg-panel);
            border: 1px solid var(--rule);
            border-radius: 10px;
            padding: 15px 20px;
            font-size: 0.8rem;
        }

        .loop-status.closed { border-color: var(--true-green); }
        .loop-status.open { border-color: var(--paradox-red); }

        .loop-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .loop-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: blink 1s ease-in-out infinite;
        }

        .loop-dot.closed { background: var(--true-green); }
        .loop-dot.open { background: var(--paradox-red); }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        footer {
            text-align: center;
            padding: 30px;
            color: var(--text-dim);
            font-size: 0.75rem;
            border-top: 1px solid var(--rule);
            margin-top: 40px;
        }
    </style>
</head>
<body>
    <div class="container">
        <nav>
            <a href="index.html">Home</a>
            <a href="limnus-architecture.html">LIMNUS</a>
            <a href="entrainment-engine.html">Entrainment</a>
            <a href="visual-flow-map.html" class="active">Flow Map</a>
            <a href="apl-mrp-bridge.html">APL→MRP</a>
        </nav>

        <header>
            <h1>THE COUPLER</h1>
            <p class="subtitle">Bidirectional Entrainment Loop · Visual Flow Map</p>
        </header>

        <div class="controls">
            <button class="btn primary" id="btnStart" onclick="toggleLoop()">START ENTRAINMENT</button>
            <button class="btn" id="btnTap" onclick="tapBeat()">TAP BEAT</button>
            <button class="btn" id="btnConnect" onclick="connectBiosignal()">CONNECT HRM</button>
        </div>

        <div class="flow-container">
            <!-- User Node (Left) -->
            <div class="panel user-node">
                <div class="panel-title">USER (NERVOUS SYSTEM)</div>

                <div class="phase-display">
                    <div class="phase-circle-container">
                        <canvas id="userPhaseCanvas"></canvas>
                    </div>
                    <div class="phase-value user" id="userPhaseValue">0.00</div>
                    <div class="phase-label">USER PHASE (rad)</div>
                </div>

                <div class="biosignal-status">
                    <div class="bio-card">
                        <div class="bio-value" id="hrValue">--</div>
                        <div class="bio-label">HEART RATE</div>
                    </div>
                    <div class="bio-card">
                        <div class="bio-value" id="rrValue">--</div>
                        <div class="bio-label">RR INTERVAL</div>
                    </div>
                    <div class="bio-card">
                        <div class="bio-value" id="tapBpm">--</div>
                        <div class="bio-label">TAP BPM</div>
                    </div>
                    <div class="bio-card">
                        <div class="bio-value" id="keystrokeCV">--</div>
                        <div class="bio-label">KEYSTROKE CV</div>
                    </div>
                </div>

                <div class="coupling-indicator">
                    <span style="color: var(--user-color);">USER</span>
                    <span class="coupling-arrow" id="arrowToSystem">→</span>
                    <span style="color: var(--text-dim);">inject</span>
                </div>
            </div>

            <!-- Central Flow Visualization -->
            <div class="panel" style="border-color: var(--coupling-color);">
                <div class="panel-title" style="color: var(--coupling-color);">BIDIRECTIONAL ENTRAINMENT LOOP</div>

                <canvas id="flowCanvas"></canvas>

                <div class="phase-delta">
                    <div class="delta-value" id="phaseDelta">0.00 rad</div>
                    <div class="delta-status" id="deltaStatus">Phase difference: 0ms lag</div>
                </div>

                <div class="entrainment-display">
                    <div class="score-value free" id="entrainmentScore">0%</div>
                    <div class="score-label">ENTRAINMENT SCORE (cos(Δφ))</div>
                </div>

                <div class="history-panel">
                    <canvas id="historyCanvas"></canvas>
                </div>
            </div>

            <!-- System Node (Right) -->
            <div class="panel system-node">
                <div class="panel-title">SYSTEM (OSCILLATOR BANK)</div>

                <div class="phase-display">
                    <div class="phase-circle-container">
                        <canvas id="systemPhaseCanvas"></canvas>
                    </div>
                    <div class="phase-value system" id="systemPhaseValue">0.00</div>
                    <div class="phase-label">SYSTEM PHASE ψ (rad)</div>
                </div>

                <div class="biosignal-status">
                    <div class="bio-card">
                        <div class="bio-value" id="orderR">0.00</div>
                        <div class="bio-label">ORDER r</div>
                    </div>
                    <div class="bio-card">
                        <div class="bio-value" id="couplingK">1.00</div>
                        <div class="bio-label">COUPLING K</div>
                    </div>
                    <div class="bio-card">
                        <div class="bio-value" id="oscCount">32</div>
                        <div class="bio-label">N OSCILLATORS</div>
                    </div>
                    <div class="bio-card">
                        <div class="bio-value" id="systemBpm">60</div>
                        <div class="bio-label">OUTPUT BPM</div>
                    </div>
                </div>

                <div class="coupling-indicator">
                    <span style="color: var(--text-dim);">adapt</span>
                    <span class="coupling-arrow" id="arrowToUser">←</span>
                    <span style="color: var(--system-color);">SYSTEM</span>
                </div>
            </div>
        </div>

        <!-- The Test -->
        <div class="test-section">
            <div class="test-question">"Can you hold a beat with me — without lag?"</div>
            <div class="test-metrics">
                <div class="test-metric">
                    <div class="test-metric-value pending" id="testLag">--</div>
                    <div class="test-metric-label">PHASE LAG (< 50ms)</div>
                </div>
                <div class="test-metric">
                    <div class="test-metric-value pending" id="testCoherence">--</div>
                    <div class="test-metric-label">COHERENCE (> 0.7)</div>
                </div>
                <div class="test-metric">
                    <div class="test-metric-value pending" id="testDuration">--</div>
                    <div class="test-metric-label">SUSTAINED (> 30s)</div>
                </div>
                <div class="test-metric">
                    <div class="test-metric-value pending" id="testResult">--</div>
                    <div class="test-metric-label">THE COUPLER</div>
                </div>
            </div>
        </div>

        <footer>
            Visual Flow Map · Bidirectional Entrainment · The Coupler Test<br>
            <span style="color:var(--user-color)">User</span> ↔
            <span style="color:var(--coupling-color)">Coupling</span> ↔
            <span style="color:var(--system-color)">System</span>
        </footer>
    </div>

    <!-- Loop Status Indicator -->
    <div class="loop-status open" id="loopStatus">
        <div class="loop-indicator">
            <div class="loop-dot open" id="loopDot"></div>
            <span id="loopText">LOOP OPEN</span>
        </div>
    </div>

    <script>
        // ================================================================
        // VISUAL FLOW MAP - BIDIRECTIONAL ENTRAINMENT VISUALIZATION
        // ================================================================

        const PHI = (1 + Math.sqrt(5)) / 2;
        const TWO_PI = Math.PI * 2;
        const Z_CRITICAL = Math.sqrt(3) / 2;

        // State
        let audioContext = null;
        let isRunning = false;
        let animationId = null;

        // Phase state
        let userPhase = 0;
        let systemPhase = 0;
        let phaseDelta = 0;
        let entrainmentScore = 0;

        // Kuramoto oscillator bank
        let N = 32;
        let K = 1.0;
        let targetCoherence = 0.7;
        let adaptationRate = 0.01;
        let phases = new Float32Array(N);
        let frequencies = new Float32Array(N);

        // Biosignal
        let hrDevice = null;
        let rrIntervals = [];
        let tapTimes = [];
        let keystrokeIntervals = [];

        // History
        let entrainmentHistory = [];
        let coherenceHistory = [];
        const HISTORY_LENGTH = 200;

        // Test metrics
        let testStartTime = null;
        let sustainedLockStart = null;
        let maxSustainedDuration = 0;

        // Canvases
        let userCanvas, userCtx;
        let systemCanvas, systemCtx;
        let flowCanvas, flowCtx;
        let historyCanvas, historyCtx;

        // ================================================================
        // INITIALIZATION
        // ================================================================

        function init() {
            initCanvases();
            initOscillators();
            setupKeystrokeMonitor();
            draw();
        }

        function initCanvases() {
            const dpr = window.devicePixelRatio || 1;

            userCanvas = document.getElementById('userPhaseCanvas');
            userCtx = userCanvas.getContext('2d');
            userCanvas.width = 150 * dpr;
            userCanvas.height = 150 * dpr;
            userCtx.scale(dpr, dpr);

            systemCanvas = document.getElementById('systemPhaseCanvas');
            systemCtx = systemCanvas.getContext('2d');
            systemCanvas.width = 150 * dpr;
            systemCanvas.height = 150 * dpr;
            systemCtx.scale(dpr, dpr);

            flowCanvas = document.getElementById('flowCanvas');
            flowCtx = flowCanvas.getContext('2d');
            const flowRect = flowCanvas.getBoundingClientRect();
            flowCanvas.width = flowRect.width * dpr;
            flowCanvas.height = 400 * dpr;
            flowCanvas.style.width = flowRect.width + 'px';
            flowCanvas.style.height = '400px';
            flowCtx.scale(dpr, dpr);

            historyCanvas = document.getElementById('historyCanvas');
            historyCtx = historyCanvas.getContext('2d');
            const histRect = historyCanvas.getBoundingClientRect();
            historyCanvas.width = histRect.width * dpr;
            historyCanvas.height = 150 * dpr;
            historyCanvas.style.width = histRect.width + 'px';
            historyCanvas.style.height = '150px';
            historyCtx.scale(dpr, dpr);

            window.addEventListener('resize', initCanvases);
        }

        function initOscillators() {
            phases = new Float32Array(N);
            frequencies = new Float32Array(N);
            for (let i = 0; i < N; i++) {
                phases[i] = Math.random() * TWO_PI;
                frequencies[i] = 1.0 + gaussianRandom() * 0.2;
            }
        }

        function gaussianRandom() {
            const u1 = Math.random();
            const u2 = Math.random();
            return Math.sqrt(-2 * Math.log(u1)) * Math.cos(TWO_PI * u2);
        }

        // ================================================================
        // KURAMOTO DYNAMICS
        // ================================================================

        function calculateOrderParameter() {
            let sumReal = 0, sumImag = 0;
            for (let i = 0; i < N; i++) {
                sumReal += Math.cos(phases[i]);
                sumImag += Math.sin(phases[i]);
            }
            const r = Math.hypot(sumReal / N, sumImag / N);
            const psi = Math.atan2(sumImag / N, sumReal / N);
            return { r, psi };
        }

        function stepKuramoto(dt = 0.02) {
            const { r, psi } = calculateOrderParameter();
            const newPhases = new Float32Array(N);

            // Heun's method
            for (let i = 0; i < N; i++) {
                const dtheta1 = frequencies[i] + K * r * Math.sin(psi - phases[i]);
                const thetaPred = phases[i] + dt * dtheta1;
                const dtheta2 = frequencies[i] + K * r * Math.sin(psi - thetaPred);
                newPhases[i] = (phases[i] + dt * (dtheta1 + dtheta2) / 2) % TWO_PI;
                if (newPhases[i] < 0) newPhases[i] += TWO_PI;
            }

            // Bidirectional coupling: inject user phase
            const injectionStrength = 0.1 * (1 - r);
            const diff = userPhase - newPhases[0];
            newPhases[0] += injectionStrength * Math.sin(diff);
            newPhases[0] = ((newPhases[0] % TWO_PI) + TWO_PI) % TWO_PI;

            // Adaptive coupling strength
            const error = targetCoherence - r;
            K += adaptationRate * error;
            K = Math.max(0.1, Math.min(5.0, K));

            phases = newPhases;
            return { r, psi };
        }

        // ================================================================
        // PHASE COMPARISON
        // ================================================================

        function circularDiff(a, b) {
            let diff = a - b;
            if (diff > Math.PI) diff -= TWO_PI;
            if (diff < -Math.PI) diff += TWO_PI;
            return diff;
        }

        function calculateEntrainment() {
            phaseDelta = circularDiff(userPhase, systemPhase);
            entrainmentScore = Math.cos(phaseDelta) * 0.5 + 0.5;
            return { phaseDelta, entrainmentScore };
        }

        // ================================================================
        // BIOSIGNAL INPUT
        // ================================================================

        async function connectBiosignal() {
            if (!navigator.bluetooth) {
                alert('WebBluetooth not supported. Use tap input instead.');
                return;
            }

            try {
                const device = await navigator.bluetooth.requestDevice({
                    filters: [{ services: ['heart_rate'] }]
                });

                const server = await device.gatt.connect();
                const service = await server.getPrimaryService('heart_rate');
                const characteristic = await service.getCharacteristic('heart_rate_measurement');

                await characteristic.startNotifications();
                characteristic.addEventListener('characteristicvaluechanged', handleHRData);

                hrDevice = device;
                document.getElementById('btnConnect').textContent = 'HRM CONNECTED';
                document.getElementById('btnConnect').classList.add('active');
            } catch (error) {
                console.error('HRM connection failed:', error);
            }
        }

        function handleHRData(event) {
            const value = event.target.value;
            const flags = value.getUint8(0);
            const is16Bit = (flags & 0x01) !== 0;
            const hasRR = (flags & 0x10) !== 0;

            let offset = 1;
            const heartRate = is16Bit ? value.getUint16(offset, true) : value.getUint8(offset);
            offset += is16Bit ? 2 : 1;

            document.getElementById('hrValue').textContent = heartRate;

            if (hasRR) {
                if (flags & 0x08) offset += 2;
                while (offset < value.byteLength) {
                    const rr = (value.getUint16(offset, true) / 1024) * 1000;
                    rrIntervals.push(rr);
                    if (rrIntervals.length > 30) rrIntervals.shift();
                    offset += 2;
                }

                if (rrIntervals.length >= 2) {
                    const lastRR = rrIntervals[rrIntervals.length - 1];
                    const avgRR = rrIntervals.reduce((a, b) => a + b) / rrIntervals.length;
                    document.getElementById('rrValue').textContent = Math.round(lastRR);
                    userPhase = (lastRR / avgRR) * TWO_PI % TWO_PI;
                }
            }
        }

        function tapBeat() {
            const now = performance.now();
            tapTimes.push(now);
            if (tapTimes.length > 10) tapTimes.shift();

            if (tapTimes.length >= 2) {
                const intervals = [];
                for (let i = 1; i < tapTimes.length; i++) {
                    intervals.push(tapTimes[i] - tapTimes[i - 1]);
                }
                const avgInterval = intervals.reduce((a, b) => a + b) / intervals.length;
                const bpm = Math.round(60000 / avgInterval);
                document.getElementById('tapBpm').textContent = bpm;

                // Convert to phase
                const lastInterval = intervals[intervals.length - 1];
                userPhase = (lastInterval / avgInterval) * TWO_PI % TWO_PI;
            }
        }

        function setupKeystrokeMonitor() {
            let lastKeyTime = 0;
            document.addEventListener('keydown', () => {});
            document.addEventListener('keyup', () => {
                const now = performance.now();
                if (lastKeyTime) {
                    const interval = now - lastKeyTime;
                    keystrokeIntervals.push(interval);
                    if (keystrokeIntervals.length > 30) keystrokeIntervals.shift();

                    if (keystrokeIntervals.length >= 5) {
                        const mean = keystrokeIntervals.reduce((a, b) => a + b) / keystrokeIntervals.length;
                        const variance = keystrokeIntervals.map(x => (x - mean) ** 2).reduce((a, b) => a + b) / keystrokeIntervals.length;
                        const cv = 1 - Math.min(1, Math.sqrt(variance) / mean);
                        document.getElementById('keystrokeCV').textContent = cv.toFixed(2);

                        // Modulate user phase slightly
                        userPhase = (userPhase + (interval / 200) * 0.1) % TWO_PI;
                    }
                }
                lastKeyTime = now;
            });
        }

        // ================================================================
        // DRAWING
        // ================================================================

        function drawPhaseCircle(ctx, phase, color, label) {
            const w = 150, h = 150;
            const cx = w / 2, cy = h / 2;
            const radius = 50;

            ctx.clearRect(0, 0, w, h);

            // Background circle
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, TWO_PI);
            ctx.stroke();

            // Phase arc
            ctx.strokeStyle = color;
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.arc(cx, cy, radius, -Math.PI / 2, -Math.PI / 2 + phase);
            ctx.stroke();

            // Phase pointer
            const px = cx + Math.cos(phase - Math.PI / 2) * radius;
            const py = cy + Math.sin(phase - Math.PI / 2) * radius;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(px, py, 8, 0, TWO_PI);
            ctx.fill();
        }

        function drawFlowVisualization() {
            const w = flowCanvas.width / (window.devicePixelRatio || 1);
            const h = flowCanvas.height / (window.devicePixelRatio || 1);

            flowCtx.fillStyle = '#0d0d12';
            flowCtx.fillRect(0, 0, w, h);

            const cx = w / 2;
            const cy = h / 2;
            const radius = 120;

            // Draw the loop arc
            flowCtx.strokeStyle = 'rgba(255,255,255,0.1)';
            flowCtx.lineWidth = 40;
            flowCtx.beginPath();
            flowCtx.arc(cx, cy, radius, 0, TWO_PI);
            flowCtx.stroke();

            // User phase arc (left side, blue)
            flowCtx.strokeStyle = 'rgba(34, 211, 238, 0.6)';
            flowCtx.lineWidth = 35;
            flowCtx.beginPath();
            flowCtx.arc(cx, cy, radius, Math.PI, Math.PI + userPhase / 2);
            flowCtx.stroke();

            // System phase arc (right side, magenta)
            flowCtx.strokeStyle = 'rgba(204, 93, 232, 0.6)';
            flowCtx.lineWidth = 35;
            flowCtx.beginPath();
            flowCtx.arc(cx, cy, radius, 0, systemPhase / 2);
            flowCtx.stroke();

            // Coupling zone (green, shows entrainment)
            const couplingAlpha = entrainmentScore;
            flowCtx.strokeStyle = `rgba(105, 219, 124, ${couplingAlpha})`;
            flowCtx.lineWidth = 8;
            flowCtx.setLineDash([10, 5]);
            flowCtx.beginPath();
            flowCtx.arc(cx, cy, radius + 30, 0, TWO_PI);
            flowCtx.stroke();
            flowCtx.setLineDash([]);

            // Draw oscillator points around the circle
            for (let i = 0; i < N; i++) {
                const angle = phases[i] - Math.PI / 2;
                const r = radius - 20;
                const x = cx + Math.cos(angle) * r;
                const y = cy + Math.sin(angle) * r;

                // Color by zone
                let color;
                const normalizedPhase = phases[i] / TWO_PI;
                if (normalizedPhase < 0.43) color = '#ffd700';
                else if (normalizedPhase < 0.71) color = '#22d3ee';
                else color = '#cc5de8';

                flowCtx.fillStyle = color;
                flowCtx.globalAlpha = 0.7;
                flowCtx.beginPath();
                flowCtx.arc(x, y, 4, 0, TWO_PI);
                flowCtx.fill();
            }
            flowCtx.globalAlpha = 1;

            // Order parameter vector
            const { r, psi } = calculateOrderParameter();
            const vecX = cx + Math.cos(psi - Math.PI / 2) * radius * r;
            const vecY = cy + Math.sin(psi - Math.PI / 2) * radius * r;

            flowCtx.strokeStyle = '#69db7c';
            flowCtx.lineWidth = 3;
            flowCtx.beginPath();
            flowCtx.moveTo(cx, cy);
            flowCtx.lineTo(vecX, vecY);
            flowCtx.stroke();

            flowCtx.fillStyle = '#69db7c';
            flowCtx.beginPath();
            flowCtx.arc(vecX, vecY, 10, 0, TWO_PI);
            flowCtx.fill();

            // User phase indicator
            const userX = cx + Math.cos(userPhase - Math.PI / 2) * (radius + 50);
            const userY = cy + Math.sin(userPhase - Math.PI / 2) * (radius + 50);
            flowCtx.fillStyle = '#22d3ee';
            flowCtx.beginPath();
            flowCtx.arc(userX, userY, 12, 0, TWO_PI);
            flowCtx.fill();

            // Labels
            flowCtx.font = '11px SF Mono, monospace';
            flowCtx.fillStyle = '#22d3ee';
            flowCtx.fillText('USER', userX - 18, userY + 25);

            flowCtx.fillStyle = '#cc5de8';
            flowCtx.fillText('SYSTEM', vecX - 25, vecY + 25);

            // Draw bidirectional arrows
            drawBidirectionalArrows(cx, cy, radius);
        }

        function drawBidirectionalArrows(cx, cy, radius) {
            const arrowStrength = entrainmentScore;

            // Arrow from user to system (injection)
            flowCtx.strokeStyle = `rgba(34, 211, 238, ${0.3 + arrowStrength * 0.7})`;
            flowCtx.lineWidth = 2 + arrowStrength * 3;

            const time = Date.now() / 1000;
            const offset = (time % 1) * 40;

            // Top arc arrow (user → system)
            for (let i = 0; i < 3; i++) {
                const pos = ((offset + i * 40) % 120) / 120;
                const angle = Math.PI + pos * Math.PI;
                const x = cx + Math.cos(angle) * (radius + 45);
                const y = cy + Math.sin(angle) * (radius + 45);

                flowCtx.beginPath();
                flowCtx.arc(x, y, 3, 0, TWO_PI);
                flowCtx.fill();
            }

            // Bottom arc arrow (system → user adaptation)
            flowCtx.strokeStyle = `rgba(204, 93, 232, ${0.3 + arrowStrength * 0.7})`;
            for (let i = 0; i < 3; i++) {
                const pos = ((offset + i * 40) % 120) / 120;
                const angle = pos * Math.PI;
                const x = cx + Math.cos(angle) * (radius + 45);
                const y = cy + Math.sin(angle) * (radius + 45);

                flowCtx.beginPath();
                flowCtx.arc(x, y, 3, 0, TWO_PI);
                flowCtx.fill();
            }
        }

        function drawHistory() {
            const w = historyCanvas.width / (window.devicePixelRatio || 1);
            const h = historyCanvas.height / (window.devicePixelRatio || 1);

            historyCtx.fillStyle = '#0d0d12';
            historyCtx.fillRect(0, 0, w, h);

            if (entrainmentHistory.length < 2) return;

            // Target coherence line
            historyCtx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
            historyCtx.lineWidth = 1;
            historyCtx.setLineDash([5, 5]);
            const targetY = h - targetCoherence * h * 0.9 - 5;
            historyCtx.beginPath();
            historyCtx.moveTo(0, targetY);
            historyCtx.lineTo(w, targetY);
            historyCtx.stroke();
            historyCtx.setLineDash([]);

            // Entrainment history (green line)
            historyCtx.strokeStyle = '#69db7c';
            historyCtx.lineWidth = 2;
            historyCtx.beginPath();
            for (let i = 0; i < entrainmentHistory.length; i++) {
                const x = (i / HISTORY_LENGTH) * w;
                const y = h - entrainmentHistory[i] * h * 0.9 - 5;
                if (i === 0) historyCtx.moveTo(x, y);
                else historyCtx.lineTo(x, y);
            }
            historyCtx.stroke();

            // Coherence history (cyan line)
            historyCtx.strokeStyle = '#22d3ee';
            historyCtx.lineWidth = 1;
            historyCtx.globalAlpha = 0.6;
            historyCtx.beginPath();
            for (let i = 0; i < coherenceHistory.length; i++) {
                const x = (i / HISTORY_LENGTH) * w;
                const y = h - coherenceHistory[i] * h * 0.9 - 5;
                if (i === 0) historyCtx.moveTo(x, y);
                else historyCtx.lineTo(x, y);
            }
            historyCtx.stroke();
            historyCtx.globalAlpha = 1;

            // Labels
            historyCtx.font = '10px SF Mono, monospace';
            historyCtx.fillStyle = '#69db7c';
            historyCtx.fillText('Entrainment', 5, 15);
            historyCtx.fillStyle = '#22d3ee';
            historyCtx.fillText('Coherence', 100, 15);
        }

        // ================================================================
        // UI UPDATE
        // ================================================================

        function updateUI() {
            const { r, psi } = stepKuramoto();
            systemPhase = (psi + Math.PI) % TWO_PI;

            calculateEntrainment();

            // Update histories
            entrainmentHistory.push(entrainmentScore);
            coherenceHistory.push(r);
            if (entrainmentHistory.length > HISTORY_LENGTH) entrainmentHistory.shift();
            if (coherenceHistory.length > HISTORY_LENGTH) coherenceHistory.shift();

            // Update UI elements
            document.getElementById('userPhaseValue').textContent = userPhase.toFixed(2);
            document.getElementById('systemPhaseValue').textContent = systemPhase.toFixed(2);
            document.getElementById('orderR').textContent = r.toFixed(2);
            document.getElementById('couplingK').textContent = K.toFixed(2);

            const entrainmentPct = Math.round(entrainmentScore * 100);
            const scoreEl = document.getElementById('entrainmentScore');
            scoreEl.textContent = entrainmentPct + '%';
            scoreEl.className = 'score-value ' + (entrainmentScore > 0.7 ? 'locked' : entrainmentScore > 0.4 ? 'partial' : 'free');

            // Phase delta
            const lagMs = Math.abs(phaseDelta) / TWO_PI * (60000 / 60); // Approximate ms at 60 BPM
            document.getElementById('phaseDelta').textContent = phaseDelta.toFixed(3) + ' rad';
            document.getElementById('deltaStatus').textContent = `Phase difference: ${lagMs.toFixed(1)}ms lag`;

            // Coupling arrows
            const arrowStrength = entrainmentScore > 0.7 ? 'strong' : entrainmentScore > 0.4 ? 'medium' : 'weak';
            document.getElementById('arrowToSystem').className = 'coupling-arrow ' + arrowStrength;
            document.getElementById('arrowToUser').className = 'coupling-arrow ' + arrowStrength;

            // Loop status
            const loopClosed = entrainmentScore > 0.7;
            document.getElementById('loopStatus').className = 'loop-status ' + (loopClosed ? 'closed' : 'open');
            document.getElementById('loopDot').className = 'loop-dot ' + (loopClosed ? 'closed' : 'open');
            document.getElementById('loopText').textContent = loopClosed ? 'LOOP CLOSED' : 'LOOP OPEN';

            // Test metrics
            updateTestMetrics(r, lagMs);
        }

        function updateTestMetrics(r, lagMs) {
            if (!testStartTime) return;

            const elapsed = (performance.now() - testStartTime) / 1000;
            const loopClosed = entrainmentScore > 0.7;

            // Track sustained lock
            if (loopClosed) {
                if (!sustainedLockStart) sustainedLockStart = performance.now();
                const currentDuration = (performance.now() - sustainedLockStart) / 1000;
                if (currentDuration > maxSustainedDuration) maxSustainedDuration = currentDuration;
            } else {
                sustainedLockStart = null;
            }

            // Update display
            const lagEl = document.getElementById('testLag');
            lagEl.textContent = lagMs.toFixed(1) + 'ms';
            lagEl.className = 'test-metric-value ' + (lagMs < 50 ? 'pass' : 'fail');

            const cohEl = document.getElementById('testCoherence');
            cohEl.textContent = r.toFixed(2);
            cohEl.className = 'test-metric-value ' + (r > 0.7 ? 'pass' : 'fail');

            const durEl = document.getElementById('testDuration');
            durEl.textContent = maxSustainedDuration.toFixed(1) + 's';
            durEl.className = 'test-metric-value ' + (maxSustainedDuration > 30 ? 'pass' : 'pending');

            const resultEl = document.getElementById('testResult');
            const passed = lagMs < 50 && r > 0.7 && maxSustainedDuration > 30;
            resultEl.textContent = passed ? 'ACTIVE' : elapsed > 60 ? 'TESTING...' : 'CALIBRATING';
            resultEl.className = 'test-metric-value ' + (passed ? 'pass' : 'pending');
        }

        // ================================================================
        // DRAW LOOP
        // ================================================================

        function draw() {
            if (isRunning) {
                updateUI();
            }

            drawPhaseCircle(userCtx, userPhase, '#22d3ee', 'USER');
            drawPhaseCircle(systemCtx, systemPhase, '#cc5de8', 'SYSTEM');
            drawFlowVisualization();
            drawHistory();

            animationId = requestAnimationFrame(draw);
        }

        // ================================================================
        // CONTROLS
        // ================================================================

        function toggleLoop() {
            isRunning = !isRunning;
            const btn = document.getElementById('btnStart');

            if (isRunning) {
                btn.textContent = 'STOP ENTRAINMENT';
                btn.classList.add('active');
                testStartTime = performance.now();
                sustainedLockStart = null;
                maxSustainedDuration = 0;
            } else {
                btn.textContent = 'START ENTRAINMENT';
                btn.classList.remove('active');
            }
        }

        // ================================================================
        // INIT
        // ================================================================

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
